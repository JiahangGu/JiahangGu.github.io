<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="认真学习，享受生活">
<meta property="og:type" content="website">
<meta property="og:title" content="菜汤里的咸鱼要翻身">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="菜汤里的咸鱼要翻身">
<meta property="og:description" content="认真学习，享受生活">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jiahang Gu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>菜汤里的咸鱼要翻身</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">菜汤里的咸鱼要翻身</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">设计模式面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 13:21:49 / 修改时间：13:22:55" itemprop="dateCreated datePublished" datetime="2022-02-21T13:21:49+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>*表示重要程度，题目摘抄自<a target="_blank" rel="noopener" href="https://github.com/liguigui/CyC2018-CS-Notes">Cyc2018</a>，答案为自己的理解</p>
<h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="*** 面向对象三大特性"></a>*** 面向对象三大特性</h3><ol>
<li>封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能隐藏内部细节，只保留一些对外接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。<br>优点：1）减少耦合：可以独立地开发、测试、优化、使用、理解和修改；2）减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块；3）有效地调节性能：可以通过剖析来确定哪些模块影响了系统地性能；4）提高软件的可重用性；5）降低了构建大型系统的风险：即使整个系统不可用，但是有些独立的模块可能可用</li>
<li>继承：实现了IS-A关系，继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。父类引用指向子类对象称为向上转型。</li>
<li>多态：多态分为编译时多态和运行时多态，编译时多态指方法的重载，运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定。运行时多态有三个条件：继承、覆盖（重写）和向上转型</li>
</ol>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="* 设计原则"></a>* 设计原则</h3><p>S.O.L.I.D</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/%E9%9D%A2%E7%BB%8F%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/%E9%9D%A2%E7%BB%8F%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" class="post-title-link" itemprop="url">面经查漏补缺</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:20:40 / 修改时间：13:07:49" itemprop="dateCreated datePublished" datetime="2022-02-21T12:20:40+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>33 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>力扣842， 8</p>
</li>
<li><p>ping用什么协议实现<br>ICMP协议，发送ICMP回答请求报文，目的主机回复ICMP回答报文，根据时间和成功响应次数计算出往返时间和丢包率</p>
</li>
<li><p>查看转发过程经过哪些路由器的命令<br>使用tracert命令，发送无法交付的udp数据包，并由目的主机发送ICMP不可达差错报文。通过逐渐增加rrt大小的方式直到超过最大限制或找到目的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\fengzhizi&gt;tracert -d www.baidu.com</span><br><span class="line"></span><br><span class="line">通过最多 30 个跃点跟踪</span><br><span class="line">到 www.a.shifen.com [39.156.66.14] 的路由:</span><br><span class="line"></span><br><span class="line">  1     *        *        *     请求超时。</span><br><span class="line">  2     3 ms     7 ms     4 ms  10.0.28.1</span><br><span class="line">  3     6 ms     5 ms     4 ms  10.0.4.21</span><br><span class="line">  4     5 ms     4 ms     5 ms  10.0.3.17</span><br><span class="line">  5     4 ms     4 ms     4 ms  172.30.21.1</span><br><span class="line">  6     7 ms    10 ms     6 ms  10.13.0.1</span><br><span class="line">  7     5 ms     5 ms     4 ms  221.179.158.177</span><br><span class="line">  8     *        *        *     请求超时。</span><br><span class="line">  9     *        *        *     请求超时。</span><br><span class="line"> 10    10 ms     8 ms    10 ms  111.13.121.66</span><br><span class="line"> 11    10 ms     8 ms     8 ms  39.156.27.5</span><br><span class="line"> 12    11 ms    10 ms     9 ms  39.156.67.25</span><br><span class="line"> 13     *        *        *     请求超时。</span><br><span class="line"> 14     *        *        *     请求超时。</span><br><span class="line"> 15     *        *        *     请求超时。</span><br><span class="line"> 16     *        *        *     请求超时。</span><br><span class="line"> 17     9 ms    10 ms     8 ms  39.156.66.14</span><br><span class="line"></span><br><span class="line">跟踪完成。</span><br></pre></td></tr></table></figure></li>
<li><p>TCP报文头有哪些内容<br> 源端口、目的端口、序号、确认号、数据偏移（首部长度）、ACK、SYN、FIN、窗口大小、校验和、填充</p>
</li>
<li><p>多线程并发i++如何同步<br> synchronized、ReentrantLock、原子类Atomic</p>
</li>
<li><p>Synchronized和Lock区别<br> synchronized由jvm实现，lock是jdk实现<br> synchronized在优化后性能和lock接近<br> synchronized不可响应中断<br> lock还可以实现公平锁，synchronized不公平<br> lock可以绑定多个condition对象</p>
</li>
<li><p>内存和外存区别，读写速度差多少数量级<br> 外存是指物理存储。<br> 内存具有易失性，掉电数据丢失<br> 容量小，成本高，读写速度快<br> 内存读取1M数据0.2ms，硬盘需要20ms，差一百倍</p>
</li>
<li><p>mysql如何实现悲观锁<br> select … for update</p>
</li>
<li><p>垃圾收集器有哪些<br> serial、serialOld、ParNew、ParallelScavange、ParallelOld、CMS、G1</p>
</li>
<li><p>cms几个步骤，几次停顿<br>4个步骤<br>1）初始标记：标记下GCRoot可以直连的对象，需要停顿<br>2）并发标记：完整的GCRoot标记过程，耗时最长，不需要停顿<br>3）重新标记：修正并发标记期间程序运行导致标记变动的记录，并发执行，需要停顿<br>4）并发清除；不需要停顿</p>
</li>
<li><p>一辆卡车能装多少乒乓球<br>留坑</p>
</li>
<li><p>jvm结构<br>程序栈空间（程序计数器、本地方法栈、java虚拟机栈）、堆、方法区（放加载的类、常量、静态变量，1.8后放入元空间，位于本机内存）、堆外内存</p>
</li>
<li><p>Spring动态代理<br>jdk动态代理和cglib动态代理。jdk需要定义接口，通过反射实现。cglib通过字节码生成被代理对象的子类，并对请求进行拦截</p>
</li>
<li><p>oom报错类型及原因<br>1）java heap space：堆内存没有足够空间存放新对象。<br>2）GC overhead limit exceeded：java花费98%的时间gc，但只回收了不到2%的内存，且连续5次。因为应用程序基本耗尽所有可用内存，gc无法回收<br>3）permgen space：永久代用满，通常是加载类太多或太大<br>4）metaspace<br>5）unable to create native thread：线程需要内存空间，当jvm请求创建线程没有足够资源分配时<br>6）out of swap space：可用虚拟内存已被耗尽，包括物理内存和交换空间<br>7）kill process or sacrifice child：内核作业out of memory killer，会在内存很低时杀死评分较低的进程<br>8）requested array size exceeds vm limit：超过了jvm限制的数组最大长度<br>9）direct buffer memory：堆外内存默认64M，超出报错</p>
</li>
<li><p>多线程编程的经验<br>1）线程起有意义的名字<br>2）缩小同步范围，减小锁争用<br>3）多用同步工具，CountDonwLatch、CyclicBarrier等同步类简化了编码操作<br>4）多用并发集合少用同步集合<br>5）使用本地变量和不可变类来保证线程安全<br>6）使用线程池而不是直接创建线程<br>7）使用阻塞队列实现生产者-消费者</p>
</li>
<li><p>什么是反射，反射效率为什么低<br>反射就是根据给定的类可以得到声明的方法和属性<br>效率低：<br>1）method和invoke方法对参数做封装和解封<br>2）检查方法可见性<br>3）校验参数<br>4）无法优化：涉及到动态加载<br>优化：<br>1）setAccessible(true)关闭安全检查<br>2）用缓存，将反射的元数据保存起来<br>3）使用高性能反射库，如reflectASM</p>
</li>
<li><p>设计模式<br>工厂模式，迭代器模式，装饰器模式，单例模式，适配器模式，备忘录模式，桥接模式，模板</p>
</li>
<li><p>mysql的事务如何实现<br>锁<br>MVCC</p>
</li>
<li><p>https比http安全的原因<br>http先和ssl（Secure SOckets layer）通信，再由ssl与tcp通信，即使用隧道进行通信，具有加密、认证和完整性保护</p>
</li>
<li><p>5L桶，7L桶，得6L<br>7倒满，然后倒满5，7还剩2，倒掉5，把2倒进5，然后倒满7，用7倒满5，此时7还剩4L，倒掉5，4L倒进5，倒满7，倒满5，此时7里还剩6L</p>
</li>
<li><p>如果你在Linux系统删除一个文件失败，如何解决？被哪个进程占用之类的信息你觉得会存在哪里？如果一个服务端口被占用，如何查看？<br>查看失败原因，比如权限不足等。可以使用lsattr查看文件附加属性，如果有a,i属性则不能被删除，使用chattr -ie 去掉ai属性。或者文件正在被使用。<br>lsof filepath 查看<br>netstat -ntlp查看端口号，状态以及占用pid</p>
</li>
<li><p>类加载机制，双亲委派模型<br>加载、验证、准备、解析、初始化<br>双亲委派：启动类加载器、扩展类加载器、应用程序类加载器。先转发到父类加载器，无法完成才会自己加载。好处是使得所有类加载具有层级关系，使得基础类得到统一</p>
</li>
<li><p>NIO<br>IO以流的方式处理数据，而NIO以块的方式。<br>面向流的IO一次处理一个字节，创建过滤器很容易，但速度慢<br>面向块的IO一次处理一个数据块，速度快，但是缺少优雅性和简单性<br>通道channel对IO的流进行模拟，相对于流只能单向移动，通道可以双向<br>发送到通道的数据必须先经过<strong>缓冲区</strong>。</p>
</li>
<li><p>Select * from a=12 and b between 5 and 9 or c&gt;6;是否用到索引，用到哪些？用到了a，b。<br>索引优化会直到遇到范围匹配为止，所以b和c都是范围匹配，会在遇到b后停止，用到的索引为a，b</p>
</li>
<li><p>HashMap的put过程<br>如果map为空，新建个表。<br>如果key为null则单独放到第一个桶<br>计算hash和桶下标，遍历一次找出是否存在对应key值，如果有更新并返回，这里在比较key的时候会先比较key的哈希值，然后比较key是否指向同一内存区域（使用==）或者是否equals<br>否则元素个数++，插入新键值对</p>
</li>
<li><p>RDB保存时的现象<br>save的话会阻塞主线程，直到数据保存完成、<br>bgsave调用fork创建子进程，并利用写时拷贝实现。fork过程会阻塞很短时间。<br>使用子进程的好处：<br>1）fork创建的子进程能获得和父进程完全相同的内存空间，且父进程对内存修改对于子进程不可见<br>2）fork创建子进程不会触发大量内存拷贝。</p>
</li>
<li><p>StringBuilder和StringBuffer的区别，除了线程安全还有别的嘛<br>1）StringBuffer线程安全，因为所有public方法都是synchronized修饰<br>2）缓冲区：StringBuffer中toString方法使用缓冲区存储String，而StringBuilder每次都要复制一次字符数组<br>3）性能：StringBuilder高</p>
</li>
<li><p>如何找到系统中存在的慢sql，改过mysql配置文件中的哪些参数<br>配置long_query_time定义临界值，所有执行时间超出临界值的sql会被记录到日志中</p>
</li>
<li><p>线程的6种状态<br>NEW、RUNNABLE（包含ready和running）、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</p>
</li>
<li><p>分布式锁有哪些？<br>1）数据库主键，利用主键的唯一性。坏处是释放失败会阻塞别的线程，无法删除<br>2）redis setnx，通过设定同一个key并根据是否设置成功判断是否获得锁<br>3）redis redlock，使用多个redis实例，从n个互相独立的redis实例获取锁，计算消耗时间，只有这个时间小于过期时间且从多数实例都获得锁，才是获得锁成功<br>4）zookeeper有序结点：使用临时有序结点，在一个所目录下创建结点，然后获得目录下结点列表，如果最小的是自己创建的则获得锁，否则监听前一个结点，获得变更通知重复此步骤直到获得锁。会话超时会删除临时结点</p>
</li>
<li><p>future接口底层<br>AQS同步框架，一个volatile int conut记录当前锁的重入次数，同时定义个FIFO的队列记录当前等待执行的线程</p>
</li>
<li><p>for循环里面string用+会发生什么？<br>每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费</p>
</li>
<li><p>一个加减乘除的计算机，你选择什么设计模式？工厂模式是解决什么问题的？<br>策略模式。定义四个操作策略，由环境对象调用。<br>工厂模式也可以。工厂模式是定义创建产品的接口，将实际创建工作推迟到子类中，客户不需要知道产品对象的细节和创建方式，使得系统可以在不修改具体工厂角色的情况下引进新产品<br>简单工厂创建对象时不向客户暴露内部细节，提供一个创建对象的通用接口。<br>工厂模式定义创建对象的接口，但由子类决定实例化哪个，推迟到子类，简单工厂则在工厂类实现。<br>抽象工厂提供一个接口，创建相关的对象家族</p>
</li>
<li><p>策略模式是什么，和工厂模式区别<br>定义一系列算法并封装，且可以互相替换，由环境角色调用策略，客户端决定调用哪种策略。<br>策略模式侧重行为的改变，工厂模式可以为新增对象提供更好的扩展</p>
</li>
<li><p>知道atomicreference吗<br>该类提供了可以原子读写的对象引用变量，会使用CAS操作，可以保证在多线程并发条件下的原子操作</p>
</li>
<li><p>两篇文章，你能判断出来有多少重复的吗？kmp？<br>余弦相似度、最短编辑距离</p>
</li>
<li><p>A发送一段信息到B，B再向A确认收到。使用TCP和UDP各需要几个包？<br>无网络错误前提下，tcp需要5个，udp需要2个</p>
</li>
<li><p>操作系统收到包后如何将包打到80端口？<br>数据包中有目的端口号，解析数据包得到后复制到对应端口的监听进程</p>
</li>
<li><p>统计平均分大于80分的学生中，A课程分数超过90分的学生数</p>
</li>
<li><p>如何在两个非常大的日志文件中查找相同行，并打印到第三个文件当中。<br>主要思路是通过hash集合来查重，但文件太大内存放不下。可以首先将每个文件的行hash映射到一个范围存到文件中，在一个文件的表示数据行hash值相等，然后对每个小文件做重复筛选</p>
</li>
<li><p>服务器收到一个业务请求，从数据库获取数据，再返回数据给前端，一共多少次I/O？<br>接收和返回2次，数据库加载索引和数据2次</p>
</li>
<li><p>lc61， 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置<br>做法是将链表改成环，然后找到需要打破的位置，破坏环</p>
</li>
<li><p>TCP/IP协议栈和OSI五层模型，他们的区别是啥，为什么要划分这两个标准<br>tcp/ip将数据链路层和物理层合并为网络接口层，不严格怎寻osi分层概念，应用层可能直接使用ip层或网络接口层</p>
</li>
<li><p>如果发送方接收方同时发送SYN请求报文，那么是一次连接还是两次连接？</p>
<p>同时发送SYN报文，同时变为SYN-SENT状态，在各自收到SYN后变为SYN-REVD，接着回复对应的ACK+SYN，在对方接收后同时变为ESTABLISHED。两次连接</p>
</li>
<li><p>破坏双亲加载的几种方式，破坏双亲加载是为了什么</p>
<ol>
<li>继承ClassLoader重写loadClass()</li>
<li>使用线程上下文类加载器，通过Thread.setContextClasssLoader设置，如果线程未设置则从父线程继承一个，打破了双亲委派模型的层次结构，逆向使用类加载器</li>
</ol>
</li>
<li><p>zk满足cap的ap还是cp,自己的理解<br>从一个读写请求分析，保证了可用性（不用阻塞等待全部follwer同步完成），保证不了数据的一致性，所以是ap<br>但是从zk架构分析，zk在leader选举期间，会暂停对外提供服务（为啥会暂停，因为zk依赖leader来保证数据一致性)，所以丢失了可用性，保证了一致性。这个c不是强一致性，而是最终一致性。即上面的写案例，数据最终会同步到一致，只是时间问题。</p>
</li>
<li><p>消息队列常用组件原理，零拷贝介绍一下</p>
<ol>
<li>broker：消息队列服务器实体，存储消息</li>
<li>exchange：消息交换机，指定消息路由规则</li>
<li>queue：消息逻辑载体</li>
<li>binding：绑定，exchange和queue绑定</li>
<li>routing key：路由关键字</li>
</ol>
<p>零拷贝是指一种避免cpu将数据从一块存储拷贝到另一块存储的技术，零拷贝技术极大提升应用程序的性能，通过在数据拷贝进行的同时，允许cpu执行其他的任务。零拷贝可以减少数据拷贝和共享总线操作的次数，消除数据不必要的中间拷贝次数。</p>
<p>可以避免不必要的系统调用和上下文切换，需要拷贝的数据可以先被缓存起来，对数据处理时尽量交给硬件来做。</p>
<p>举例：服务端的下载文件功能，服务端将主机磁盘文件不做修改的从已连接的socket发出去。原本操作时将磁盘内容从内核态读到用户空间缓存，再从用户空间缓存拷贝到网络传送所需的内核态。再内核态和用户态之间拷贝需要浪费cpu资源，如果可以直接在内核态将磁盘文件拷贝到网络socket内核部分进行发送，则会减少cpu浪费，进行更多的任务处理</p>
</li>
<li><p>如果想把udp做成像tcp一样怎么做</p>
<p>TCP可靠的条件是：1. 停止等待协议，等待确认接收后再继续发送；2.使用超时重传，如果超时没有确认则重传，则接收端收到重复包丢弃；</p>
<p>UDP可能的问题：1.丢包；2.数据完整性，不执行校验和；3.乱序，数据包顺序不保证</p>
<p>可靠udp协议：1.数据完整性：加上CRC校验；2.乱序：数据包加上序列号；3.丢包：引入确认和超时重传</p>
</li>
<li><p>map是collection下的吗？map存的一个类作为key，重写了hashcode没有重写equels会有什么问题</p>
<p>不是，是map的。会在put时判断不是同一个key，会重复放入</p>
</li>
<li><p>redis zset为什么使用跳表而不是红黑树</p>
<p>跳表：实现简单；维护操作少，不需要进行旋转来维护红黑树特性；期望查询时间是O(lgn)</p>
</li>
<li><p>为什么ArrayList每次扩容1.5倍</p>
<p>不能取固定容量，可能太小会造成频繁扩容，频繁申请内存空间+数组频繁复制；太大会浪费空间，需要动态确定。此外1.5可以充分利用位移操作，减少运算时间</p>
</li>
<li><p>in和 exists 有什么区别？</p>
<p>in语句将外表和内表做hash连接，而exists语句对外表做loop循环，每次loop循环向内表查询</p>
<p>效率对比：</p>
<ol>
<li>如果查询的表大小接近，则都一样</li>
<li>如果一个大一个小，则子查询大的用exists，小的用in</li>
<li>not in和not exists，如果查询语句用not in，则内外表都全表扫描，没用到索引；而not exists的子查询依然用到表上索引。not exists比not in快</li>
</ol>
</li>
<li><p>公司年会，有一等奖、二等奖和三等奖，每个奖项对应不同的数量，如何设计抽奖程序？</p>
</li>
<li><p>mybatis缓存的过期时间</p>
<p>一级缓存没有过期时间，只有生命周期。会创建一个Sqlsession对象，该对象的缓存是Mybatis的一级缓存，在对象中有hashMap保存缓存数据。如果执行DML操作会清空缓存，当清空SqlSession的一级缓存（生命周期结束）。如果调用close会释放缓存，一级缓存不可用。如果clearCache（）或DML会清空缓存数据</p>
<p>二级缓存有过期时间，但没有后台线程检测。二级缓存是mapper级别缓存，多个sqlSession使用同一个sql语句操作数据库，数据在二级缓存区域。二级缓存有过期时间，并不是k-v过期时间，而是这个cache的过期时间，意味着整个清空缓存cache。</p>
</li>
<li><p>Spring启动的时候，怎么完成依赖注入的，有那几个核心的点？</p>
<p>setter注入、构造函数注入、静态工厂注入、实例工厂注入</p>
</li>
<li><p>spring事务传播机制有哪几种？</p>
<p><strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，创建一个新事务，如果存在则加入</p>
<p><strong>PROPAGATION_SUPPORTS</strong>：支持当前事务，如果存在则加入，否则以非事务执行</p>
<p><strong>PROPAGATION_MANDATORY</strong>：支持当前事务，如果当前存在则加入，否则抛出异常</p>
<p><strong>PROPAGATION_REQUIRES_NEW</strong>：创建新事务，无论存不存在事务，创建新事物</p>
<p><strong>PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式执行操作，如果存在事务则挂起当前事务</p>
<p><strong>PROPAGATION_NEVER</strong>：以非事务方式执行，如果存在则抛出异常</p>
<p><strong>PROPAGATION_NESTED</strong>：如果当前存在事务，则在嵌套事务执行，如果没有事务，则创建新事物</p>
</li>
<li><p>CMS和G1收集垃圾的过程？</p>
<p>CMS，只能用在老年代：</p>
<ol>
<li>初始标记：只是标记下GC Roots能直接关联到的对象，速度快，需要停顿</li>
<li>并发标记：进行GC Roots Tracing的过程，不停顿</li>
<li>重新标记：为了修正标记期间因用户程序继续运行而导致的标记产生变动的部分对象的记录，需要停顿</li>
<li>并发清除：不需要停顿</li>
</ol>
<p>G1，在新生代和老年代一起回收：</p>
<ol>
<li>把堆划分到多个大小相等的独立区域，新生代和老年代不再物理隔离。引入region，将原来的一整块内存划分为多个小空间，单独进行垃圾回收。可以预测停顿时间，并记录每个region垃圾回收时间及空间，维护一个优先列表，优先回收价值最低的region</li>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：修正并发标记期间因用户程序继续运作导致标记变动的部分标记，虚拟机将对象变化记录在线程的Remembered Set Logs里面，最终标记阶段将logs合并到Remembered Set。这阶段需要停顿线程，可并行执行</li>
<li>筛选回收：首先region中的回收价值和成本排序，根据期望的GC停顿时间来指定回收计划。时间用户可控，通过停顿用户线程将大幅度提高收集效率</li>
</ol>
</li>
<li><p>大量timewait可能出现什么情况</p>
<ol>
<li><p>高并发让服务器在短时间范围内同时占用大量端口</p>
</li>
<li><p>维护连接状态给Server带来负担</p>
<p>可以设置sysctl.conf文件，减少keepalive消息频率；增加SYN队列长度；开启SYN Cookies；开启重启，允许Time-Wait套接字重新用于新的TCP；开启TCP连接中sockets快速回收；减少超时前的探测次数</p>
</li>
</ol>
</li>
<li><p>创建索引语句</p>
<p>主键索引：创建表时自动创建</p>
<p>唯一索引：create unique index 索引名称 on 表名(列名)</p>
<p>普通索引：create index 索引名称 on 表名（列名）</p>
<p>组合索引：create index 索引名称 on 表名(列名1，列名2，列名3)</p>
</li>
<li><p>雪花算法</p>
<p>用于生成分布式ID，自增ID（数据敏感不宜使用，且不适合分布式）、GUID（无意义字符串，数据量大时访问过慢，且不宜排序）</p>
<p><img src="C:\Users\fengzhizi\AppData\Roaming\Typora\typora-user-images\image-20210807231121176.png" alt="image-20210807231121176"></p>
<p>最高位是符号位，始终为0，不可用。</p>
<p>41位时间序列，精确到毫秒级，可以使用69年，还可以根据时间排序</p>
<p>10位的机器标识，最多部署1024结点</p>
<p>12位的计数序列号，即自增id，可以支持同一节点同一毫秒生成多个ID序列，12位最多产生4096个序号</p>
</li>
<li><p>父进程和子进程读到的变量地址一样吗</p>
<p>vfork创建一个子进程，子进程不会完全复制父进程地址空间，会在父进程地址空间进行。因为vfork创建的子进程是与父进程共享地址空间，为了避免竞争，所以就让子进程先运行，而父进程后运行；而fork创建的子进程是父进程的副本，所以不会带来竞争问题，谁先谁后也就无所谓了</p>
</li>
<li><p>深浅拷贝在JVM层面的区别</p>
<p>浅拷贝：只复制当前对象，对该对象内部的引用不能复制</p>
<p>深拷贝：对对象内部所有对象的引用均复制，每个引用对象创建一个实例并复制实例</p>
</li>
<li><p>jvm句柄</p>
<p>jvm访问对象由指针直接访问和句柄间接访问两种。</p>
<p>指针：栈帧中的本地变量表存储的引用是实例数据地址，可以直接获取到示例数据地址。并且引用指向的堆中的对象数据由两部分：对象实例本身；和对象类型在方法区的地址</p>
<p>句柄：jvm在堆中划分一块内存做句柄池，jvm的栈帧存的是句柄地址，句柄池中一个对象地址分为两部分：对象数据在堆内存中实例池的地址；以及对象类型在方法区的地址。</p>
<p>句柄好处：对象实例移动时，只改变句柄池该对象实例地址即可，无需改变引用和句柄池关系，在引用中存储的句柄地址稳定</p>
<p>指针访问好处：快（减少了一半寻址时间），省空间</p>
</li>
<li><p>Http header里面的字段，对研发岗有用的字段</p>
<p>Accept-ranges：表明服务器是否支持指定范围以及哪种类型</p>
<p>Age：从原始服务器到代理缓存形成的估算时间</p>
<p>Allow：对网络资源允许的请求方式</p>
<p>Cache-Control：告诉缓存机制是否可以缓存及哪种类型</p>
<p>Content-Encoding：web服务器支持的返回内容压缩编码类型</p>
<p>Content-Language：响应体的语言</p>
<p>Content-length：响应体长度</p>
<p>Content-Range：整个返回体中本部分的字节位置</p>
</li>
<li><p>银行家算法</p>
<p>定义了安全状态为当所有的线程均请求最大资源时依然能满足要求，如果一个请求符合安全状态，则为其分配资源，否则拒绝</p>
</li>
<li><p>继承的缺点</p>
<ol>
<li>父类内部细节子类可见</li>
<li>子类从父类继承的方法在编译时确定，无法改变运行期间父类继承的方法的行为</li>
<li>对父类做修改则子类也要修改</li>
</ol>
</li>
<li><p>Integer是不是可变的，存储在jvm哪个区域</p>
<p>可变，存在堆内存</p>
</li>
<li><p>说说四个拒绝策略的英文，我不想听中文，中文你八股文肯定背过了</p>
<p>AbortPolicy：抛出异常</p>
<p>CallerRunsPolicy：调用线程自己执行任务</p>
<p>DiscardPolicy：丢弃掉新任务</p>
<p>DiscardOldestPolicy：抛弃最老的任务</p>
</li>
<li><p>线程池参数设置，你怎么压测的？看哪些参数判断压力大小，如果什么方法看这些参数的？</p>
<p>线程池活跃度公式为activeCount/maximumPoolSIze，越大则负载越高</p>
<p>ThreadPoolExecutor提供了一些getter方法可以得到当前线程池的运行状态和参数</p>
<p><img src="C:\Users\fengzhizi\AppData\Roaming\Typora\typora-user-images\image-20210807162933875.png" alt="image-20210807162933875"></p>
</li>
<li><p>写数据到master，master同步到slave，这个时候slave没收到，并且master也挂了，怎么办</p>
<p>可以做成强一致性，在slave将log写入磁盘后才返回成功日志，此时可以slave上位，并且从log中恢复数据。</p>
</li>
<li><p>了解哪些调度算法，说下优缺点</p>
<ol>
<li>先来先服务</li>
<li>短作业优先</li>
<li>最短剩余时间优先</li>
<li>时间片轮转</li>
<li>优先级</li>
<li>多级反馈队列</li>
</ol>
</li>
<li><p>TCP是稳定链接，为什么应用层还需要心跳机制</p>
<p>TCP的keepAlive是操作系统级别的，netstat查看链接的状态为ESTABLISHED，表示处于链接状态，此时可能链路不通但tcp还没感知到，此时应用层更感受不到链路。TCP的KeepAlive机制由操作系统实现，如果操作系统不定期清除失活连接，会占用资源。开启TCP KeepaLlive机制后在没有数据传送时会定期探活。</p>
<p>应用层维护心跳可以及时发现链路故障问题，尽早建立新链接进行故障转移。一旦连接不可用，可以重连或者其他afailover处理。并且应用层处理更容易修改。TCP协议包由操作系统负责，如果存在代理层则不会处理</p>
</li>
<li><p>硬中断和软中断的区别</p>
<p>硬中断通常是外部事件引起的，具有随机性和突发性，软中断执行中断指令产生，通常是程序安排好的</p>
<p>软中断的中断响应周期，cpu需要发中断回合信号</p>
<p>硬中断信号是中断控制器提供，软中断信号由指令给出</p>
<p>应中断可屏蔽，软中断不可</p>
</li>
<li><p>32位能不能存储long型数据</p>
<p>可以，JVM具有跨平台特性，数据类型字节一致</p>
</li>
<li><p>Linux命令，查看8080端口的进程</p>
<p>lsof -i查看，lsof -i :8080</p>
<p>netstat -anp</p>
</li>
<li><p>发现系统执行慢，怎么去找到造成慢的点</p>
<p>top，查看占用cpu和内存很大的进程</p>
</li>
<li><p>可以说一下为什么快重传是三次吗？</p>
<p>区分包的丢失是由于链路故障还是乱序造成。两次重复ack可能是乱序造成，三次则可能是丢包造成</p>
<p>造成重传的原因：1.包校验出错；2.网络拥塞；3.网络断。两个重复包可能是乱序造成，无需重传。三个包以上的大概率是丢包，既然收到了ack则网络通，可能出错或拥塞，重传一次如果正确则继续发送，否则是拥塞造成降速比较合理</p>
</li>
<li><p>讲讲进程、线程、协程</p>
<p>协程是用户模式下的轻量级线程，一个线程可以包含多个协程，协程有自己的寄存器上下文和栈，并且空间占用小于线程，协程调度切换时，将寄存器上下文保存起来，切换后恢复先前保存的上下文和栈。协程有用户调度，在执行到某一状态后会主动让出cpu，并通过回调函数在其他协程执行后继续进行</p>
<p>优势：1. 节省内存，线程需要分配栈空间，以及内核资源；2.节省分配线程的开销（创建和销毁都要做sys call）；3.节省线程切换带来的开销；4.与NIO配合实现非阻塞编程</p>
</li>
<li><p>你提到读时共享写时复制，操作系统是通过什么机制来实现它的</p>
<p>通过MMU实现，子进程的段均指向父进程的物理空间，两者虚拟空间不同，但对应物理空间同样，逻辑上仍是严格独立的两个进程，各自维护参数，在物理上实现读时共享、写时复制</p>
</li>
<li><p>linux命令，查日志里面包含“ERROR”的行的个数</p>
<p>grep -c ‘ERROR’ log.txt</p>
</li>
<li><p>介绍一下fd是什么</p>
<p>是文件描述符，是一个非负整数，本质上是一个索引值，打开文件时内核向进程返回fd，后续对文件操作只需要使用fd来标识改文件。值的范围是0-OPEN_MAX-1，现在fd范围不受限制</p>
</li>
<li><p>os怎么知道文件来自哪里（比如磁盘、套接字），os是怎么做的</p>
</li>
<li><p>生成分布式id的方法 越多越好</p>
<ol>
<li>UUID</li>
<li>数据库自增ID</li>
<li>数据库集群模式：设置起始值和自增步长</li>
<li>基于数据库的号段模式：从数据库批量获取id，在id用完后再向数据库申请新号段，采用版本号乐观锁方式更新，不强依赖数据库，对数据库压力小很多</li>
<li>Redis模式：利用incr命令实现id原子性自增</li>
<li>雪花算法</li>
<li>百度uid-generaotr</li>
<li>美团leaf</li>
<li>滴滴tinyid</li>
</ol>
</li>
<li><p>我和你同时输入url ，最终显示画面不一致的原因</p>
</li>
<li><p>甲乙两人抛同一枚硬币 谁先正面谁赢，谁的赢面大 概率是多少?</p>
<p>第一轮甲获胜概率1/2，乙是1/2*1/2是1/4，第二轮甲1/8，乙1/16，所以甲获胜概率是2/3，乙是1/3</p>
</li>
<li><p>Redis和zookeeper的实现分布式锁方式和优缺点，怎么选择</p>
<p>redis使用setnx，zookeeper使用临时有序结点</p>
<p>redis性能更高，但redis获取到锁之后主节点宕机了，但主服务器没来得及将键复制到从服务器，此时从服务器晋升为主服务器，另一个客户端也可以获取锁，互斥效果就失效了。</p>
<p>Zookeeper更安全</p>
</li>
<li><p>状态码500和502区别</p>
<p>500，服务器内部错误，遇到了预期之外的错误导致无法完成请求</p>
<p>502，Bad Gateway，网关错误，网关从上游服务器中接收到的响应是无效的。502不是指网关出了问题，而是上游接收响应除了问题，比如上游服务自身超时导致不能产生响应数据，或者上游不按照协议约定来返回数据，导致网关不能正常解析</p>
<p>网关：宏观意义上只要连接两个不同的网络设备可以叫网关，http上具体是指转发其他服务器通信数据的服务器。</p>
</li>
<li><p>mss（ 最大分段大小）和mtu（ 最大传输单元）分别是什么，如果mtu小于mss会有什么问题</p>
<p>MTU是链路层一次最大传输数据的大小，MSS是指TCP最大报文段长度，是传输层一次发送最大数据的大小。MSS=MTU-IP首部-TCP首部如果MSS+TCP首部+IP首部&gt;MTU，则数据包拆分为多个发送</p>
</li>
<li><p>64匹马，8个赛道，最少需要比赛多少次才能选出跑的最快的4匹马</p>
<p>先赛8次，得到每8个的排名，然后这8个第一排名，得到前四名，则这前四名成为候选，以及对应的8个马一组的划分，第一名有4个候选，第二名有三个，然后2个1个，一共10个，则这10个需要做两次排名知道前四名是啥。一共十一次</p>
</li>
<li><p>用户在微博上发了一个post后，怎么保证所有关注他的用户收到推送，中间经历了什么，数据库怎么设计</p>
<p>数据库记录所有关注他的用户列表</p>
</li>
<li><p>epoll有哪两种触发方式，<strong>tcp</strong>应该用哪种触发方式</p>
<p>水平触发和边缘触发，应该用水平触发，tcp一次读包可能不能完全读完，如果采用边缘触发可能丢失部分这次传输的数据</p>
</li>
<li><p> TCP窗口大小，如果拥塞控制和接收缓冲区控制窗口不一样，应该选哪个</p>
</li>
</ol>
<pre><code>应该选最小的，既实现了拥塞控制，也实现了流量控制，让服务器可以来得及接收数据包
</code></pre>
<ol start="93">
<li><p>应用层<strong>send</strong>一个数据成功了，发送方应用程序怎么感知到自己发送成功了，是应用层还是传输层做</p>
<p>需要让对方返回一个响应消息。不管进程是否会读取socket，对端发来的数据都会经由内核接收并缓存到socket的内核接收缓冲区中。read的工作就是把内核缓冲区的数据拷贝到应用层用户的buffer里。send数据时也是经数据拷贝到socket的内核发送缓冲区中，然后返回应用层，此时不能说明数据已经被发送并且被对方接收</p>
</li>
<li><p><strong>TCP</strong>里的**<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>alive(<strong>心跳机制</strong>)**了解吗</p>
<p>操作系统实现的，在tcp固定时间内未进行数据传输时会进行一次保活探测操作。默认关闭，开启的一方向对端发送保活探测报文。如果持续无响应并超过设置的循环次数上限，认为tcp连接失效，做中断处理</p>
<p><strong>保活时间：tcp_keepalive_time、探测时间间隔：tcp_keepalive_intvl、探测循环次数：tcp_keepalive_probes</strong>。</p>
</li>
<li><p><strong>HTTP</strong>的keepalive了解吗</p>
<p>表头的keep-alive字段，1.1中默认开启。若开启后，在一次http请求中，服务器进行响应后，不再直接断开TCP连接，而是将TCP连接维持一段时间。在这段时间内，如果同一客户端再次向服务端发起http请求，便可以复用此TCP连接，向服务端发起请求，并重置timeout时间计数器，在接下来一段时间内还可以继续复用。这样无疑省略了反复创建和销毁TCP连接的损耗。</p>
</li>
<li><p>HTTP2.0和1.1有什么区别</p>
<p>header帧和data帧分离</p>
<p>维护共同有用的header字段，并且首部字段使用huffman编码压缩</p>
<p>会在请求时将所有相关的静态资源一起发送</p>
</li>
<li><p>全量同步的时候，如果复制缓冲区写满了怎么解决</p>
<p>增大从服务器的缓冲区最大值，或者增加每秒允许的写入量。</p>
<p>主库会为每一个从库建立一个replication buffer，用来发送增量写命令，一旦replication buffer写满了，主从就需要断开，重新进行全量同步</p>
</li>
<li><p>当<strong>master</strong>死亡后，新的<strong>slave</strong>竞选成为<strong>master</strong>后会触发全量复制吗，如何进行同步</p>
<p>不会，应该是增量复制</p>
</li>
<li><p>ssl协议</p>
<p>SSL分为：</p>
<p>SSL记录协议：作用是在高层协议提供基本的安全服务。建立在tcp之上，为高层协议提供数据封装、压缩、加密等功能</p>
<p>SSL握手协议：用于SSL管理信息的交换，允许应用协议传送数据之间相互验证，协商加密算法和生成秘钥等。作用是协调客户和服务器的状态，是双方能达到状态的同步。建立在SSL记录协议上，用于实际数据传输之前，身份认证、协商加密算法、交换加密秘钥等</p>
</li>
<li><p>线程池，计算多少个线程数，场景题让我设计线程池。4核，1S执行100个任务，一个任务需要10ms， 怎么设置能保证1S执行完100个任务。 这个要作比较计算需要的线程数。然后确定工作核心和最大线程数。</p>
</li>
<li><p>docker的网络配置</p>
<p>docker network 自定义网络</p>
<p>docker run –net指定容器网络</p>
</li>
<li><p>docker怎么资源管理，怎么权限控制</p>
<p>cgroups实现资源限制、优先级分配、资源统计和任务控制</p>
<p>–cpu-period设置调度周期，–cpu-quota设置每个周期内容器能使用的cpu时间，–cpu-shares指定cpu份额</p>
<p>-m限制内存</p>
<p>-device-read-bps：限制某个设备上的读速度，-device-write-bps</p>
<p>权限控制：默认root，使用–user指定启动时的用户，使用namespace隔离技术</p>
</li>
<li><p>怎么进行进程同步</p>
<p>信号量、信号、条件变量</p>
</li>
<li><p>SpringBoot的SpringBootApplication注解的作用</p>
<p>包含三个注解</p>
<ol>
<li>SpringBootConfiguration，组合配置文件功能</li>
<li>EnableAutoConfiguration，自动配置</li>
<li>ComponentScan：组件扫描</li>
</ol>
</li>
<li><p>select 和 epoll的区别</p>
</li>
<li><p>客户端挂了，那服务端能感知到TCP断了吗 不能怎么办，能的话是什么原理？</p>
<p>不能马上感知，因为tcp保活探测机制通常是2小时，应用层实现心跳机制</p>
</li>
<li><p>B+树的缺点，MySQL怎么优化B+树</p>
<p>B+树叶子结点可能出现重复数据，占用空间。每个表都设定主键，叶子结点存放主键对应数据，唯一</p>
</li>
<li><p>什么是二级索引？符合二级索引的查询条件就一定不回表吗?</p>
<p>辅助索引，叶节点存储的是主键值，再去主键索引找数据。覆盖索引才不需要回表</p>
</li>
<li><p>平时怎么调试代码？怎么实现断点的？跑着的线程怎么打断点让它停下来</p>
<p>断点加载线程的函数体run里</p>
</li>
<li><p>Hashmap的hashcode跟对象的hashcode是同一个吗</p>
<p>不是，会在hashCode的基础上额外做些操作</p>
</li>
<li><p>Mysql的关键字执行顺序</p>
<p>from</p>
<p>on</p>
<p>join</p>
<p>where</p>
<p>group by</p>
<p>having</p>
<p>select</p>
<p>distinct</p>
<p>order by</p>
<p>limit</p>
</li>
<li><p>索引下推的实现过程</p>
<p>对辅助索引的回表操作，先判断是否满足条件，如果满足才回表查询。</p>
<p>例如联合索引a,b。之前的做法是根据a得到了主键值立即回表，然后判断数据行是否满足b的条件，下推则先判断b是否满足，只有满足了才会回表。所以是优化了回表次数</p>
</li>
<li><p>G1收集器的思想</p>
<p>对堆内存划分为region，并根据每次回收的时间和空间计算优先级，每次回收时根据优先级为region排序</p>
</li>
<li><p>G1与其他收集器的区别，在什么情况下选G1，什么情况下会选择其他垃圾收集器</p>
<p>划分region，并发。新生代和老年代都可以使用G1</p>
<p>当触发了Full GC时，会使用Serial收集器</p>
</li>
<li><p>一个无序，元素可重复数组，找出和为k和k的倍数的长度最小的子数组。子数组中元素可以不连续。</p>
</li>
<li><p>进程之间网络通信断开的过程</p>
<p>tcp四次挥手</p>
</li>
<li><p>复制粘贴操作系统都做了啥</p>
<p>复制文本是复制到缓冲区，复制文件是只复制路径</p>
</li>
<li><p>1000个试剂找出有毒的那个，要求所用的小白鼠数量最少，且要最快找出</p>
<p>10只小白鼠，从1到1000标号试剂，并且按照二进制给对应小白鼠注射，假设死了为1，没死为0，则小白鼠结果序列转化为十进制即为有毒</p>
</li>
<li><p>一个天平，一个7g砝码，一个2g砝码，要求用最快的方式将140g盐分成50g和90g</p>
<ol>
<li><p>不用砝码，将 140 g 盐用天平分成 70g + 70g</p>
</li>
<li><p>不用砝码，将 70 g盐用天平分成 35g + 35g</p>
</li>
<li><p>用天平将一份 35g 盐分为 20g盐 + 2g砝码 = 15g盐 + 7g砝码</p>
</li>
<li><p>将 20g与 70g盐并在一起就是 90g，剩下的是 50</p>
<p>方法2：</p>
<ol>
<li>天平分61g+9g砝码=70g，此时得到9g盐</li>
<li>再用9g盐+2g砝码从61g盐中取出11g，此时61剩50</li>
</ol>
</li>
</ol>
</li>
<li><p>tcp协议如果发生丢包了，滑动窗口要发的包存在哪里</p>
<p>socket缓冲区</p>
</li>
<li><p>100个兔子取10个兔子，10只兔子中最重在100只里期望是多少。</p>
<p>1 / C10-100</p>
</li>
<li><p>八个硬币，有一个最轻，其他一样重，用天平最少几次能选出最轻那个</p>
<p>两次，三个三个称</p>
</li>
<li><p>发送窗口会变成0吗</p>
<p>会变成0，对于变成0的情况发送方不再发送数据，会启动一个零窗口探测器，向接收方询问窗口大小，当接收方窗口恢复时可以再次发送数据</p>
</li>
<li><p>给一个表，id,a,b,c (a,b)是联合索引 select * from db where a &gt; x and b == y;能否使用上索引？那查找过程呢？a走不走索引？b走不走？</p>
<p>可以用上索引，会在第一个范围查找处停止，所以a可以用索引，b不走</p>
</li>
<li><p>update set c == x,会加什么锁？，那update set id == x呢？</p>
<p>如果没有索引，所以update会锁表，如果加了索引，就会锁行</p>
</li>
<li><p>一个无序数组，找到一个数，左边都比他小，右边都比他大</p>
<p>一次从左到右遍历，找到该数左边的最大值，然后从右向左遍历，记录当前出现的最小值，如果当前值更新了最小值并且比左边的最大值还大，则符合条件</p>
</li>
<li><p>如何去找到入口去执行第一段代码</p>
</li>
<li><p>Mysql 中某索引列 已经 存在 5，9记录，第一个事务Insert 6，第二个事务 select for update where col &gt; 4? （问：第二个事务是否会被block？如果没有for update会不会被阻塞？那如果第二个事务insert 7会不会加锁？）</p>
</li>
<li><p>md5和加密算法有啥区别？</p>
<p>md5是摘要算法，或哈希算法，通过函数将任意长度数据转化为一个长度固定的数据串，计算摘要容易，但破解很难，通常要使用暴力破解的方式。</p>
<p>加密算法，是将数据通过加密算法处理，成为不可读的数据部分</p>
</li>
<li><p>代码块，变量，构造方法的执行顺序</p>
<p>变量 - 代码块- 构造方法</p>
</li>
<li><p>1000个苹果放10个箱子 - 转换为二进制秒解</p>
</li>
<li><p>树的高度和磁盘IO有什么联系</p>
<p>最坏情况下，磁盘IO和树的高度一样。</p>
</li>
<li><p><strong>BeanFactory 和 ApplicationContext 有什么区别</strong></p>
<p>BeanFactory是含有bean集合的工厂类，包含各种bean定义，便于实例化，还包含bean的生命周期</p>
<p>ApplicationContext则是在此基础上提供了更多的功能，比如支持国际化文本消息、统一资源文件读取方式、在监听器注册bean事件</p>
<ol>
<li>BeanFactory延迟加载，只有用到某个bean才会加载实例化，而ApplicationContext在容器启东时一次性创建所有bean</li>
<li>BeanFactory编程方式创建，ApplicationContext可以声明方式</li>
<li>BeanFactory和ApplicationContext都支持PostProcessor使用，但BeanFactory需要手动注册</li>
</ol>
</li>
<li><p><strong>Spring Bean 的生命周期</strong></p>
<ol>
<li>实例化bean</li>
<li>设置对象属性</li>
<li>处理Aware接口，比如BeanNameAware、BeanFactoryAware、ApplicationContextAware接口</li>
<li>initializingBean和init-method</li>
<li>BeanPostProcessor：初始化结束时调用</li>
<li>DIsposableBean：清理阶段，若实现则调用其实现的destory方法</li>
<li>destory-method</li>
</ol>
</li>
<li><p><strong>Spring IOC 如何实现</strong></p>
<p>BeanFactory实现加载和控制所有bean，当需要一个bean时BeanFactory会实现实例化以及注入</p>
</li>
<li><p><strong>Spring AOP 实现原理</strong></p>
<p>静态代理，jdk动态代理和cglib动态代理</p>
</li>
<li><p><strong>动态代理（cglib 与 JDK）</strong></p>
<p>jdk必须定义接口，通过反射实现</p>
<p>cglib通过字节码实现其子类，并拦截所有父类调用请求实现</p>
</li>
<li><p><strong>Spring 事务实现方式</strong></p>
<ol>
<li>编码方式，编程式显示声明</li>
<li>@Transaction注解</li>
</ol>
</li>
<li><p><strong>如何自定义注解实现功能</strong></p>
<p>创建注解的interface以@开头，且不能带参数</p>
</li>
<li><p><strong>Spring MVC 运行流程</strong></p>
</li>
<li><p><strong>Spring MVC 启动流程</strong></p>
<p>web.xml给servlet配置了load-on-startup，会先初始化SpringMVC，在httpServletBean中将配置的contextConfigLocation属性设置到servlet中，然后在FrameworkServlet中创建WebApplicationContext，DIspatcherServlet根据contextConfigLocation配置的classpath下的xml文件初始化SpringMVC总组件</p>
</li>
<li><p><strong>Spring 的单例实现原理</strong></p>
<p> Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是ConcurrentHashMap 对象</p>
</li>
<li><p>实体硬连接和符号软连接的区别<br>实体连接是创建一个条目，记录某文件的inode和文件名，这样在文件被删除后，原目录下文件名和inode被删除，也可以通过实体连接记录的信息找到文件对应的block。不会导致文件真的被删除，并且不能对目录连接。<br>符号连接是复制的文件的路径，比如类似/tmp/xxx/x.log这样的形式，在打开时还需要根据路径在文件所在目录中找到对应的文件名和inode，这样在文件被删除后，目录下的文件名和inode被删除，符号链接再去找发现不存在，则无法打开文件。</p>
</li>
<li><p>java中cas操作实现了version的类是什么<br>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
</li>
<li><p>@Transaction的切面实现原理，如果错误如何发现并回退</p>
<p>在执行时，当执行一个类的方法时，如果方法上带有注解，会使用jdk代理的方式织入事务的逻辑，并且只有直接调用该方法才可以织入。如果在方法2上加事务，在方法1中调用方法2，此时如果生成该实例调用方法1不会引入方法2的事务逻辑，因为未发现事务注解，不会织入事务逻辑</p>
</li>
<li><p>秒杀系统如何防止超卖<br>1）秒杀开始之前，将参加秒杀活动商品的信息缓存起来，避免数据库压力<br>2）需要避免恶意刷单的情况，可以对一个用户的访问频率做限制，比如采用接口+用户id作为key存储对应的访问次数，到达限制后提醒用户<br>后端需要做到：<br>1）可扩展：通过水平添加机器将请求分发到不同机器上，数据库可扩展，支持分库分表，对用户请求映射到不同数据库<br>2）内存缓存：事先将参加秒杀的信息缓存到redis，提高系统吞吐量<br>3）限流：库存消耗完之后，将前端的秒杀入口关闭<br>4）削峰：利用缓存和消息中间件的技术，将瞬间高流量变成一段时间平稳的流量<br>5）异步处理；用于提高系统并发量<br>使用mysql+redis搭建秒杀系统，使用redis的list或者set存储用户信息，存储用户购买数量<br>秒杀开始前：将参加秒杀的信息缓存到redis中，key要和前端的key一致<br>秒杀开始时；提交后，获取redis的key-value值，查询缓存，得到库存量，判断是否大于0，如果大于0记录用户id，库存-1，如果等于0，则提示用户卖光。上述操作必须做到事务执行，可以利用redis的multi和exec或者watch功能实现redis事务，保证数据的一致性，避免超卖问题<br>库存卖完后：启动一个线程阻塞请求，并获取set集合中的用户信息，异步处理需要操作的购买等操作</p>
</li>
<li><p>求二叉树两个结点的首个共同祖先</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ans;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left, p, q);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((left &amp;&amp; right) || ((left || right) &amp;&amp; (root == p || root == q))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left || right || root == p || root == q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="148">
<li>交换整数的奇数位和偶数位</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/%E9%9D%A2%E7%BB%8F%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">计网面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:20:26 / 修改时间：13:07:24" itemprop="dateCreated datePublished" datetime="2022-02-21T12:20:26+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>*表示重要程度，题目摘抄自<a target="_blank" rel="noopener" href="https://github.com/liguigui/CyC2018-CS-Notes">Cyc2018</a>，答案为自己的理解</p>
<h3 id="各层协议的作用，以及-TCP-IP-协议的特点"><a href="#各层协议的作用，以及-TCP-IP-协议的特点" class="headerlink" title="*** 各层协议的作用，以及 TCP/IP 协议的特点"></a>*** 各层协议的作用，以及 TCP/IP 协议的特点</h3><p>五层协议：</p>
<ol>
<li>应用层：为特定应用程序提供数据传输服务，例如HTTP、DNS等协议。数据单位为报文</li>
<li>传输层：为进程提供通用数据传输服务。由于应用层协议很多，需要定义通用的传输层协议。传输层协议包括：1）传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP主要提供完整性服务，UDP主要提供及时性服务</li>
<li>网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组</li>
<li>数据链路层：网络层针对的是主机之间的数据传输服务，而主机之间有多条链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的数据封装成帧</li>
<li>物理层：考虑怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到差异。</li>
</ol>
<p>OSI协议：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/%E8%AE%A1%E7%BD%91%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/%E8%AE%A1%E7%BD%91%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">计网总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:20:19 / 修改时间：13:35:12" itemprop="dateCreated datePublished" datetime="2022-02-21T12:20:19+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是根据<a target="_blank" rel="noopener" href="https://github.com/liguigui/CyC2018-CS-Notes">Cyc2018</a>总结的基础知识整理而来，在基础知识的基础上更多偏向实际面试问题，以及一些深入的问题思考</p>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>五层协议：</p>
<ol>
<li>应用层：为特定应用程序提供数据传输服务，例如HTTP、DNS协议，数据单位为报文</li>
<li>传输层：为进程提供通用数据传输服务。包括TCP和UDP协议。传输控制协议TCP提供面向连接、可靠的数据传输服务，数据单位为报文段，提供完整性服务；用户数据报协议UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报，提供及时性服务。</li>
<li>网络层：提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组</li>
<li>数据链路层：为同一链路的主机提供数据传输服务。把网络层传下来的分组封装成帧。</li>
<li>物理层：考虑怎样在传输媒体上传输数据比特流。尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感受不到差异。</li>
</ol>
<h5 id="OSI网络体系结构各层协议"><a href="#OSI网络体系结构各层协议" class="headerlink" title="OSI网络体系结构各层协议"></a>OSI网络体系结构各层协议</h5>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/%E8%AE%A1%E7%BD%91%E6%80%BB%E7%BB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/ZooKeeper%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/ZooKeeper%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">ZooKeeper总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:19:43 / 修改时间：13:06:09" itemprop="dateCreated datePublished" datetime="2022-02-21T12:19:43+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>整理自<a target="_blank" rel="noopener" href="https://blog.csdn.net/Geffin/article/details/108967125">博客</a></p>
<h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p>一个开源的分布式协调服务。为分布式应用提供一致性服务。分布式应用程序可以基于ZooKeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能<br>目标数封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统给用户.<br>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p>
<p>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个 zookeeper 最新的 zxid。</p>
<h3 id="ZooKeeper文件系统"><a href="#ZooKeeper文件系统" class="headerlink" title="ZooKeeper文件系统"></a>ZooKeeper文件系统</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/ZooKeeper%E6%80%BB%E7%BB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/Spring%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/Spring%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Spring总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:19:29 / 修改时间：13:05:48" itemprop="dateCreated datePublished" datetime="2022-02-21T12:19:29+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>部分参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/Geffin/article/details/104101716">博客</a></p>
<h3 id="Spring核心组件"><a href="#Spring核心组件" class="headerlink" title="Spring核心组件"></a>Spring核心组件</h3><p><img src="https://github.com/JiahangGu/blog/blob/main/images/Spring/spring.png" alt="Spring核心组件"></p>
<ol>
<li>核心容器：提供Spring框架的基本功能。主要组件是BeanFactory，是工厂模式的实现。BeanFactory使用IoC模式将应用程序的配置和依赖性规范与实际的应用程序代码分开</li>
<li>Spring上下文：一个配置文件，向框架提供上下文信息</li>
<li>Spring AOP：通过配置管理特性，AOP模块直接将面向切面的编程功能集成到了Spring框架中。可以将一些通用任务，如安全、事务、日志等集中进行管理，提高了复用性和管理的便捷性</li>
<li>Spring DAO：为JDBC DAO抽象层提供了异常层次结构，可以用该结构来管理异常处理和不同数据库供应商的错误消息。简化了错误处理，并极大降低了需要编写的异常代码数量</li>
<li>Spring ORM：提供若干个ORM框架，提供了ORM的对象关系工具，包括JDO、Hibernate和Ibatis SQL Map，遵从Spring的通用事务和DAO异常层次结构</li>
<li>Spring Web：Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。</li>
<li>Spring MVC：全功能的构建Web应用程序的MVC实现。容纳了大量的视图技术</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/Spring%E6%80%BB%E7%BB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Redis面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:19:19 / 修改时间：13:05:22" itemprop="dateCreated datePublished" datetime="2022-02-21T12:19:19+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="字典和跳跃表原理分析"><a href="#字典和跳跃表原理分析" class="headerlink" title="** 字典和跳跃表原理分析"></a>** 字典和跳跃表原理分析</h3><p>字典：dictht是一个散列表结构，使用拉链法解决哈希冲突。Redis的字典dict中包含两个哈希表dictht，为了方便进行rehash操作。在扩容时将其中一个dictht上的键值对rehash到另一个dictht上，完成后释放空间并交换。rehash不是一次性完成，而是采用渐进方式，避免一次性执行过多rehash操作给服务器带来过大负担。<br>渐进式rehash通过记录dict的rehashidx完成，从0开始，每执行一次rehash都会递增。rehash期间每次对字典执行添加、删除、查找或更新操作时执行一次渐进式rehash。渐进式rehash导致字典中数据分散在两个dictht上，查找操作也需要到对应的dictht去执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    void *privdata;</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    long rehashidx;  //等于-1时不处于渐进式rehash期间</span><br><span class="line">    unsigned long iterators;</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>

<p>跳跃表：是有序集合的底层实现之一，基于多指针有序链表实现，可以看成多个有序链表。<br>跳跃表结构示意如下：<br>entry -&gt;                                                      end<br>entry -&gt; 7 -&gt;                         25 -&gt;             53 -&gt; end<br>entry -&gt; 7 -&gt;       13 -&gt; 15 -&gt;       25 -&gt;       42 -&gt; 53 -&gt; end<br>entry -&gt; 7 -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 22 -&gt; 25 -&gt; 30 -&gt; 42 -&gt; 53 -&gt; end<br>查找时从上层指针开始查找，找到对应的区间之后再到下一层去寻找<br>与红黑树等平衡树比较，跳跃表具有以下优点：</p>
<ol>
<li>插入速度非常快速，因为不需要旋转等操作维护平衡性</li>
<li>更容易实现</li>
<li>支持无锁操作</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/Redis%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/Redis%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Redis总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:19:07 / 修改时间：13:04:47" itemprop="dateCreated datePublished" datetime="2022-02-21T12:19:07+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基础知识</p>
<h3 id="Redis为什么是单线程"><a href="#Redis为什么是单线程" class="headerlink" title="Redis为什么是单线程"></a>Redis为什么是单线程</h3><p>Redis是基于内存的操作，CPU不是Redis的瓶颈。单线程容易实现，而且CPU不会成为瓶颈，也可以省去线程切换上下文的开销</p>
<h3 id="为什么使用IO多路复用"><a href="#为什么使用IO多路复用" class="headerlink" title="为什么使用IO多路复用"></a>为什么使用IO多路复用</h3><p>来保证多连接的时候系统的高吞吐量。多路复用通过单线程高效地处理多个连接请求，可以减少网络IO地时间消耗。采用epoll实现的多路复用在监控时只需要将描述符复制到内核态一次，并且维护队列记录已经到达的事件，只需要O(1)时间即可得到到达的事件，避免轮询。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/Redis%E6%80%BB%E7%BB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/Nginx%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/Nginx%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Nginx总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:18:58 / 修改时间：13:04:12" itemprop="dateCreated datePublished" datetime="2022-02-21T12:18:58+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h4><p>一个轻量级、高性能的反向代理Web服务器，可以实现非常高的反向代理、负载均衡，官方数据可以支持5万并发，新浪、网易、腾讯等均使用</p>
<h4 id="为什么要用Nginx"><a href="#为什么要用Nginx" class="headerlink" title="为什么要用Nginx"></a>为什么要用Nginx</h4><ol>
<li>跨平台、配置简单、反向代理、高并发连接、内存占用少、处理静态文件好</li>
<li>内置健康检查功能，会将发送到宕机的服务器的请求转发到其他节点上</li>
<li>还可以节省带宽（支持gzip，添加浏览器本地缓存）、稳定性高、异步接收用户请求</li>
</ol>
<h4 id="为什么Nginx性能高"><a href="#为什么Nginx性能高" class="headerlink" title="为什么Nginx性能高"></a>为什么Nginx性能高</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/Nginx%E6%80%BB%E7%BB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Java多线程总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:18:49 / 修改时间：13:03:48" itemprop="dateCreated datePublished" datetime="2022-02-21T12:18:49+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>主要参考自CyC2018公众号文档，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq1404510094/article/details/80724038">博客</a>，</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。<br>线程复用：每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。<br>工作过程：</p>
<ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<br>a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；<br>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；<br>c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiahang Gu</p>
  <div class="site-description" itemprop="description">认真学习，享受生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JiahangGu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiahangGu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/fengzhizi76506" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;fengzhizi76506" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiahang Gu</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
