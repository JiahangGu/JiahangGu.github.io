<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="为啥先判断hash再判断eqauls()因为两个相同的对象hashCode一定相等，反之不成立。通常得到hash更快，可以先使用hashCode排除不相等的元素，减少equals的判断次数 List、List、List&lt;?&gt;、List 泛型的区别List, List, List都可以容纳所有对象，使用顺序应该是List, List，最后List  List是确定的某一个类型，具体类型在">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础总结">
<meta property="og:url" content="http://example.com/2022/02/21/Java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="菜汤里的咸鱼要翻身">
<meta property="og:description" content="为啥先判断hash再判断eqauls()因为两个相同的对象hashCode一定相等，反之不成立。通常得到hash更快，可以先使用hashCode排除不相等的元素，减少equals的判断次数 List、List、List&lt;?&gt;、List 泛型的区别List, List, List都可以容纳所有对象，使用顺序应该是List, List，最后List  List是确定的某一个类型，具体类型在">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-21T04:18:41.000Z">
<meta property="article:modified_time" content="2022-02-21T05:03:20.925Z">
<meta property="article:author" content="Jiahang Gu">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/02/21/Java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java基础总结 | 菜汤里的咸鱼要翻身</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">菜汤里的咸鱼要翻身</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/Java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:18:41 / 修改时间：13:03:20" itemprop="dateCreated datePublished" datetime="2022-02-21T12:18:41+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="为啥先判断hash再判断eqauls"><a href="#为啥先判断hash再判断eqauls" class="headerlink" title="为啥先判断hash再判断eqauls()"></a>为啥先判断hash再判断eqauls()</h3><p>因为两个相同的对象hashCode一定相等，反之不成立。通常得到hash更快，可以先使用hashCode排除不相等的元素，减少equals的判断次数</p>
<h3 id="List、List、List-lt-gt-、List-泛型的区别"><a href="#List、List、List-lt-gt-、List-泛型的区别" class="headerlink" title="List、List、List&lt;?&gt;、List 泛型的区别"></a>List、List<Object>、List&lt;?&gt;、List<K> 泛型的区别</h3><p>List, List<?>, List<Object>都可以容纳所有对象，使用顺序应该是List<T>, List<?>，最后List<Object></p>
<ol>
<li>List<T>是确定的某一个类型，具体类型在运行期决定；List&lt;?&gt;表示任意类型，与List<T>类似，而List<Object>则表示List集合中所有元素为Object类型，所以也可以容纳所有类类型</li>
<li>List<T>可以进行读写操作，因为是固定的T类型，编码器不需要进行转型操作；List&lt;?&gt;是只读类型，不能增加和修改，因为编译器不知道List中容纳的是什么类型的元素，无法校验类型是否安全，并且取出的元素都是Object类型，需要主动转型。但是可以删除元素。List<Object>也可以读写，但在写入时需要向上转型，取出后需要向下转型，即知道了具体数据类型，失去了泛型的意义</li>
</ol>
<h3 id="Java泛型及类型擦除"><a href="#Java泛型及类型擦除" class="headerlink" title="Java泛型及类型擦除"></a>Java泛型及类型擦除</h3><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数</p>
<ol>
<li>泛型方法<E>：调用时可以接受不同类型的参数，根据传递的参数类型，编译器适当地处理每一个方法调用。可以包含一个或多个类型参数，参数间用逗号隔开<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void print(E[] array) &#123;</span><br><span class="line">    for (E element : array) &#123;</span><br><span class="line">        System.out.printf( &quot;%s &quot;, element );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型类<T>；在类名后添加类型参数声明部分。例如class Box<T>，则类内代码可以使用T声明变量<? extends T>表示通配符代表地类型是T类型地子类
<? super T>表示该通配符代表的类型是T类型的父类</li>
<li>类型通配符?，代替具体的类型参数，例如List&lt;?&gt;逻辑上是List<String>, List<Integer>等所有List&lt;具体类型实参&gt;的父类</li>
</ol>
<p>类型擦除：Java中的泛型基本上在编译器层次实现，生成的Java字节码不包含泛型中的类型信息。使用泛型的时候加上的类型参数在被编译器编译时会被去掉，称为泛型擦除，基本过程是找到替换类型参数的具体类，一般是Object或者指定类型参数的上界。</p>
<h2 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h2><p>主要包括Collection(集合)和Map，Collection存储着对象的集合，而Map存储着键值对（两个对象）的映射表。之前只是有了解并没有深入去看，直到面试的时候问我Java集合有哪些，直接傻眼</p>
<h3 id="集合Collection"><a href="#集合Collection" class="headerlink" title="集合Collection"></a>集合Collection</h3><p>接口有Set、List和Queue，并对应不同实现。</p>
<ol>
<li>List：有序集合<br>1）ArrayList：内部通过数组实现，基于动态数据实现，支持随机访问。当增加/删除数据时需要将已有数据复制到新的存储空间，代价高，适合随机查找和遍历，不适合插入和删除<br>2）Vector：和ArrayList类似，但线程安全。使用synchronized实现同步，但花销高<br>3）LinkedList：基于双向链表实现，只能顺序访问，但可以快速地在链表中插入和删除元素，还可以用作栈、队列和双向队列</li>
<li>Set：用于存储不重复的值。如果想让两个不同的对象视为相等，则要覆盖Object的hashCode和equals方法<br>1）TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作，但查找效率不如HashSet，HashSet查找的时间复杂度为O(1)，TreeSet是O(lgn)。自定义类对象需要实现Comparable接口并覆写compareTo函数指定排序的顺序。<br>2）HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息。会先判断两个元素的哈希值，如果一样再使用equals方法，如果true则视为同一元素。集合内同等hashCode的元素存放在同一个哈希桶里<br>3）LinkedHashSet：具有HashSet的查找效率，并且内部使用双向链表维护元素的插入顺序。继承于HashSet，底层使用LinkedHashMap实现。</li>
<li>Queue<br>1）LinkedList：可以用来实现队列和双向队列<br>2）PriorityQueue：基于堆结构实现，可以用来实现优先队列</li>
</ol>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ol>
<li>TreeMap：基于红黑树实现，实现SortedMap接口，将保存的记录默认升序排序。构造迭代器访问时记录是排序的。key必须实现Comparable接口或构造TreeMap时传入自定义的Comparator。</li>
<li>HashMap：基于哈希表实现</li>
<li>HashTable：和HashMap类似，但是线程安全，是遗留类，不应该使用它。可以使用ConcurrentHashMap实现线程安全，并且效率更高。注意ConcurrentHashMap是JUC包下的类</li>
<li>LinkedHashMap：使用双向链表维护元素的顺序，顺序为插入顺序或LRU顺序。继承于HashMap</li>
</ol>
<h3 id="容器中的设计模式"><a href="#容器中的设计模式" class="headerlink" title="容器中的设计模式"></a>容器中的设计模式</h3><ol>
<li>迭代器模式：Collection继承了Iterable接口，Iterable()方法能够产生一个Iterator对象，可以迭代遍历Collection中的元素</li>
<li>适配器模式：可以使用Arrays.asList()把数组类型转换为List类型，并且asList参数为泛型，需要使用基本类型相应的包装类型数组</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在此不会贴源码，而是总结各种具体类的实现方式的特点</p>
<ol>
<li>ArrayList<br>1）基于数组实现，支持快速随机访问，实现RandomAccess接口标识着该类支持快速随机访问，数组默认大小为10<br>2）扩容：添加元素需要判断容量是否足够，如果不够进行扩容1.5倍。扩容操作需要使用Arrays.copyOf()复制原数组，开销大，最好创建ArrayList就指定大概的容量大小，减少扩容的次数<br>3）删除元素：需要调用System.arraycopy()将index+1后的元素复制到index位置上，时间复杂度为O(N)<br>4）Fail-Fast：使用modCount记录ArrayList结构变化的次数，结构变化是指添加或删除元素的操作，或调整内部数组的大小，不包含设置元素值。在进行序列化或迭代操作时，需要比较操作前后modCount是否改变，如果改变抛出ConcurrentModificationException。<br>5）序列化：ArrayList基于数组实现，并有动态扩容特性，因此保存元素的数组不一定全部使用，没必要全部进行序列化。transient Object[] elementData;transient关键字声明数组默认不会被序列化。使用writeObject()和readObject()控制只序列化数组中有元素填充那部分内容。序列化时需要使用ObjectOutputStream的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是ObjectInputStream 的 readObject() 方法，原理类似。</li>
<li>Vector<br>1）同步：实现与ArrayList类似，但使用synchronized进行同步<br>2）与ArrayList的比较：1：Vector是同步的，因此开销比ArrayList大，访问速度更慢。最好不用，因为同步操作可以由程序员自己控制；2：Vector每次扩容放大2倍，而ArrayList为1.5倍<br>3）替代方案：可以使用Collections.synchronizedList()得到一个线程安全的ArrayList（以List为参数放入构造函数），也可使用juc下的CopyOnWriteArrayList类。<br>CopyOnWriteArrayList实现了读写分离：写操作在一个复制的数组上进行，读操作在源数组进行，读写互不影响。写操作需要加锁防止并发写入数据丢失，写操作结束后将原始数组指向新的复制数组。适用于读多写少的场景。但有缺点：1. 内存占用多：写操作时要复制一个新的数组；2. 数据不一致：读操作不能读取实时性数据，部分写操作数据未同步到原数组中。</li>
<li>LinkedList<br>1）实现：基于双向链表，每个Node存储next、prev指针。且每个链表存储了first和last指针指向链表的首尾元素<br>2）与ArrayList的比较：1. ArrayList基于动态数组实现，LinkedList基于双向链表实现；2. ArrayList支持随机访问，LinkedList不支持；3. LinkedList在任意位置添加删除元素更快</li>
<li>HashMap<br>1）实现：内部包含Entry[]数组，Entry存储键值对、hash值和next节点，采用拉链法解决冲突。<br>2）工作原理：插入时先计算key的hashCode，求余得到桶下标插入到链表头。查找时先计算键值所在的捅，然后在链表上顺序查找<br>3）HashMap允许插入key为null的数据，强制放在第0个桶中<br>4）计算哈希值：取模操作y%x可以等价于y&amp;(x-1)<br>5）扩容：参数capacity，size，threshold，loadFactor参与。每次扩容放大2倍，需要将老对象的键值对插入到新的位置，需要重新计算hashCode和插入。允许用户传入容量不是2的n次方，但会自动转换为第一个大于容量的2的n次方。在重新计算hashCode时，如果原capacity=16，即10000，要扩容到32，即100000，对于之前的key，如果第5位=0，则取模结果不变，如果=1则为原结果+16<br>6）JDK1.8开始，桶存储的链表长度大于8时将链表转换为红黑树<br>7）与HashTable比较：1. HashTable使用synchronized同步；2. HashMap可以插入key=null的Entry；3. HashMap迭代器是fail-fast的；4. HashMap不保证元素次序不变</li>
<li>ConcurrentHashMap<br>1） 实现：使用分段锁Segment，继承于ReentrantLock，每个分段锁维护1个桶，多线程可以同时访问不同分段锁的桶，增加并发度。<br>2） size()：每个Segment维护一个count统计该Segment的键值对个数，执行size操作时将所有Segment的count累加起来。size操作时先不加锁，如果连续两次操作结果一致则认为正确，最大尝试次数为3.<br>3） JDK1.8：使用CAS操作支持更高并发度，CAS失败时使用synchronized</li>
</ol>
<h3 id="拆箱和装箱"><a href="#拆箱和装箱" class="headerlink" title="拆箱和装箱"></a>拆箱和装箱</h3><p>将基本数据类型转换位包装器类型叫装箱int-&gt;Integer，使用Integer.valueOf(int)；拆箱则相反，使用Integer.intValue()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = 100;</span><br><span class="line">Integer i2 = 100;</span><br><span class="line">Integer i3 = 200;</span><br><span class="line">Integer i4 = 200;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure>
<p>输出结果为true、false，因为Integer范围的-128-127会引用常量池的数据，所以相等，而大于127则需要新建对应包装类型对象，不等</p>
<h3 id="final-finalize-finally"><a href="#final-finalize-finally" class="headerlink" title="final, finalize(), finally"></a>final, finalize(), finally</h3><ol>
<li>final为关键字，表示常量，标识的数据存储在常量池中</li>
<li>finalize()为方法，定义在Object，在对象结束时，由JVM调用对对象进行垃圾回收</li>
<li>finally标识代码块，try配合，无论是否发生异常，该代码块中的程序必定执行，在return方法之前执行</li>
</ol>
<h3 id="抽象类abstract-class和接口interface有什么异同"><a href="#抽象类abstract-class和接口interface有什么异同" class="headerlink" title="抽象类abstract class和接口interface有什么异同"></a>抽象类abstract class和接口interface有什么异同</h3><p>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是<br>常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法</p>
<h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><p>即New IO，用到的主要是块，所以效率要比IO高狠多。Java提供两套NIO，一套针对标准输入输出NIO，另一套是网络编程NIO。<br>三大核心：channel，buffer，selector，NIO基于channel和buffer操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。selector用于监听多个通道的事件。可以单线程监听多个数据通道，NIO面向缓冲区</p>
<h5 id="NIO的缓冲区"><a href="#NIO的缓冲区" class="headerlink" title="NIO的缓冲区"></a>NIO的缓冲区</h5><p>Java IO面向流意味着每次从流中读一个或多个字节，直到读取所有字节，它们没有被缓存到任何地方。并且不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先把它缓存到一个缓冲区。NIO的缓冲导向方法不同，数据读取到一个稍后处理的缓冲区，需要时可在缓存区中前后移动，增加了处理过程中的灵活性。但是还需要检查该缓冲区中包含所有需要处理的数据。需要确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据</p>
<h5 id="NIO的非阻塞"><a href="#NIO的非阻塞" class="headerlink" title="NIO的非阻塞"></a>NIO的非阻塞</h5><p>IO的各种流是阻塞的。当一个线程调用read()或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，期间线程不能做其他事。NIO的非阻塞模式，使一个线程从某通道发送请求读数据，但仅能得到目前可用的数据，如果没有数据可用时，什么都获取不到，但不保持线程阻塞，所以直到数据变得可以读取之前，线程可以继续做其他事情。线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 </p>
<h5 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h5><p>Stream是单向，Channel是双向，可读可写</p>
<h5 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h5><p>缓冲区，实际是一个容器，是一个连续数组。Channel提供从文件、网络读写数据的渠道，但读写的数据必须经由buffer。例如发送数据，必须先将数据放入buffer中，再将buffer中的数据写入通道</p>
<h5 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h5><p>NIO 的核心类， Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。 </p>
<h3 id="字节流和字符流区别"><a href="#字节流和字符流区别" class="headerlink" title="字节流和字符流区别"></a>字节流和字符流区别</h3><p>字节流以字节为单位，字符流以字符（16位）为单位传输</p>
<p>下述面经参考自<a target="_blank" rel="noopener" href="https://thinkwon.blog.csdn.net/article/details/104390612">博客</a></p>
<h3 id="JVM、JRE、JDK区别"><a href="#JVM、JRE、JDK区别" class="headerlink" title="JVM、JRE、JDK区别"></a>JVM、JRE、JDK区别</h3><p>JVM是Java虚拟机，用于运行Java程序并实现跨平台特性<br>JRE是JVM和Java程序所需的核心类库等，包含运行Java必不可少的系统类<br>JDK是提供给Java开发人员使用的，包含了开发工具（编译、打包工具）和JRE</p>
<h3 id="Java字节码及好处"><a href="#Java字节码及好处" class="headerlink" title="Java字节码及好处"></a>Java字节码及好处</h3><p>字节码是Java源代码经过虚拟机编译器编译后产生的文件（.class文件），不面向任何处理器，只面向虚拟机。采用字节码可以解决传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。<br>Java源代码—-&gt;编译器—-&gt;JVM可执行的Java字节码—-&gt;JVM—-&gt;JVM解释器解释执行—-&gt;机器可执行的二进制机器码—-&gt;程序运行</p>
<h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ol>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java不提供指针来直接访问内存，程序内存更安全</li>
<li>Java类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但接口可以多继承</li>
<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ol>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>创建独立于具体对象的域变量或方法，可以在没创建对象的条件下也能使用属性和调用方法。此外还可以形成静态代码块来优化程序性能，类初次加载的时候，static块顺序初始化并且只执行一次。<br>注意点：</p>
<ol>
<li>static修饰的变量或方法独立于该类的任何对象，不属于任何一个实例对象，而是被类的所有实例对象共享</li>
<li>该类被第一次加载时，会加载被static修饰的部分并进行初始化，不被static修饰的变量在第一次加载不进行初始化</li>
<li>static变量值在类加载的时候分配空间，再创建类对象时不会重新分配</li>
<li>被static修饰的变量或方法是优先于对象存在，类加载完毕后，即使没有创建对象也可以访问</li>
</ol>
<p>应用场景：如果某个成员变量被所有对象共享，则应该定义为静态变量。<br>注意事项；1. 静态只能访问静态；2. 非静态既可以访问非静态也可以访问静态</p>
<h3 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h3><p>抽象类用来捕捉子类的通用特性，接口是抽象方法的集合。从设计层面来看，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范<br>相同点；</p>
<ol>
<li>接口和抽象类都不能实例化</li>
<li>都位于继承的顶端，用于被其他类实现或继承</li>
<li>都包含抽象方法，子类必须覆写</li>
</ol>
<p>不同点：</p>
<ol>
<li>抽象类使用abstract，接口使用interface关键字</li>
<li>抽象类使用extends继承，并且只能继承一个，子类使用implements实现接口，可以实现多个接口</li>
<li>抽象类可以有构造器，接口不能有</li>
<li>抽象类的方法可以是任意访问修饰符，接口方法默认且只能是public</li>
<li>抽象类的字段声明任意，而接口的字段默认都是static和final的</li>
</ol>
<h3 id="定义不做事且没有参数的构造方法的作用"><a href="#定义不做事且没有参数的构造方法的作用" class="headerlink" title="定义不做事且没有参数的构造方法的作用"></a>定义不做事且没有参数的构造方法的作用</h3><p>在执行子类的构造方法之前，如果没用super()调用父类特定构造方法，会调用没有参数的构造方法，用来帮助子类做初始化工作。如果没有提供该构造方法，且子类没有调用super()，编译时将发生错误</p>
<h3 id="hashCode和equals"><a href="#hashCode和equals" class="headerlink" title="hashCode和equals"></a>hashCode和equals</h3><p>以HashSet检查重复为例，首先计算加入元素的hashCode，并与已有对象进行判断，如果hashCode相等再调用equals方法比较，可以减少equals的次数提高执行速度。因此如果覆盖equals方法则也要覆盖hashCode方法</p>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>Java传参使用将对象引用按照值传递的方法，即传递到形参的是对参数的拷贝，所以可以修改所传形参的属性，但修改形参的引用不会影响传入的参数</p>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象都能调用它的任意一个方法和属性。<br>优点：运行期类型的判断，动态加载类，提高代码灵活度<br>缺点：性能瓶颈：反射相当于一系列解释操作，通知jvm要做的事，比直接的java代码慢很多<br>应用场景：框架设计的灵魂<br>例如Spring框架使用xml配置模式由IoC容器装在Bean的过程，由java解析配置内容得到实体类的字节码字符串以及相关的属性信息，使用反射机制获得某个类的Class实例，动态配置实例属性。<br>反射的实现方式：1）通过new对象；2）通过路径实现；3）通过类名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Get &#123;</span><br><span class="line">    //获取反射机制三种方式</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        //方式一(通过建立对象)</span><br><span class="line">        Student stu = new Student();</span><br><span class="line">        Class classobj1 = stu.getClass();</span><br><span class="line">        System.out.println(classobj1.getName());</span><br><span class="line">        //方式二（所在通过路径-相对路径）</span><br><span class="line">        Class classobj2 = Class.forName(&quot;fanshe.Student&quot;);</span><br><span class="line">        System.out.println(classobj2.getName());</span><br><span class="line">        //方式三（通过类名）</span><br><span class="line">        Class classobj3 = Student.class;</span><br><span class="line">        System.out.println(classobj3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Java面向对象编程三大特性"><a href="#Java面向对象编程三大特性" class="headerlink" title="Java面向对象编程三大特性"></a>Java面向对象编程三大特性</h3><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性</p>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>使用已存在的类的定义作为基础建立新类，新类的定义可以增加新的数据或功能，也可以使用父类的功能，但不能选择性地继承父类。通过继承可以提高代码复用性，是多态的前提。注意点</p>
<ol>
<li>子类拥有父类非private的属性和方法</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展</li>
<li>子类可以用自己的方式实现父类的方法</li>
</ol>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，提高了程序的扩展性。<br>多态指程序中定义的引用变量所指向的具体类型和方法调用属于哪个类，只能在程序运行期间决定。不修改源代码，就可以让引用变量绑定到各种不同的类实现上，导致该引用调用的具体方法随之改变，程序可以有多个运行状态。<br>分为编译时多态和运行时多态，编译时多态是静态的，主要指方法的重载，根据参数列表区分函数。运行时多态是动态的，通过动态绑定实现。<br>实现多态的三个必要条件：</p>
<ol>
<li>继承：存在有继承关系的父子类</li>
<li>重写：子类对父类中某些方法进行重新定义，调用对应方法时会调用子类的方法</li>
<li>向上转型：多态中需要将子类的引用赋给父类对象</li>
</ol>
<h3 id="对象实例与对象引用有何不同"><a href="#对象实例与对象引用有何不同" class="headerlink" title="对象实例与对象引用有何不同"></a>对象实例与对象引用有何不同</h3><p>对象实例在堆内存中，对象引用指向对象实例，存放在栈内存中，一个对象可以有n个引用指向它</p>
<h3 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h3><p>静态变量：属于类而不属于任何实例对象，在内存中只有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间<br>实例变量：每次创建对象都会为每个对象分配内存空间</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol>
<li>静态内部类：可以访问外部类所有的静态变量，创建方式为new 外部类.静态内部类()</li>
<li>成员内部类：可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有，创建方式为外部类实例.new 内部类()</li>
<li>局部内部类：定义在方法中的内部类，可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法，创建方式为在对应方法内，new 内部类()</li>
<li>匿名内部类：没有名字的内部类，特点：1）必须继承一个抽象类或实现一个接口；2）不能定义任何静态成员和静态方法；3）所在方法的形参需要被匿名内部类使用时必须声明为final；4）匿名内部类不能是抽象的，必须要实现继承的类或者实现的接口的所有抽象方法</li>
</ol>
<p>内部类优点：</p>
<ol>
<li>可以访问创建它的外部类对象的内容，包括私有数据</li>
<li>不为同一包的其他类可见，具有很好的封装性</li>
<li>有效实现了多重继承，优化java单继承</li>
<li>匿名内部类可以很方便的定义回调</li>
</ol>
<h3 id="和equals的区别是什么"><a href="#和equals的区别是什么" class="headerlink" title="==和equals的区别是什么"></a>==和equals的区别是什么</h3><p>==：判断两个对象的地址是不是相等，即是不是一个对象（基本数据类型比较的是值）<br>equals：判断两个对象是否相等，有两种情况</p>
<ol>
<li>类没有覆盖equals方法，则通过equals比较时等价于==</li>
<li>类覆盖了equals方法，使用自定义的逻辑判断两个对象是否相等</li>
</ol>
<h3 id="BIO、NIO、AIO区别"><a href="#BIO、NIO、AIO区别" class="headerlink" title="BIO、NIO、AIO区别"></a>BIO、NIO、AIO区别</h3><ol>
<li>BIO：Block IO同步阻塞式IO，平时使用的传统IO，特点是模式简单使用方便，并发处理能力低</li>
<li>NIO：Non-blocking IO，同步非阻塞IO，传统IO的升级，客户端和服务端通过Channel通讯实现了多路复用</li>
<li>AIO：异步IO，操作基于事件和回调机制</li>
</ol>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>位于堆内存中，用于存储字符串常量，可以提高内存使用率。在创建字符串时JVM首先检查字符串常量池，如果该字符串已存在则返回引用，否则实例化一个字符串放到池中，并返回其引用</p>
<h3 id="String-str-”i”和String-str-new-String-“i”-的区别"><a href="#String-str-”i”和String-str-new-String-“i”-的区别" class="headerlink" title="String str=”i”和String str = new String(“i”)的区别"></a>String str=”i”和String str = new String(“i”)的区别</h3><p>String str = “i”，JVM会分配到常量池中，而new String(“i”)会分到堆内存中</p>
<h3 id="红黑树与平衡二叉树的区别"><a href="#红黑树与平衡二叉树的区别" class="headerlink" title="红黑树与平衡二叉树的区别"></a>红黑树与平衡二叉树的区别</h3><ol>
<li>红黑树不追求完全平衡，追求大致平衡，每次插入最多需要三次旋转能达到平衡，实现简单且插入操作少，统计情况下时间复杂度优于平衡二叉树</li>
<li>平衡二叉树追求绝对平衡，每次插入节点不可预知旋转的次数，实现复杂，插入操作较多，查找的时间复杂度均为O(lgn)</li>
</ol>
<h3 id="哪些对象可以作为gc-roots"><a href="#哪些对象可以作为gc-roots" class="headerlink" title="哪些对象可以作为gc roots"></a>哪些对象可以作为gc roots</h3><ol>
<li>JVM中引用的对象</li>
<li>方法区中的类静态属性引用的对象（被static修饰的对象）</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中的JNI（native方法）引用的对象</li>
</ol>
<p>以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆 中其他对象的引用，这种引用逐步扩展，最终以null引用或者基本类型结束，这样就形成了一颗以Java栈中引用所对应的对象为根节点的一颗对象树，如果 栈中有多个引用，则最终会形成多颗对象树</p>
<h3 id="堆外内存及特点"><a href="#堆外内存及特点" class="headerlink" title="堆外内存及特点"></a>堆外内存及特点</h3><p>堆外内存是把内存对象分配在JVM的堆以外的内存，直接受操作系统管理<br>优点：</p>
<ol>
<li>减少垃圾回收，但堆外内存会溢出，垃圾回收依赖于代码显式调用System.gc()</li>
<li>加快复制的速度</li>
</ol>
<p>为何使用堆外内存：使用缓存时本地缓存速度最快，但会给虚拟机带来GC压力，使用硬盘或分布式缓存响应时间较长，堆外缓存是个较好的选择</p>
<h3 id="线程池七大参数"><a href="#线程池七大参数" class="headerlink" title="线程池七大参数"></a>线程池七大参数</h3><ol>
<li>corePoolSize：线程池中核心线程数。需要划分io密集型和cpu密集型。cpu密集型的话cpu使用率很高，如果线程池的核心线程数量过多，会增加上下文切换的次数，带来额外开销。因此一般情况下核心线程数量等于CPU核数+1。而IO密集型任务，CPU使用率并不高，可以让CPU等待IO操作的时候处理别的任务，充分利用CPU，因此一般情况下线程的核心线程数等于2*CPU核数。而对于混合任务，核心线程数=（线程等待时间/线程CPU时间+1） * CPU核数</li>
<li>maximumPoolSize：线程池能够容纳同时执行的最大线程数</li>
<li>keepAliveTime：多余的空闲线程的存活时间，当线程池线程数量超过corePoolSize时，若线程空闲时间到达keepAliveTime值，会被销毁，直到只剩下corePoolSize个为止</li>
<li>unit：keepAliveTime单位</li>
<li>workQueue：任务队列，被提交但未被执行的任务</li>
<li>threadFactory：表示生产线程池中工作线程的线程工场，一般默认</li>
<li>handler：拒绝策略</li>
</ol>
<h3 id="synchronized-和-volatile-的区别？"><a href="#synchronized-和-volatile-的区别？" class="headerlink" title="synchronized 和 volatile 的区别？"></a>synchronized 和 volatile 的区别？</h3><ol>
<li>volatile告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取，而synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住</li>
<li>volatile仅能用在变量级别，而synchronized可以用在变量、方法、类级别</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized可以保证变量的修改可见性和原子性</li>
<li>volatile不会造成线程阻塞，synchronized可能造成阻塞</li>
<li>volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化</li>
</ol>
<h3 id="synchronized、lock、volatile的底层实现分别是什么？"><a href="#synchronized、lock、volatile的底层实现分别是什么？" class="headerlink" title="synchronized、lock、volatile的底层实现分别是什么？"></a>synchronized、lock、volatile的底层实现分别是什么？</h3><ol>
<li>synchronized底层通过一个monitor对象完成。任何一个对象都和一个monitor关联，当一个monitor被持有后，处于锁定状态。在JVM里的实现是通过MonitorEnter指令插入在同步代码块的开始位置，当执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得锁；而MonitorExit指令插入在方法结束处和异常处，释放锁，保证每个MonitorEnter均有对应的MonitorExit</li>
<li>lock的底层通过AQS实现，使用计数值、双向链表、CAS+自旋。volatile int state表示锁状态，双向链表存储等待中的线程。获取锁：CAS操作state，如果成功则获得锁。释放锁：CAS修改state，同时更新下一个链表的线程等待结点</li>
</ol>
<h3 id="说一下HashMap-底层实现原理？什么时候又转回链表"><a href="#说一下HashMap-底层实现原理？什么时候又转回链表" class="headerlink" title="说一下HashMap 底层实现原理？什么时候又转回链表"></a>说一下HashMap 底层实现原理？什么时候又转回链表</h3><p>链表长度大于8转为红黑树，红黑树结点小于等于6转回链表。因为维护红黑树的旋转操作在节点数较少时的花销大于链表。</p>
<h3 id="JVM-调优有了解过吗？平时碰到过相关的问题吗"><a href="#JVM-调优有了解过吗？平时碰到过相关的问题吗" class="headerlink" title="JVM 调优有了解过吗？平时碰到过相关的问题吗"></a>JVM 调优有了解过吗？平时碰到过相关的问题吗</h3><p>调优的目标：使用较小的内存占用获得较高的吞吐量或较低的延迟<br>几个重要的指标（根据实际目标调整优化目标，针对性能瓶颈做针对性的优化）：</p>
<ol>
<li>内存占用：程序正常运行需要的内存大小</li>
<li>延迟：由于垃圾收集而引起的程序停顿时间</li>
<li>吞吐量：用户程序运行时间占用户程序和垃圾收集占总时间的比值</li>
</ol>
<p>调优参考的数据：</p>
<ol>
<li>系统运行日志：程序代码打印出的日志</li>
<li>堆栈错误信息：系统出现异常后，根据堆栈信息初步定位问题。OOM: Java heap space堆内存溢出，StackOverFlowError是栈溢出，OOM: PermGen space是方法区溢出</li>
<li>GC日志：程序启动时用-XX:+PrintGCDetails和-Xloggc:/data/jvm/gc.log可以将运行时gc的详细过程记录下来。或者配置-verbose:gc将gc日志打印到控制台</li>
<li>线程快照：看到线程在某一时刻的状态，确定请求超时、死循环、死锁等问题。执行JVM自带的jstack pid命令</li>
<li>堆转储快照：使用-XX:+HeadDumpOnOutOfMemory和-XX:+HeadDUmpPath=/data/jvm/dumpfile.hprof，当发生内存溢出时，将内存快照以文件形式转储</li>
</ol>
<p>调优工具</p>
<ol>
<li>jps：查看虚拟机启动的所有进程、执行主类的全名、JVM启动参数</li>
<li>jstat：坚实虚拟机信息。jstat -gc pid 500 10每500毫秒打印一次Java堆状况，打印10次</li>
<li>jmap：查看堆内存信息</li>
<li>jconsole、visualvm分析内存信息如Eden、Survivor、Old等内存变化情况</li>
</ol>
<p>堆设置<br>-Xms: 初始堆大小<br>-Xmx: 最大堆大小<br>-XX:NewSize=n: 设置年轻代大小<br>-XX:NewRatio=n: 设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4<br>-XX:SurvivorRatio=n: 年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5<br>-XX:MaxPermSize=n: 设置持久代大小</p>
<p>收集器设置<br>-XX:+UseSerialGC: 设置串行收集器<br>-XX:+UseParallelGC: 设置并行收集器<br>-XX:+UseParalledlOldGC: 设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC: 设置并发收集器</p>
<p>垃圾回收统计信息<br>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename</p>
<p>并行收集器设置<br>-XX:ParallelGCThreads=n :设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n :设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n :设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p>
<p>并发收集器设置<br>-XX:+CMSIncrementalMode: 设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads=n: 设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
<h3 id="JVM-运行时区域说一下有哪些？是不是线程安全的？会抛哪些异常？具体说说。"><a href="#JVM-运行时区域说一下有哪些？是不是线程安全的？会抛哪些异常？具体说说。" class="headerlink" title="JVM 运行时区域说一下有哪些？是不是线程安全的？会抛哪些异常？具体说说。"></a>JVM 运行时区域说一下有哪些？是不是线程安全的？会抛哪些异常？具体说说。</h3><p>分为：方法区、堆内存、线程栈空间、本地方法区<br>线程栈是线程安全的，方法区是线程安全的。堆内存不是线程安全的<br>堆内存会抛出OOM异常，栈会抛出StackOverFlowError</p>
<h3 id="知道怎么破坏双亲委派模型吗。"><a href="#知道怎么破坏双亲委派模型吗。" class="headerlink" title="知道怎么破坏双亲委派模型吗。"></a>知道怎么破坏双亲委派模型吗。</h3><p>工作过程：</p>
<ol>
<li>先查找当前ClassLoader是否加载过此类，有就返回</li>
<li>如果没有，查询父ClassLoader是否已经加载过此类，如果已加载过，就直接返回Parent加载的类</li>
<li>如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载</li>
</ol>
<p>如何打破：</p>
<ol>
<li>自定义类加载器，重写loadClass方法</li>
<li>使用线程上下文类加载器</li>
</ol>
<h3 id="static与final的区别"><a href="#static与final的区别" class="headerlink" title="static与final的区别"></a>static与final的区别</h3><p>final表示不可变。修饰类表示类不可变，不可继承。修饰方法表示不可重写。修饰变量表示不可修改<br>static表示全局或静态，可以修饰方法、变量、代码块，被放在方法区中，全局共享<br>static final同时具有两种特征</p>
<h3 id="int类型在32位系统和64位系统中使用有区别吗？怎么屏蔽差异"><a href="#int类型在32位系统和64位系统中使用有区别吗？怎么屏蔽差异" class="headerlink" title="int类型在32位系统和64位系统中使用有区别吗？怎么屏蔽差异"></a>int类型在32位系统和64位系统中使用有区别吗？怎么屏蔽差异</h3><p>64位机器能使用32位和64位，32位机器上只能使用32位。此外Java引用指针在64位机器上是8字节，而32位机器上是4字节<br>编译时JIT编译器会根据版本将Java字节码编译到对应的机器码</p>
<h3 id="Redis的哈希表跟HashMap有什么区别？"><a href="#Redis的哈希表跟HashMap有什么区别？" class="headerlink" title="Redis的哈希表跟HashMap有什么区别？"></a>Redis的哈希表跟HashMap有什么区别？</h3><ol>
<li>哈希实现方式不同，redis的哈希采用一致性哈希算法，构造哈希环实现负载均衡。而HashMap通过链地址法解决冲突，并且在长度大于8转为红黑树</li>
<li>rehash不同，HashMap扩容2倍，对每个k-v重新计算hashCode并插入到对应桶；而Redis采用渐进式扩容的机制，使用两个哈希表，在rehash期间每执行增删改查操作时额外将旧哈希值复制到新的哈希表中，将rehash操作分摊，避免集中进行导致服务器短暂停顿</li>
</ol>
<h3 id="为什么TreeMap没有负载因子、容量这样的参数？"><a href="#为什么TreeMap没有负载因子、容量这样的参数？" class="headerlink" title="为什么TreeMap没有负载因子、容量这样的参数？"></a>为什么TreeMap没有负载因子、容量这样的参数？</h3><p>TreeMap基于红黑树实现，添加数据后由旋转操作实现平衡，不存在HashMap中的容量限制。</p>
<h3 id="Java中对象占用的字节数"><a href="#Java中对象占用的字节数" class="headerlink" title="Java中对象占用的字节数"></a>Java中对象占用的字节数</h3><p>一个空对象占8字节，一个对对象的引用占4字节（比如栈中对堆对象的引用）</p>
<h3 id="什么情况触发Full-GC"><a href="#什么情况触发Full-GC" class="headerlink" title="什么情况触发Full GC"></a>什么情况触发Full GC</h3><ol>
<li>年老代（Tenured）被写满</li>
<li>持久代（Perm）被写满 </li>
<li>System.gc()被显示调用 </li>
<li>上一次GC之后Heap的各域分配策略动态变化</li>
</ol>
<h3 id="Java如何排查OOM"><a href="#Java如何排查OOM" class="headerlink" title="Java如何排查OOM"></a>Java如何排查OOM</h3><p>OOM可能由于内存泄漏或溢出造成</p>
<ol>
<li>使用ps命令查看java进程，找到对应的pid</li>
<li>使用top命令，查找上述pid占用的内存（通常是很高的）</li>
<li>使用jstat -gcutil pid 500 5每隔500毫秒打印一次java堆状况（各个区的容量、使用容量、gc时间等），主要是看新生代、老年代的已使用量（用来分析垃圾回收是否能正常减少使用量，年轻代是否用满导致新数据直接建立到老年代），GC次数（用于查看年老代、年轻代占满后有没有正常回收垃圾，以及回收频率，比如回收频率很高说明每次垃圾回收的少，可能泄露）</li>
<li>jmap -histo pid可以打印当前堆中每个类的实例数量和内存占用（比如某个时间一些类实例应该被回收但是没有，说明存在泄露）</li>
<li>线上JVM可以配置-XX:+HeapDumpOnOutOfMemoryError，-XX:HeapDumpPath=/path/heap/dump，当OOM出现时自动导出内存快照，用于后续分析OOM问题</li>
</ol>
<p>总结：OOM要么短时间内涌入大量对象，导致系统堆内存不够用；要么是出现内存泄漏，导致垃圾对象没有被正确回收，堆内存越来越多。</p>
<h3 id="查看GC日志"><a href="#查看GC日志" class="headerlink" title="查看GC日志"></a>查看GC日志</h3><p>使用JVM参数-XX:+PrintGCTimeStamps，-XX:+PrintGCDeatils</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/interview/" rel="tag"># 面经</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/21/HR%E9%9D%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" rel="prev" title="HR面问题汇总">
      <i class="fa fa-chevron-left"></i> HR面问题汇总
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/" rel="next" title="Java多线程总结">
      Java多线程总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%95%A5%E5%85%88%E5%88%A4%E6%96%ADhash%E5%86%8D%E5%88%A4%E6%96%ADeqauls"><span class="nav-number">1.</span> <span class="nav-text">为啥先判断hash再判断eqauls()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E3%80%81List%E3%80%81List-lt-gt-%E3%80%81List-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">List、List、List&lt;?&gt;、List 泛型的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E6%B3%9B%E5%9E%8B%E5%8F%8A%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">3.</span> <span class="nav-text">Java泛型及类型擦除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%AE%B9%E5%99%A8"><span class="nav-number"></span> <span class="nav-text">Java容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88Collection"><span class="nav-number">1.</span> <span class="nav-text">集合Collection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">2.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">容器中的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1"><span class="nav-number">5.</span> <span class="nav-text">拆箱和装箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-finalize-finally"><span class="nav-number">6.</span> <span class="nav-text">final, finalize(), finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract-class%E5%92%8C%E6%8E%A5%E5%8F%A3interface%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C"><span class="nav-number">7.</span> <span class="nav-text">抽象类abstract class和接口interface有什么异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-NIO"><span class="nav-number">8.</span> <span class="nav-text">Java NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#NIO%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">8.0.1.</span> <span class="nav-text">NIO的缓冲区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NIO%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">8.0.2.</span> <span class="nav-text">NIO的非阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Channel"><span class="nav-number">8.0.3.</span> <span class="nav-text">Channel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Buffer"><span class="nav-number">8.0.4.</span> <span class="nav-text">Buffer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Selector"><span class="nav-number">8.0.5.</span> <span class="nav-text">Selector</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">字节流和字符流区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E3%80%81JRE%E3%80%81JDK%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">JVM、JRE、JDK区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%8F%8A%E5%A5%BD%E5%A4%84"><span class="nav-number">11.</span> <span class="nav-text">Java字节码及好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">Java和C++的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">13.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">14.</span> <span class="nav-text">抽象类和接口的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">15.</span> <span class="nav-text">定义不做事且没有参数的构造方法的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode%E5%92%8Cequals"><span class="nav-number">16.</span> <span class="nav-text">hashCode和equals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">17.</span> <span class="nav-text">值传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">18.</span> <span class="nav-text">反射机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">19.</span> <span class="nav-text">Java面向对象编程三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">19.0.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">19.0.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">19.0.3.</span> <span class="nav-text">多态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="nav-number">20.</span> <span class="nav-text">对象实例与对象引用有何不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB"><span class="nav-number">21.</span> <span class="nav-text">静态变量和实例变量区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">22.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">23.</span> <span class="nav-text">&#x3D;&#x3D;和equals的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%E3%80%81NIO%E3%80%81AIO%E5%8C%BA%E5%88%AB"><span class="nav-number">24.</span> <span class="nav-text">BIO、NIO、AIO区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">25.</span> <span class="nav-text">字符串常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-str-%E2%80%9Di%E2%80%9D%E5%92%8CString-str-new-String-%E2%80%9Ci%E2%80%9D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">26.</span> <span class="nav-text">String str&#x3D;”i”和String str &#x3D; new String(“i”)的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">27.</span> <span class="nav-text">红黑树与平衡二叉树的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-roots"><span class="nav-number">28.</span> <span class="nav-text">哪些对象可以作为gc roots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="nav-number">29.</span> <span class="nav-text">堆外内存及特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="nav-number">30.</span> <span class="nav-text">线程池七大参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">synchronized 和 volatile 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E3%80%81lock%E3%80%81volatile%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">synchronized、lock、volatile的底层实现分别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BHashMap-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%88%E8%BD%AC%E5%9B%9E%E9%93%BE%E8%A1%A8"><span class="nav-number">33.</span> <span class="nav-text">说一下HashMap 底层实现原理？什么时候又转回链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-%E8%B0%83%E4%BC%98%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F%E5%B9%B3%E6%97%B6%E7%A2%B0%E5%88%B0%E8%BF%87%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">34.</span> <span class="nav-text">JVM 调优有了解过吗？平时碰到过相关的问题吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E4%BC%9A%E6%8A%9B%E5%93%AA%E4%BA%9B%E5%BC%82%E5%B8%B8%EF%BC%9F%E5%85%B7%E4%BD%93%E8%AF%B4%E8%AF%B4%E3%80%82"><span class="nav-number">35.</span> <span class="nav-text">JVM 运行时区域说一下有哪些？是不是线程安全的？会抛哪些异常？具体说说。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E5%90%97%E3%80%82"><span class="nav-number">36.</span> <span class="nav-text">知道怎么破坏双亲委派模型吗。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E4%B8%8Efinal%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">37.</span> <span class="nav-text">static与final的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int%E7%B1%BB%E5%9E%8B%E5%9C%A832%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%92%8C64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E5%B1%8F%E8%94%BD%E5%B7%AE%E5%BC%82"><span class="nav-number">38.</span> <span class="nav-text">int类型在32位系统和64位系统中使用有区别吗？怎么屏蔽差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E8%B7%9FHashMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">Redis的哈希表跟HashMap有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TreeMap%E6%B2%A1%E6%9C%89%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E3%80%81%E5%AE%B9%E9%87%8F%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">为什么TreeMap没有负载因子、容量这样的参数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0"><span class="nav-number">41.</span> <span class="nav-text">Java中对象占用的字节数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E8%A7%A6%E5%8F%91Full-GC"><span class="nav-number">42.</span> <span class="nav-text">什么情况触发Full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5OOM"><span class="nav-number">43.</span> <span class="nav-text">Java如何排查OOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8BGC%E6%97%A5%E5%BF%97"><span class="nav-number">44.</span> <span class="nav-text">查看GC日志</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiahang Gu</p>
  <div class="site-description" itemprop="description">认真学习，享受生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JiahangGu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiahangGu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/fengzhizi76506" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;fengzhizi76506" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiahang Gu</span>

</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
