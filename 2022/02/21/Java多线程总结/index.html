<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="主要参考自CyC2018公众号文档，博客， 多线程线程池线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。线程复用：每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程总结">
<meta property="og:url" content="http://example.com/2022/02/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="菜汤里的咸鱼要翻身">
<meta property="og:description" content="主要参考自CyC2018公众号文档，博客， 多线程线程池线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。线程复用：每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-21T04:18:49.000Z">
<meta property="article:modified_time" content="2022-02-21T05:03:48.179Z">
<meta property="article:author" content="Jiahang Gu">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/02/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java多线程总结 | 菜汤里的咸鱼要翻身</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">菜汤里的咸鱼要翻身</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java多线程总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:18:49 / 修改时间：13:03:48" itemprop="dateCreated datePublished" datetime="2022-02-21T12:18:49+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>主要参考自CyC2018公众号文档，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq1404510094/article/details/80724038">博客</a>，</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。<br>线程复用：每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。<br>工作过程：</p>
<ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<br>a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；<br>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；<br>c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ol>
<p>顶层接口为Executors，线程池接口为ExecutorService。使用线程池作为缓存，避免每次创建和销毁线程浪费资源</p>
<ol>
<li>newCachedThreadPool。创建一个根据需要创建新线程的线程池。调用execute将重用以前构造的线程（如果线程可以用），如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除已有60秒未用的线程。ExecutorService executorService = Executors.newCachedThreadPool();通过execute()方法执行线程任务</li>
<li>newFixedThreadPool。创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行。如果提交任务时没有可用线程，则任务在队列中等待。在某个线程被显式关闭之前，池中的线程一直存在.ExecutorService executorService = Executors.newFixedThreadPool();</li>
<li>newScheduledThreadPool，创建一个线程池，安排在给定延迟后运行命令或定期执行</li>
<li>newSingleThreadExecutor，返回一个只有一个线程的线程池，在线程死后重新启动一个线程替代原来的线程。</li>
</ol>
<p>拒绝策略（频率好像很高）</p>
<ol>
<li>AbortPolicy：直接抛出异常，阻止系统正常运行</li>
<li>CallerRunsPolicy：只要线程池未关闭，直接在调用者线程中，运行当前被丢弃的任务。</li>
<li>DiscardOldestPolicy：丢弃最老的一个请求，并尝试再次提交当前任务</li>
<li>DiscardPolicy：丢弃无法处理的任务</li>
</ol>
<h3 id="如何在Java中实现线程"><a href="#如何在Java中实现线程" class="headerlink" title="如何在Java中实现线程"></a>如何在Java中实现线程</h3><p>四种方法：</p>
<ol>
<li>继承Thread，但不能继承别的类</li>
<li>实现Runnable接口，然后传递给Thread的构造函数</li>
<li>实现Callable接口，传递给Thread构造函数，执行后可以获取一个Future对象，用get()可以得到线程返回值</li>
<li>使用线程池，实现了缓存策略，避免了创建和销毁线程的开销</li>
</ol>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><ol>
<li>新建状态：使用new关键字创建了一个线程后，处于新建状态，仅由JVM分配内存，并初始化成员变量的值</li>
<li>就绪状态：调用了start()方法之后，处于就绪态，JVM会为其创建方法调用和程序计数器，等待调度运行</li>
<li>运行态：处于就绪态的线程获得了CPU，开始执行run()方法的程序</li>
<li>阻塞态：线程因为某种原因放弃了cpu使用权，即让出cpu时间片停止运行。有三种情况：1）等待阻塞：运行中的线程执行o.wait()方法，jvm会将该线程放入等待队列；2）同步阻塞：运行中的线程在获取对象的同步锁时，若该同步锁被别的线程占用，jvm会将该线程放入锁池中；3）其他阻塞：运行中的线程执行sleep或t.join()等待线程终止或发出IO请求时，jvm将线程置为阻塞态。</li>
<li>死亡态：1）正常结束：run()或call()执行完成；2）异常结束：线程抛出未捕获的Exception或Error；3）调用stop：直接调用stop方法结束线程，但容易导致死锁</li>
</ol>
<h3 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a>终止线程方式</h3><ol>
<li>正常运行结束</li>
<li>使用退出标志退出线程：使用一个变量控制循环，在外部修改变量值之后关闭线程</li>
<li>interrupt方法结束：1）线程处于阻塞态，调用interrupt()方法时会抛出InterruptException异常，阻塞中的方法抛出异常并通过代码捕获，break跳出循环；2）线程未阻塞：使用isInterrupted()判断线程的中断标志来退出循环</li>
<li>stop方法终止：thread.stop()强行终止，调用后创建子线程的线程会抛出ThreadDeathError，释放子线程所持有的所有锁，被保护的数据可能呈现出不一致性。</li>
</ol>
<h3 id="sleep和wait区别"><a href="#sleep和wait区别" class="headerlink" title="sleep和wait区别"></a>sleep和wait区别</h3><ol>
<li>sleep方法属于Thread类，而wait()是属于Object</li>
<li>sleep()方法导致程序暂停执行指定时间，让出cpu，但监控状态依然保持，指定时间过后自动恢复到运行态</li>
<li>调用sleep()方法时，线程不会释放对象锁，而wait调用时线程会放弃已获得的锁，进入等待此对象的等待锁池，只有针对此对象调用notify方法后本线程才进入对象锁池准备获取对象锁</li>
</ol>
<h3 id="用Ruanable还是Thread"><a href="#用Ruanable还是Thread" class="headerlink" title="用Ruanable还是Thread"></a>用Ruanable还是Thread</h3><p>由于Java不支持类的多重继承，但可以实现多个接口。如果实现类需要继承其他类，实现Runnable接口。</p>
<h3 id="start-和run-有什么区别"><a href="#start-和run-有什么区别" class="headerlink" title="start()和run()有什么区别"></a>start()和run()有什么区别</h3><ol>
<li>start()方法启动线程，实现了多线程运行，无需等待run方法执行完毕可以继续执行下面的代码</li>
<li>调用start()启动一个线程进入就绪态</li>
<li>run()称为线程体，包含了要执行的线程的内容，线程进入运行态才开始执行run函数的代码，run方法结束线程终止</li>
</ol>
<h3 id="Runnable和Callable有什么不同"><a href="#Runnable和Callable有什么不同" class="headerlink" title="Runnable和Callable有什么不同"></a>Runnable和Callable有什么不同</h3><p>Callable的call()方法可以返回值和抛出异常，可以返回装载有计算结果的Future对象，run()没有这些功能</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ol>
<li>是后台线程，为用户线程提供公共服务，在没有用户线程可服务时自动离开</li>
<li>优先级较低</li>
<li>可以通过setDaemon(true)设置线程为守护线程</li>
<li>守护线程产生的新线程也是守护线程</li>
<li>线程是JVM级别的，应用启动的线程的生命周期和应用不保持同步，而是由JVM管理</li>
<li>生命周期：依赖于系统而不是中断，当所有线程都是守护线程时JVM可以退出。经典样例是垃圾回收线程</li>
</ol>
<h3 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h3><ol>
<li>乐观锁：认为读多写少，并发写可能性低，拿数据不上锁。但是在更新时会判断一下在此期间别人有没有更新这个数据，采取在写时先读当前版本号，然后加锁如果一样则更新，失败则重复CAS操作。乐观锁基本通过CAS操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</li>
<li>悲观锁：每次拿数据都先加锁。Java中使用synchronized实现。AQS框架下的锁是先尝试CAS乐观锁操作，操作失败才会转换为悲观锁，如ReentreenLock</li>
<li>自旋锁：如果持有锁的线程能在很短时间内释放锁，则等待锁的线程不需要做内核态和用户态的切换进入阻塞态，只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，避免用户线程和内核切换的开销。但自旋过程cpu做无用功，需要设置一个自旋等待的最大时间。自旋后仍没有得到锁则停止自旋进入阻塞态。如果锁竞争不激烈且占用锁时间很短，使用自旋由于节省了线程上下文切换的时间带来了性能提升；但如果锁竞争激烈或占锁时间长则使用自旋会消耗cpu做无用功。通过引入适应性自旋锁，每次自旋锁的自旋时间由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定。</li>
<li>可重入锁：递归锁，同一线程外层函数获得锁之后，内层函数仍然可以获取该锁</li>
<li>非公平锁：按随机、就近原则分配锁的机制。</li>
<li>公平锁：锁的分配机制是公平的，先对锁提出获取请求的线程先分配到锁。通常非公平锁的性能高于公平锁，除非程序特殊要求使用公平锁</li>
</ol>
<h3 id="synchronized同步锁"><a href="#synchronized同步锁" class="headerlink" title="synchronized同步锁"></a>synchronized同步锁</h3><p>可以将任意一个非NULL对象当锁，属于悲观锁和可重入锁。<br>作用范围：</p>
<ol>
<li>作用于方法时，锁住的是对象的实例</li>
<li>作用于静态方法时，锁住的是Class实例，又因为class的数据存储在元空间全局共享，因此静态方法锁相当于类的一个全局锁，会锁住所有调用该方法的线程</li>
<li>作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。他有多个队列，多个线程一起访问某个对象监视器的时候，对象监视器将这些线程存储在不同的容器</li>
</ol>
<p>核心组件：</p>
<ol>
<li>wait set：存放调用wait方法被阻塞的线程</li>
<li>contention list：竞争队列，所有请求锁的线程首先放在竞争队列中</li>
<li>entry list：竞争队列中有资格成为候选资源的线程移动到entry list</li>
<li>OnDeck：任意时刻最多只有一个线程正在竞争锁资源，称为OnDeck</li>
<li>Owner：已经获取到锁资源的线程</li>
</ol>
<p>synchronized实现</p>
<ol>
<li>JVM每次从队列尾部取出一个数据用于锁竞争候选者OnDeck，但在并发情况下contentionList被大量并发线程CAS访问，为降低对尾部元素的竞争，JVM将一部分线程移动到EntryList中作为候选竞争线程</li>
<li>Owner线程在unlock时将contentionList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程</li>
<li>Owner线程不直接把锁传递给OnDeck线程，而是把锁竞争的权力交给OnDeck，由OnDeck重新竞争锁，以牺牲公平性换来系统吞吐量的提升</li>
<li>OnDeck线程获得锁资源后变为Owner线程，没有得到锁的线程仍在EntryList。如果Owner线程被wait阻塞，则转移到waitSet队列，直到某一时可被唤醒，重新进入ENtryList</li>
<li>处于contentionList、EntryList、WaitSet中的线程都是阻塞态，由操作系统完成</li>
<li>synchronized是非公平锁，在线程进入contentionList先自旋，获取不到锁才进入ContentionList，对于已进入队列和OnDeck线程是不公平的</li>
<li>每个对象都有个monitor对象，加锁是在竞争monitor对象，加锁指令是在前后加monitorenter和monitorexit实现</li>
<li>synchronized是一个重量级操作，需调用操作系统接口，性能较低</li>
<li>synchronized引入了适应自旋、锁消除、锁粗化、轻量级锁和偏向锁</li>
</ol>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>是可重入锁，继承了接口Lock，可以完成synchronized可以做的所有工作，此外还可完成诸如可响应中断锁、可轮询锁请求、定时锁等避免死锁的方法<br>主要方法：</p>
<ol>
<li>void lock()：如果锁处于空闲状态则获取锁，否则阻塞线程</li>
<li>boolean tryLock()：如果锁可用则获取，并返回true，否则返回false。即使不可用也不会阻塞该线程</li>
<li>void unlock()：线程释放持有的锁</li>
<li>Condition newCondition()：获取等待通知组件，和锁绑定，只有获取锁才能调用await方法，并且通过await方法和singal实现通信</li>
</ol>
<p>Condition类和Object类锁方法区别</p>
<ol>
<li>Condition类的await、signal、signalAll方法和Object类的wait、notify、notifyAll方法等效</li>
<li>ReentrantLock类可以唤醒指定条件的线程，而Object的唤醒是随机的</li>
</ol>
<p>tryLock、lock和lockInterruptibly区别</p>
<ol>
<li>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false</li>
<li>lock 能获得锁就返回 true，不能的话一直等待获得锁</li>
<li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。</li>
</ol>
<h3 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h3><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。互斥量就是计数为1的信号量。<br>通过acquire()和release()方法来获得和释放临界资源，其中acquire方法默认为可响应中断锁，与lockInterruptibly作用效果一致</p>
<h3 id="Atomic类"><a href="#Atomic类" class="headerlink" title="Atomic类"></a>Atomic类</h3><p>java.util.concurrent.atomic包下，提供原子操作的包装类型，例如AtomicInteger可以实现i++运算的原子性。效率比ReentrantLock高很多，并且可以使用AtomicReference<V>将对象所有操作转化为原子操作</p>
<h3 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h3><p>读写分离提高性能，接口位于java.util.concurrent.locks.ReadWriteLock</p>
<h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><p>独占锁模式每次只能一个线程持有锁，ReentrantLock以独占方式实现，悲观锁<br>共享锁允许多个线程同时获取锁，并发访问共享资源，乐观锁</p>
<h3 id="锁的四种状态"><a href="#锁的四种状态" class="headerlink" title="锁的四种状态"></a>锁的四种状态</h3><p>无锁状态、偏向锁、轻量级锁和重量级锁，随着锁的竞争可以从偏向锁升级到更重的锁</p>
<ol>
<li>偏向锁：如果锁由同一线程多次获得，可以在某个线程获得锁之后引入偏向锁，消除这个锁重入的开销。如果没有其余线程竞争锁，每次线程来都可直接得到锁，看起来偏向于这个线程。只需要在置换ThreadID的时候依赖一次CAS指令，在只有一个线程执行同步块时进一步提高性能</li>
<li>轻量级锁是在没有多线程同一时间访问同一锁的情况下，即线程交替执行同步块，减少重量级锁使用产生的性能消耗</li>
<li>重量级锁：使用monitor实现，本质依赖于低层操作系统的mutex lock实现，需要从用户态切换到内核态，成本很高。</li>
</ol>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>是一种思想，例如ConcurrentHashMap采用分段锁的方式提高并发度</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ol>
<li>减少锁持有时间</li>
<li>减小锁粒度：大对象拆分小对象，增加并行度，降低锁竞争，提高偏向锁和轻量级锁的成功率</li>
<li>锁分离：根据功能进行分离</li>
<li>锁粗化：每个线程持有锁的时间尽量短</li>
<li>锁消除：由编译器执行</li>
</ol>
<h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><p>yield：使当前线程让出CPU执行时间片，与其他线程一起重新竞争cpu时间<br>join：等待其他线程终止，当前线程调用另一个线程的join方法，会阻塞直到另一个线程执行结束。如果需要用到其余线程的返回结果可以采用join</p>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>CPU执行线程前将线程的上下文加载进寄存器，时间结束后保存任务的状态，并加载下一任务的状态。上下文是指CPU寄存器和程序计数器的内容，寄存器：cpu内速度很快的内存，程序计数器表明指令序列中cpu正在执行的位置<br>切换活动：</p>
<ol>
<li>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。</li>
<li>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。</li>
<li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。</li>
</ol>
<p>引起切换的原因：</p>
<ol>
<li>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；</li>
<li>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；</li>
<li>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；</li>
<li>用户代码挂起当前任务，让出 CPU 时间；</li>
<li>硬件中断；</li>
</ol>
<h3 id="CountDownLatch和CyclicBarrier"><a href="#CountDownLatch和CyclicBarrier" class="headerlink" title="CountDownLatch和CyclicBarrier"></a>CountDownLatch和CyclicBarrier</h3><p>均位于java.util.concurrent包<br>CountDownLatch实现类似计数器的功能，在当前线程调用CountDownLatch.await()时，需要等其余线程执行CountDownLatch.countDown()直到0才会执行<br>CyclicBarrier实现一组线程等待至某个状态之后再全部同时执行。并且当所有线程都释放之后，还可以重用。await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务</p>
<h3 id="volatile关键字作用"><a href="#volatile关键字作用" class="headerlink" title="volatile关键字作用"></a>volatile关键字作用</h3><p>1）Java编写的程序有时为了提高运行效率，编译器会自动优化，把经常访问的变量缓存起来，程序在读变量时可能直接从缓存读取，而不会去内存读。当多线程编程时，变量的值可能因为别的线程改变了，而该缓存的值不会相应的改变，造成读取的值与变量实际值不一致。volatile被设计用来修饰不同线程访问和修改的变量。被volatile类型定义的变量，系统每次用到时都直接从对应内存提取而不会利用缓存，这样线程在任何时候拿到的变量的值都相同。2）可以禁止JVM指令重排，保证在多线程环境下正常运行。例如实例化uniqueInstance = new Singleton();时分三步执行：（1）为uniqueInstance分配内存空间；（2）初始化uniqieInstance；（3）将uniqueInstance指向分配的内存地址。JVM可能重排为1,3,2，例如T1执行了1,3，T2判断if调用时发现不为空，直接返回uniqueInstance，但此时uniqueInstance只是不为null，还未被初始化</p>
<ol>
<li>变量可见性：保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。在此期间不会执行加锁操作，因此不会使线程阻塞，比sychronized关键字更轻量级。适用于：一个变量被多个线程共享，线程直接给这个变量赋值。单次读写具有原子性，因为每次读变量直接从内存读</li>
<li>可以禁止JVM指令重排</li>
</ol>
<h3 id="线程之间共享数据的方式"><a href="#线程之间共享数据的方式" class="headerlink" title="线程之间共享数据的方式"></a>线程之间共享数据的方式</h3><p>Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。</p>
<ol>
<li>数据抽象成一个类，并将数据的操作作为这个类的方法，方法加synchronized</li>
<li>将 Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个 Runnable 对象调用外部类的这些方法</li>
</ol>
<h3 id="ThreadLocal作用"><a href="#ThreadLocal作用" class="headerlink" title="ThreadLocal作用"></a>ThreadLocal作用</h3><p>线程本地存储，作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，用于减少同一个线程内多个函数或者组件之间一些公共变量传递的复杂度<br>ThreadLocalMap（线程的一个属性）</p>
<ol>
<li>每个线程都有一个自己的ThreadLocalMap类对象，将线程自己的对象保存，可以正确访问到自己的对象</li>
<li>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。</li>
<li>ThreadLocalMap 其实就是线程里面的一个属性</li>
</ol>
<h3 id="ThreadLocal内存泄漏原因及解决方案"><a href="#ThreadLocal内存泄漏原因及解决方案" class="headerlink" title="ThreadLocal内存泄漏原因及解决方案"></a>ThreadLocal内存泄漏原因及解决方案</h3><p>ThreadLocal实现是每个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal实例，value为线程变量的副本。当一个ThreadLocal不存在外部强引用时，key会被GC回收，导致ThreadLocalMap中的key为null，但value还存在着强引用，只有线程退出value才会被回收，否则一直存在。如果key使用强引用，在回收ThreadLocal时，ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。而使用弱引用时，即使没有手动删除，ThreadLocal也会被回收，并且key为null时，下次调用set(),get(),remove()时也会清除value。<br>所以根本原因是ThreadLocalMap和Thread的生命周期一样，没有手动删除对应key就会内存泄漏，使用弱引用保证ThreadLocal不会内存泄漏，但value会。<br>解决方案：</p>
<ol>
<li>每次使用完ThreadLocal都调用remove方法清除数据</li>
<li>将ThreadLocal变量定义为private static，一直存在ThreadLocal强引用，保证任何时候能通过ThreadLocal弱引用访问到value值并且清除掉</li>
</ol>
<h3 id="ReentrantLock和synchronized比较"><a href="#ReentrantLock和synchronized比较" class="headerlink" title="ReentrantLock和synchronized比较"></a>ReentrantLock和synchronized比较</h3><p>共同点：</p>
<ol>
<li>用来协调多线程对共享对象、变量的访问</li>
<li>都是可重入锁，同一线程可以多次获得同一个锁</li>
<li>保证可见性和互斥性</li>
</ol>
<p>不同点：</p>
<ol>
<li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li>
<li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</li>
<li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</li>
<li>ReentrantLock 可以实现公平锁</li>
<li>ReentrantLock 通过 Condition 可以绑定多个条件</li>
<li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</li>
<li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。</li>
<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</li>
<li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
<li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</li>
</ol>
<h3 id="ConcurrentHashMap并发"><a href="#ConcurrentHashMap并发" class="headerlink" title="ConcurrentHashMap并发"></a>ConcurrentHashMap并发</h3><p>ConcurrentHashMap实现了高并发度的哈希实现，通过减小锁粒度（缩小锁定对象的范围），从而减小锁冲突的可能性，提高系统并发能力。内部细分了若干个段，每个段独立加锁。hash操作时先根据hashcode得出在哪个段，然后对段加锁，多线程操作时只要操作表项不在同一个段中，就可以并行。 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</p>
<h3 id="CAS操作及问题"><a href="#CAS操作及问题" class="headerlink" title="CAS操作及问题"></a>CAS操作及问题</h3><p>CAS（compare and swap）比较并交换。V表示要更新的变量，E表示旧值，N表示新值。当且仅当V等于E时，才将V的值设为N。如果不同则其他线程进行了更新，当前线程重试或返回。多线程同时使用CAS操作一个变量时，只有一个胜出，并成功更新，其余均失败。失败线程不会挂起，仅被告知失败，并允许再次尝试，也允许放弃操作。<br>存在ABA问题，即取出旧值后操作完成，发现和旧值相同完成交换操作，但其实这期间有其余线程先对数据进行了修改，然后又修改回原值，虽然数据一样但已经发生变化。可以通过添加版本号的方式解决ABA问题。</p>
<h3 id="什么是AQS（抽象队列同步器）"><a href="#什么是AQS（抽象队列同步器）" class="headerlink" title="什么是AQS（抽象队列同步器）"></a>什么是AQS（抽象队列同步器）</h3><p>AbstractQueuedSynchronizer定义了一套多线程访问共享资源的同步器框架。例如ReentrantLock/Semaphore/CountDownLatch均依赖于AQS实现。<br>AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。state有set, get, CAS三种访问方式。AQS定义了独占式和共享式。但AQS只是一个框架，具体资源的获取和释放方式由自定义同步器去实现。<br>同步器的实现：</p>
<ol>
<li>以ReentrantLock为例，state初始化0，表示未锁定，A线程lock时调用tryAcquire独占锁并state+1，此后其他线程acquire失败，直到A线程unlock。此外A线程可以重复获取锁。但获取多少次就释放多少次</li>
<li>CountDownLatch时，state初始化为N，N个子线程并行，每个子线程执行countDown后state会CAS减1，等所有子线程执行完后，unpark主调用线程，主线程从await函数返回，继续执行操作</li>
</ol>
<h3 id="Java中notify和notifyAll有什么区别"><a href="#Java中notify和notifyAll有什么区别" class="headerlink" title="Java中notify和notifyAll有什么区别"></a>Java中notify和notifyAll有什么区别</h3><p>notify不能唤醒某个具体的线程，多个线程等待时会随机唤醒一个。而notifyAll会唤醒所有等待的线程并允许他们争夺锁，确保至少有一个线程能运行</p>
<h3 id="为什么wait，notify和notifyAll这些方法不在Thread类里"><a href="#为什么wait，notify和notifyAll这些方法不在Thread类里" class="headerlink" title="为什么wait，notify和notifyAll这些方法不在Thread类里"></a>为什么wait，notify和notifyAll这些方法不在Thread类里</h3><p>Java提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程要等待某些锁，那么调用等待对象的wait方法，可以明确定义线程是在等待哪个锁。而如果放在Thread里就不能看出在等待的对象。总之，这些方法都是锁级别操作，需要定义在对象中而不是具体类</p>
<h3 id="什么是FutureTask"><a href="#什么是FutureTask" class="headerlink" title="什么是FutureTask"></a>什么是FutureTask</h3><p>在Java并发程序中FutureTask表示一个可以取消的异步运算，有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有运算完成才能取回结果，如果未完成调用get方法会阻塞。一个FutureTask对象可以包装实现了Callable和Runnable接口的类，并且可以提交给Executor执行</p>
<h3 id="interrupted和isInterrupted方法的区别"><a href="#interrupted和isInterrupted方法的区别" class="headerlink" title="interrupted和isInterrupted方法的区别"></a>interrupted和isInterrupted方法的区别</h3><p>区别主要是前者会清除中断状态而后者不会。Java多线程的中断机制用内部标识实现，调用Thread.interrupt()会中断一个线程并设置中断标识为true。当中断线程调用静态方法Thread.interrputed()检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其他线程的中断状态且不会改变在中断状态标识。总结就是，任何抛出InterruptedException异常的方法都会将中断状态清零。</p>
<h3 id="JMM（Java内存模型）"><a href="#JMM（Java内存模型）" class="headerlink" title="JMM（Java内存模型）"></a>JMM（Java内存模型）</h3><p>Java内存模型试图屏蔽各种硬件和操作系统的内存差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果，是一种虚拟机规范，规范了JVM和计算机内存是如何协同工作的；规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步地访问共享变量<br>调用栈和本地变量放在线程栈上（线程的工作内存），对象存储在堆上，具体划分如下：</p>
<ol>
<li>本地变量可能是原始类型，在这种情况下总是在线程栈上</li>
<li>本地变量可能是指向一个对象的引用，此时引用放在线程栈上，对象本身在堆上</li>
<li>一个对象可能包含方法，方法可能包含本地变量，本地变量仍在线程栈上，即使方法所属对象在堆上</li>
<li>对象的成员变量可能随着对象自身存放在堆上</li>
<li>静态成员变量和类定义一起放在堆上</li>
<li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时也可以访问对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，他们都访问这个对象的成员变量，但每个线程拥有这个成员变量的私有拷贝，即主内存副本拷贝。不同线程之间变量值传递需要通过主内存完成</li>
</ol>
<h5 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h5><p>8个操作来完成主内存和工作内存的交互操作</p>
<ol>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在read之后执行，把read得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在store之后执行，把store得到的值写入主内存变量</li>
<li>lock：作用于主内存的变量，把一个变量标识为一条线程独占状态</li>
<li>unlock：作用于主内存变量，解锁</li>
</ol>
<h5 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h5><ol>
<li>原子性：JMM保证上述操作都具有原子性。但允许JVM将没有被volatile修饰的64位数据的读写分为两次32位操作进行。例如int类型读写操作满足原子性是指load、assign和store单操作满足原子性，但int++不满足，因为需要先读再写，新变量值依赖于旧值。使用AtomicInteger能保证多线程修改的原子性。</li>
<li>可见性：一个线程修改了共享变量的值，其他线程能立即得知这个修改。JMM通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值实现可见性。主要有三种实现方式：<br>1）volatile：要求线程直接从主存中读一个变量，如果变量被修改总是会被写回主存，保证新值能立即同步到主内存<br>2）synchronized：对变量lock前清空工作内存中此变量的值，在执行引擎使用变量前重新执行load或assign操作初始化变量值，对变量执行unlock之前将变量值同步回主内存<br>3）final：被final修饰的字段在构造器中一旦初始化完成，并没有发生this逃逸（其他线程使用this引用访问到初始化了一半的对象），则其他线程可见final字段值</li>
<li>有序性：在本线程内观察，所有操作无序，另一个线程观察则是无序的，因为发生了指令重排。JMM允许指令重排，不影响单线程执行，但会影响多线程并发执行的正确性。volatile关键字添加内存屏障禁止指令重排，即重排时不能把后面的指令放到内存屏障之前。synchronized通过monitorenter和monitorexit确保每个时刻只有一个线程执行同步代码</li>
</ol>
<p>此外JVM规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成</p>
<ol>
<li>单一线程原则：一个线程内程序前面的操作先行发生于后面的操作</li>
<li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量原则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li>
<li>线程启动规则：Thread对象的start()方法调用先行发生于此线程的每一个动作</li>
<li>线程加入规则：Thread对象的结束先行发生于join()方法返回</li>
<li>线程中断规则：线程interrupt()方法调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始</li>
<li>传递性：a先行于b，b先行于c则a先行于c</li>
</ol>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>将阻塞特性加入队列，阻塞的情况有：</p>
<ol>
<li>队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞，直到有数据放入队列</li>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞，直到队列中有空位置，线程自动唤醒</li>
</ol>
<p>主要方法<br>|方法类型|抛出异常|特殊值|阻塞|超时|<br>|:—:|:—:|:—:|:—-:|:—:|<br>|插入|add(e)|offer(e)|put(e)|offer(e, time, unit)|<br>|移除|remove()|poll()|take()|poll(time, unit)|<br>|检查|element()|peek()|x|x|</p>
<p>表格中第一列表示在无法进行相应操作时的结果，例如add(e)在无法加入时会抛出异常并终止，超时会在给定时间内阻塞，如果还无法完成则放弃操作</p>
<h5 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h5><ol>
<li>ArrayBlockingQueue：用数组实现的有界阻塞队列，按照先进先出的原则保持元素顺序，默认下不保证访问者公平的访问队列，公平是指先阻塞的线程先操作</li>
<li>LinkedBlockingQueue：基于链表的阻塞队列，FIFO。对生产者和消费者端分别采用独立锁控制数据同步，以提高并发性，处理并发数据更高效</li>
<li>PriorityBlockingQueue：支持优先级的无界队列。默认情况下采取自然升序，可以自定义compareTo()方法指定排序规则，或初始化时构造Comparator参数对象，同优先级元素的顺序无法保证</li>
<li>DelayQueue：支持延时获取元素的无界阻塞队列。使用PriorityQueue实现，元素必须实现Delayed接口，创建元素时指定多久才能从队列中获取当前元素，延迟期满才能拿元素。可以用于缓存系统、定时任务调度</li>
<li>SynchronousQueue：不存储元素的阻塞队列。，每一个put操作必须等待一个take操作，否则不能继续添加元素，可用于传递数据，适合传递性场景，吞吐量较高</li>
<li>LinkedTransferQueue：由链表组成的无界阻塞TransferQueue队列，多了tryTransfer和transfer方法，transfer方法是如果当前有消费者正在等待接收元素，transfer方法立刻将生产者传入的元素transfer给消费者，如果没有等待的线程就将元素存在队列的tail节点，并等到该元素被消费了才返回</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。可以从两端插入和移除元素。相比其他队列在操作后加First和Last表示对队列的首或尾操作</li>
</ol>
<h3 id="线程运行时发生异常会怎样"><a href="#线程运行时发生异常会怎样" class="headerlink" title="线程运行时发生异常会怎样"></a>线程运行时发生异常会怎样</h3><p>如果异常没有被捕获该线程会停止运行</p>
<h3 id="为什么wait和notify方法要在同步块中调用"><a href="#为什么wait和notify方法要在同步块中调用" class="headerlink" title="为什么wait和notify方法要在同步块中调用"></a>为什么wait和notify方法要在同步块中调用</h3><p>一个线程需要调用对象的wait方法时要拥有该对象的锁，接着释放这个对象锁并进入阻塞状态直到其他线程调用对象的notify方法。调用notify时也需要释放对象锁，以便其他等待的线程可以得到。这些方法都需要在线程持有对象锁，只能在同步块中首先获得锁才可以调用。不然会抛出IllegalMonitorStateException异常</p>
<h3 id="为什么在循环中检查等待条件"><a href="#为什么在循环中检查等待条件" class="headerlink" title="为什么在循环中检查等待条件"></a>为什么在循环中检查等待条件</h3><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因</p>
<h3 id="同步集合和并发集合有什么区别"><a href="#同步集合和并发集合有什么区别" class="headerlink" title="同步集合和并发集合有什么区别"></a>同步集合和并发集合有什么区别</h3><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。并发集合提供线程安全并用锁分离和内部分区等技术提高了可扩展性</p>
<h3 id="Java中堆和栈的不同"><a href="#Java中堆和栈的不同" class="headerlink" title="Java中堆和栈的不同"></a>Java中堆和栈的不同</h3><p>每个线程有自己的栈内存，用于存储本地变量、方法参数和栈调用，一个线程中存储的变量对其他线程不可见。堆是所有线程共享的一片公用内存区，对象在堆里创建，线程会从堆中拷贝变量副本到自己的栈。</p>
<h3 id="写代码实现生产者-消费者问题"><a href="#写代码实现生产者-消费者问题" class="headerlink" title="写代码实现生产者-消费者问题"></a>写代码实现生产者-消费者问题</h3><p>低级办法使用wait和notify，好点的办法是用Semaphore和BlockingQueue实现</p>
<h3 id="活锁和死锁的区别"><a href="#活锁和死锁的区别" class="headerlink" title="活锁和死锁的区别"></a>活锁和死锁的区别</h3><p>处于活锁的线程或进程的状态是不断改变的，是一种特殊的饥饿。例如两个人对面遇到都向同一方向避让导致不能通过。即活锁的进程状态可以改变但不能继续执行</p>
<h3 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h3><p>Thread中使用holdsLock()。</p>
<h3 id="JVM中哪个参数用来控制线程的堆栈大小"><a href="#JVM中哪个参数用来控制线程的堆栈大小" class="headerlink" title="JVM中哪个参数用来控制线程的堆栈大小"></a>JVM中哪个参数用来控制线程的堆栈大小</h3><p>-Xss</p>
<h3 id="三个线程T1-T2-T3怎么确保按顺序执行"><a href="#三个线程T1-T2-T3怎么确保按顺序执行" class="headerlink" title="三个线程T1,T2,T3怎么确保按顺序执行"></a>三个线程T1,T2,T3怎么确保按顺序执行</h3><p>可以使用join在一个线程中启动另一个。可以在T3中调用T2.join，T2中调用T1.join</p>
<h3 id="Thread类中的yield方法有什么用"><a href="#Thread类中的yield方法有什么用" class="headerlink" title="Thread类中的yield方法有什么用"></a>Thread类中的yield方法有什么用</h3><p>yield方法可以暂停当前正在执行的线程对象（即放弃CPU时间片），让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行</p>
<h3 id="如果你提交任务时，线程池队列已满，会发生什么"><a href="#如果你提交任务时，线程池队列已满，会发生什么" class="headerlink" title="如果你提交任务时，线程池队列已满，会发生什么"></a>如果你提交任务时，线程池队列已满，会发生什么</h3><p>如果当前正在执行的线程数小于线程池的最大线程数，则新建线程执行任务。否则根据配置的策略执行拒绝并抛出相应异常</p>
<h3 id="线程池中submit和execute方法有什么区别"><a href="#线程池中submit和execute方法有什么区别" class="headerlink" title="线程池中submit和execute方法有什么区别"></a>线程池中submit和execute方法有什么区别</h3><p>都可以向线程池提交任务，但execute方法返回类型是void，定义在Executor接口中，而submit方法可以返回持有计算结果的Future对象，定义在ExecutorService接口中，扩展了Executor接口。其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法</p>
<h3 id="什么是阻塞式方法"><a href="#什么是阻塞式方法" class="headerlink" title="什么是阻塞式方法"></a>什么是阻塞式方法</h3><p>程序会一直等待该方法完成，期间不做任何事情，例如ServerSocket的accept方法</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>每个线程有优先级，一般情况下高优先级线程在运行时具有优先权，但依赖于线程调度的实现，与OS相关。我们可以定义优先级，但不能保证高优先级线程一定会先于低优先级线程执行。优先级是一个int变量1-10，10是最高级</p>
<h3 id="线程调度器和时间分片"><a href="#线程调度器和时间分片" class="headerlink" title="线程调度器和时间分片"></a>线程调度器和时间分片</h3><p>线程调度器是操作系统服务，负责为runnable态线程分配CPU时间，启动线程后执行依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给runnable线程的过程。分配方法由线程调度算法控制。线程调度不受JVM控制，最好不要让线程依赖于优先级</p>
<h3 id="如何在Java中创建Immutable（不变的）对象"><a href="#如何在Java中创建Immutable（不变的）对象" class="headerlink" title="如何在Java中创建Immutable（不变的）对象"></a>如何在Java中创建Immutable（不变的）对象</h3><p>Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。创建不可变类的步骤：通过构造方法初始化所有成员、对变量不提供setter方法、将所有成员声明为私有的、在getter方法中，不直接返回对象本身而是克隆对象返回对象的拷贝</p>
<h3 id="ReadWriteLock是什么"><a href="#ReadWriteLock是什么" class="headerlink" title="ReadWriteLock是什么"></a>ReadWriteLock是什么</h3><p>读写锁用来提升并发程序性能，使用锁分离技术。ReadWriteLock中维护ReadLock和WriteLock，将读写操作分离。可以实现为JUC.locks.ReentrantReadWriteLock</p>
<h3 id="忙循环"><a href="#忙循环" class="headerlink" title="忙循环"></a>忙循环</h3><p>用循环让一个线程等待，不放弃CPU。目的是保留CPU缓存，多核系统一个等待线程醒来时可能在另一个内核运行，需要重建缓存。忙循环可以避免重建缓存和减少等待重建的时间</p>
<h3 id="volatile和atomic变量的不同"><a href="#volatile和atomic变量的不同" class="headerlink" title="volatile和atomic变量的不同"></a>volatile和atomic变量的不同</h3><p>volatile可以确保有序性，但不能保证原子性。例如a++不是原子性。而AtomicInteger类提供的atomic方法可以使其具有原子性</p>
<h3 id="同步块内的线程抛出异常会发生什么"><a href="#同步块内的线程抛出异常会发生什么" class="headerlink" title="同步块内的线程抛出异常会发生什么"></a>同步块内的线程抛出异常会发生什么</h3><p>只要同步块退出，里面的线程都会自动释放锁</p>
<h3 id="单例模式的双检锁是什么"><a href="#单例模式的双检锁是什么" class="headerlink" title="单例模式的双检锁是什么"></a>单例模式的双检锁是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getUniqueInstance() &#123;</span><br><span class="line">        if (uniqueInstance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (uniqueInstance == null) &#123;</span><br><span class="line">                    uniqueInstance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不加第二个if，则两个线程都进入第一个if语句，虽然有加锁，但是会先后实例化。所以需要两个if：第一个if避免uniqueInstance已经实例化之后的加锁，第二个if语句保证不会有多个线程同时进入第一个if后得到锁之后顺序实例化。<br>volatile关键字的作用：1）Java编写的程序有时为了提高运行效率，编译器会自动优化，把经常访问的变量缓存起来，程序在读变量时可能直接从缓存读取，而不会去内存读。当多线程编程时，变量的值可能因为别的线程改变了，而该缓存的值不会相应的改变，造成读取的值与变量实际值不一致。volatile被设计用来修饰不同线程访问和修改的变量。被volatile类型定义的变量，系统每次用到时都直接从对应内存提取而不会利用缓存，这样线程在任何时候拿到的变量的值都相同。2）可以禁止JVM指令重排，保证在多线程环境下正常运行。例如实例化uniqueInstance = new Singleton();时分三步执行：（1）为uniqueInstance分配内存空间；（2）初始化uniqieInstance；（3）将uniqueInstance指向分配的内存地址。JVM可能重排为1,3,2，例如T1执行了1,3，T2判断if调用时发现不为空，直接返回uniqueInstance，但此时uniqueInstance只是不为null，还未被初始化</p>
<h3 id="如何在Java中创建线程安全的Singleton"><a href="#如何在Java中创建线程安全的Singleton" class="headerlink" title="如何在Java中创建线程安全的Singleton"></a>如何在Java中创建线程安全的Singleton</h3><ol>
<li>静态内部类实现<br>Singleton类被加载时，静态内部类SingletonHolder没有被加载进内存，只有调用getUniqueInstance方法触发SingletonHolder.INSTANCE时才会被加载，并且实例化，可以确保只实例化一次。既具有延迟初始化的好处，JVM也提供了线程安全的支持<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton getUniqueInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>枚举实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.INSTANCE;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以防止反射攻击。其他实现中，可以通过setAccessible()方法修改私有构造函数访问级别为public，然后调用构造函数从而实例化对象，要防止攻击，需要在构造函数中添加防止多次实例化的代码。而本实现由JVM保证只会实例化一次</li>
</ol>
<h3 id="3条你遵循的多线程最佳实践"><a href="#3条你遵循的多线程最佳实践" class="headerlink" title="3条你遵循的多线程最佳实践"></a>3条你遵循的多线程最佳实践</h3><ol>
<li>给线程起有意义的名字</li>
<li>避免锁定和缩小同步的范围</li>
<li>多用同步类少用wait和notify</li>
<li>多用并发集合少用同步集合</li>
</ol>
<h3 id="Java中fork-join框架是什么"><a href="#Java中fork-join框架是什么" class="headerlink" title="Java中fork join框架是什么"></a>Java中fork join框架是什么</h3><p>主要用于并行计算，将大任务拆分成多个小任务并行计算。ForkJoin由ForkJoinPool启动，是一个特殊的线程池，线程数量取决于CPU核数。ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争</p>
<h3 id="什么是Java线程转储（Thread-Dump），如何得到"><a href="#什么是Java线程转储（Thread-Dump），如何得到" class="headerlink" title="什么是Java线程转储（Thread Dump），如何得到"></a>什么是Java线程转储（Thread Dump），如何得到</h3><p>线程转储是一个JVM活动线程的列表，对于分析系统瓶颈和死锁很有用。可以使用Profiler、Kill -3命令，jstack工具等。jstack工具容易使用且是JDK自带</p>
<h3 id="什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><a href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="什么是Java Timer类？如何创建一个有特定时间间隔的任务？"></a>什么是Java Timer类？如何创建一个有特定时间间隔的任务？</h3><p>java.util.Timer是一个工具类，可用于安排一个线程在未来的某个特定时间执行。Timer类可安排一次性任务或周期任务。<br>java.util.TimerTask是一个实现了Runnable接口的抽象类，需要去继承这个类来创建自己的定时任务并使用Timer去安排执行</p>
<h3 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h3><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段</p>
<h3 id="Java-Concurrent-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#Java-Concurrent-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="Java Concurrent API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？"></a>Java Concurrent API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock接口比同步方法和同步块提供了更具可扩展性的锁操作。允许更灵活的结果，可以具有完全不同的性质，可以支持多个相关类的条件对象<br>优势有：</p>
<ol>
<li>可以使锁更公平</li>
<li>可以使线程在等待锁的时候响应中断</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或等待一段时间</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁</li>
</ol>
<h3 id="什么是Executor框架"><a href="#什么是Executor框架" class="headerlink" title="什么是Executor框架"></a>什么是Executor框架</h3><p>由java.util.concurrent.Executor接口在Java5被引入，是个根据一组执行策略调用、调度、执行和控制的异步任务的框架。<br>无限制地创建线程会引起应用程序内存溢出，所以创建线程池是一个更好的解决方案，可以限制线程的数量并回收再利用。</p>
<h3 id="Executors类是什么"><a href="#Executors类是什么" class="headerlink" title="Executors类是什么"></a>Executors类是什么</h3><p>Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法，可用于方便的创建线程池</p>
<h3 id="什么是阻塞队列？如何使用阻塞队列实现生产者-消费者模型"><a href="#什么是阻塞队列？如何使用阻塞队列实现生产者-消费者模型" class="headerlink" title="什么是阻塞队列？如何使用阻塞队列实现生产者-消费者模型"></a>什么是阻塞队列？如何使用阻塞队列实现生产者-消费者模型</h3><p>juc.BlockingQueue特性是：当队列为空，从队列获取或删除元素的操作会被阻塞，队列满时，向队列里添加元素的操作会被阻塞。阻塞队列不接受空值，是线程安全的，所有查询方法是原子性的并使用内部锁或其他形式的并发控制</p>
<h3 id="什么是Callable和Future"><a href="#什么是Callable和Future" class="headerlink" title="什么是Callable和Future"></a>什么是Callable和Future</h3><p>juc.Callable，和Runnable接口很相似，但可以返回一个对象或者抛出一个异常。Callable接口使用泛型定义返回类型。Executors类提供了方法在线程池中执行Callable内的任务，并由于是并发的，需要等待返回结果。在线程池提交Callable任务后返回Future对象，可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get方法是我们可以等待Callable结束并获取执行结果</p>
<h3 id="什么是FutureTask-1"><a href="#什么是FutureTask-1" class="headerlink" title="什么是FutureTask"></a>什么是FutureTask</h3><p>FutureTask包装器实现了Future和Runnable接口，可通过Executor执行，也可以传递给Thread对象执行。如果在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态</p>
<h3 id="什么是并发容器的实现"><a href="#什么是并发容器的实现" class="headerlink" title="什么是并发容器的实现"></a>什么是并发容器的实现</h3><p>Java集合类都是快速失败的，当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next方法抛出ConcurrentModificationException异常<br>并发容器：针对多个线程并发访问设计的，如juc下的ConcurrentHashMap，CopyOnWriteArrayList。例如ConcurrentHashMap采用了分段锁机制，加锁粒度更细，允许任意数量的读线程并发访问map。</p>
<h3 id="用户线程和守护线程的区别"><a href="#用户线程和守护线程的区别" class="headerlink" title="用户线程和守护线程的区别"></a>用户线程和守护线程的区别</h3><p>在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程</p>
<h3 id="为什么Thread类的sleep和yield方法是静态的"><a href="#为什么Thread类的sleep和yield方法是静态的" class="headerlink" title="为什么Thread类的sleep和yield方法是静态的"></a>为什么Thread类的sleep和yield方法是静态的</h3><p>sleep和yield方法均是在当前正在执行的线程上运行，在其他处于等待状态的线程上调用没有意义。声明为静态方法可以在当前执行的线程中调用</p>
<h3 id="如何确保线程安全"><a href="#如何确保线程安全" class="headerlink" title="如何确保线程安全"></a>如何确保线程安全</h3><p>同步、使用原子类、实现并发锁、使用volatile关键字、使用final对象和线程安全类</p>
<h3 id="同步方法和同步块，哪个更好"><a href="#同步方法和同步块，哪个更好" class="headerlink" title="同步方法和同步块，哪个更好"></a>同步方法和同步块，哪个更好</h3><p>同步块更好，因为锁住的范围更小，并发程度更高</p>
<h3 id="如何创建守护线程"><a href="#如何创建守护线程" class="headerlink" title="如何创建守护线程"></a>如何创建守护线程</h3><p>使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常</p>
<h3 id="在线程中怎么处理不可捕获异常"><a href="#在线程中怎么处理不可捕获异常" class="headerlink" title="在线程中怎么处理不可捕获异常"></a>在线程中怎么处理不可捕获异常</h3><p>Thread.UncaughtExceptionHandler，允许在每个Thread对象上添加一个异常处理器</p>
<h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理，将真实对象传递给代理对象，由代理对象执行对应方法，可以使真实对象专注自己的事情，同时代理对象可以在方法前后加入pre和post函数做处理</span></span><br><span class="line"><span class="comment">// 经典样例为Thread和Runnable</span></span><br><span class="line"><span class="type">Thread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();	<span class="comment">// 实现了Runnable接口，重写了run方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(thread1).start();		<span class="comment">// 将Runnable接口对象传入给Thread对象作为代理的目标</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名表达式</span></span><br><span class="line"><span class="comment">// 可以替代函数式接口、局部内部类、静态内部类、匿名内部类</span></span><br><span class="line"><span class="comment">// 在作为构造函数输入时，只能实现函数式接口（只有一个函数的接口）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ILike</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以省略参数类型，也可以带上（清晰）</span></span><br><span class="line"><span class="type">ILike</span> <span class="variable">like</span> <span class="operator">=</span> (a) -&gt; &#123;</span><br><span class="line">    Sout(<span class="string">&quot;lambda&quot;</span> + a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 简化，前提是只能有一行，但()可以去掉</span></span><br><span class="line"><span class="type">ILike</span> <span class="variable">like</span> <span class="operator">=</span> a -&gt; Sout(<span class="string">&quot;lambda&quot;</span> + a);</span><br><span class="line">like.lambda(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐的线程停止方法</span></span><br><span class="line"><span class="comment">// 1. 建议线程正常停止，不建议死循环</span></span><br><span class="line"><span class="comment">// 2. 建议使用标志位，外部修改</span></span><br><span class="line"><span class="comment">// 3. 不要使用stop或destory等过时方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join()方法</span></span><br><span class="line">thread.join()		<span class="comment">// 让当前线程等待，直到thread执行完成</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.State是一个Enum结构，定义了线程生命历程中的各种状态</span></span><br><span class="line"><span class="comment">// 优先级，Thread.getPriority()和getPriority() 设置优先级，1-10，默认为5</span></span><br><span class="line"><span class="comment">// thread.setDaemon(true)设置守护线程</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized方法控制对对象的访问，每个对象对应一把锁，每个synchronized方法必须获得调用该方法的对象的锁才能执行，否则阻塞。synchronized默认锁的是this，最好传入一个公共资源作为锁的监视对象（一般是要进行CRUD的对象）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池</span></span><br><span class="line"><span class="comment">// ExecutorService，线程池接口</span></span><br><span class="line"><span class="comment">// void execute(Runnable cmd)：执行任务，没有返回值。用来执行Runnable</span></span><br><span class="line"><span class="comment">// &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，用来执行Callable。Callable需要有返回值，通常为Callable&lt;T&gt;</span></span><br><span class="line"><span class="comment">// void shutdown()：关闭连接池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors：工具类、线程池的工厂类，创建并返回不同类型的线程池</span></span><br></pre></td></tr></table></figure>

<h3 id="注解和反射"><a href="#注解和反射" class="headerlink" title="注解和反射"></a>注解和反射</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/interview/" rel="tag"># 面经</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/21/Java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" rel="prev" title="Java基础总结">
      <i class="fa fa-chevron-left"></i> Java基础总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/21/Nginx%E6%80%BB%E7%BB%93/" rel="next" title="Nginx总结">
      Nginx总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.1.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">如何在Java中实现线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.3.</span> <span class="nav-text">线程生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">终止线程方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep%E5%92%8Cwait%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">sleep和wait区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8Ruanable%E8%BF%98%E6%98%AFThread"><span class="nav-number">1.6.</span> <span class="nav-text">用Ruanable还是Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#start-%E5%92%8Crun-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.</span> <span class="nav-text">start()和run()有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable%E5%92%8CCallable%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">1.8.</span> <span class="nav-text">Runnable和Callable有什么不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.9.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.10.</span> <span class="nav-text">锁总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">1.11.</span> <span class="nav-text">synchronized同步锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">1.12.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.13.</span> <span class="nav-text">Semaphore信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic%E7%B1%BB"><span class="nav-number">1.14.</span> <span class="nav-text">Atomic类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.15.</span> <span class="nav-text">ReadWriteLock读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="nav-number">1.16.</span> <span class="nav-text">共享锁和独占锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">1.17.</span> <span class="nav-text">锁的四种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E9%94%81"><span class="nav-number">1.18.</span> <span class="nav-text">分段锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">1.19.</span> <span class="nav-text">锁优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.20.</span> <span class="nav-text">线程方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">1.21.</span> <span class="nav-text">线程上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch%E5%92%8CCyclicBarrier"><span class="nav-number">1.22.</span> <span class="nav-text">CountDownLatch和CyclicBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8"><span class="nav-number">1.23.</span> <span class="nav-text">volatile关键字作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.24.</span> <span class="nav-text">线程之间共享数据的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E4%BD%9C%E7%94%A8"><span class="nav-number">1.25.</span> <span class="nav-text">ThreadLocal作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.26.</span> <span class="nav-text">ThreadLocal内存泄漏原因及解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock%E5%92%8Csynchronized%E6%AF%94%E8%BE%83"><span class="nav-number">1.27.</span> <span class="nav-text">ReentrantLock和synchronized比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap%E5%B9%B6%E5%8F%91"><span class="nav-number">1.28.</span> <span class="nav-text">ConcurrentHashMap并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS%E6%93%8D%E4%BD%9C%E5%8F%8A%E9%97%AE%E9%A2%98"><span class="nav-number">1.29.</span> <span class="nav-text">CAS操作及问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%88%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%89"><span class="nav-number">1.30.</span> <span class="nav-text">什么是AQS（抽象队列同步器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%ADnotify%E5%92%8CnotifyAll%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.31.</span> <span class="nav-text">Java中notify和notifyAll有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88wait%EF%BC%8Cnotify%E5%92%8CnotifyAll%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8D%E5%9C%A8Thread%E7%B1%BB%E9%87%8C"><span class="nav-number">1.32.</span> <span class="nav-text">为什么wait，notify和notifyAll这些方法不在Thread类里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFFutureTask"><span class="nav-number">1.33.</span> <span class="nav-text">什么是FutureTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interrupted%E5%92%8CisInterrupted%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.34.</span> <span class="nav-text">interrupted和isInterrupted方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="nav-number">1.35.</span> <span class="nav-text">JMM（Java内存模型）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-number">1.35.0.1.</span> <span class="nav-text">内存间交互操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.35.0.2.</span> <span class="nav-text">内存模型三大特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">1.36.</span> <span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">1.36.0.1.</span> <span class="nav-text">Java中的阻塞队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="nav-number">1.37.</span> <span class="nav-text">线程运行时发生异常会怎样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8"><span class="nav-number">1.38.</span> <span class="nav-text">为什么wait和notify方法要在同步块中调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%A3%80%E6%9F%A5%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.39.</span> <span class="nav-text">为什么在循环中检查等待条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%9B%86%E5%90%88%E5%92%8C%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.40.</span> <span class="nav-text">同步集合和并发集合有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">1.41.</span> <span class="nav-text">Java中堆和栈的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.42.</span> <span class="nav-text">写代码实现生产者-消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.43.</span> <span class="nav-text">活锁和死锁的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%8B%A5%E6%9C%89%E9%94%81"><span class="nav-number">1.44.</span> <span class="nav-text">怎么检测一个线程是否拥有锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E4%B8%AD%E5%93%AA%E4%B8%AA%E5%8F%82%E6%95%B0%E7%94%A8%E6%9D%A5%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A0%86%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.45.</span> <span class="nav-text">JVM中哪个参数用来控制线程的堆栈大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8BT1-T2-T3%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">1.46.</span> <span class="nav-text">三个线程T1,T2,T3怎么确保按顺序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%B1%BB%E4%B8%AD%E7%9A%84yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">1.47.</span> <span class="nav-text">Thread类中的yield方法有什么用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%97%B6%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">1.48.</span> <span class="nav-text">如果你提交任务时，线程池队列已满，会发生什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsubmit%E5%92%8Cexecute%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.49.</span> <span class="nav-text">线程池中submit和execute方法有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E5%BC%8F%E6%96%B9%E6%B3%95"><span class="nav-number">1.50.</span> <span class="nav-text">什么是阻塞式方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.51.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87"><span class="nav-number">1.52.</span> <span class="nav-text">线程调度器和时间分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E5%88%9B%E5%BB%BAImmutable%EF%BC%88%E4%B8%8D%E5%8F%98%E7%9A%84%EF%BC%89%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.53.</span> <span class="nav-text">如何在Java中创建Immutable（不变的）对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadWriteLock%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.54.</span> <span class="nav-text">ReadWriteLock是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%99%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.55.</span> <span class="nav-text">忙循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%92%8Catomic%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">1.56.</span> <span class="nav-text">volatile和atomic变量的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%9D%97%E5%86%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">1.57.</span> <span class="nav-text">同步块内的线程抛出异常会发生什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E6%A3%80%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.58.</span> <span class="nav-text">单例模式的双检锁是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84Singleton"><span class="nav-number">1.59.</span> <span class="nav-text">如何在Java中创建线程安全的Singleton</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E6%9D%A1%E4%BD%A0%E9%81%B5%E5%BE%AA%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.60.</span> <span class="nav-text">3条你遵循的多线程最佳实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%ADfork-join%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.61.</span> <span class="nav-text">Java中fork join框架是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJava%E7%BA%BF%E7%A8%8B%E8%BD%AC%E5%82%A8%EF%BC%88Thread-Dump%EF%BC%89%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0"><span class="nav-number">1.62.</span> <span class="nav-text">什么是Java线程转储（Thread Dump），如何得到</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJava-Timer%E7%B1%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%89%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="nav-number">1.63.</span> <span class="nav-text">什么是Java Timer类？如何创建一个有特定时间间隔的任务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">1.64.</span> <span class="nav-text">什么是原子操作？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Concurrent-API%E4%B8%AD%E7%9A%84Lock%E6%8E%A5%E5%8F%A3-Lock-interface-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AF%B9%E6%AF%94%E5%90%8C%E6%AD%A5%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="nav-number">1.65.</span> <span class="nav-text">Java Concurrent API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFExecutor%E6%A1%86%E6%9E%B6"><span class="nav-number">1.66.</span> <span class="nav-text">什么是Executor框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.67.</span> <span class="nav-text">Executors类是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.68.</span> <span class="nav-text">什么是阻塞队列？如何使用阻塞队列实现生产者-消费者模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCallable%E5%92%8CFuture"><span class="nav-number">1.69.</span> <span class="nav-text">什么是Callable和Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFFutureTask-1"><span class="nav-number">1.70.</span> <span class="nav-text">什么是FutureTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.71.</span> <span class="nav-text">什么是并发容器的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.72.</span> <span class="nav-text">用户线程和守护线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Thread%E7%B1%BB%E7%9A%84sleep%E5%92%8Cyield%E6%96%B9%E6%B3%95%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84"><span class="nav-number">1.73.</span> <span class="nav-text">为什么Thread类的sleep和yield方法是静态的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.74.</span> <span class="nav-text">如何确保线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%8C%E5%93%AA%E4%B8%AA%E6%9B%B4%E5%A5%BD"><span class="nav-number">1.75.</span> <span class="nav-text">同步方法和同步块，哪个更好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.76.</span> <span class="nav-text">如何创建守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E4%B8%8D%E5%8F%AF%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-number">1.77.</span> <span class="nav-text">在线程中怎么处理不可捕获异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.78.</span> <span class="nav-text">多线程实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="nav-number">1.79.</span> <span class="nav-text">注解和反射</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiahang Gu</p>
  <div class="site-description" itemprop="description">认真学习，享受生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JiahangGu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiahangGu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/fengzhizi76506" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;fengzhizi76506" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiahang Gu</span>

</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
