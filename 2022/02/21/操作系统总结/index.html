<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文是根据Cyc2018总结的基础知识整理而来，在基础知识的基础上更多偏向实际面试问题，以及一些深入的问题思考 操作系统操作系统特性 并发：同一段时间内多个程序执行 共享：系统中的资源可以被内存中多个并发执行的进线程共同使用 虚拟：通过时分复用以及空分复用，一个物理实体虚拟为多个 异步：进程以一种不可预知的速度推进  大端、小端存储">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统总结">
<meta property="og:url" content="http://example.com/2022/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="菜汤里的咸鱼要翻身">
<meta property="og:description" content="本文是根据Cyc2018总结的基础知识整理而来，在基础知识的基础上更多偏向实际面试问题，以及一些深入的问题思考 操作系统操作系统特性 并发：同一段时间内多个程序执行 共享：系统中的资源可以被内存中多个并发执行的进线程共同使用 虚拟：通过时分复用以及空分复用，一个物理实体虚拟为多个 异步：进程以一种不可预知的速度推进  大端、小端存储">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-21T04:10:16.000Z">
<meta property="article:modified_time" content="2022-02-21T04:11:15.766Z">
<meta property="article:author" content="Jiahang Gu">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统总结 | 菜汤里的咸鱼要翻身</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">菜汤里的咸鱼要翻身</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:10:16 / 修改时间：12:11:15" itemprop="dateCreated datePublished" datetime="2022-02-21T12:10:16+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文是根据<a target="_blank" rel="noopener" href="https://github.com/liguigui/CyC2018-CS-Notes">Cyc2018</a>总结的基础知识整理而来，在基础知识的基础上更多偏向实际面试问题，以及一些深入的问题思考</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h3 id="操作系统特性"><a href="#操作系统特性" class="headerlink" title="操作系统特性"></a>操作系统特性</h3><ol>
<li>并发：同一段时间内多个程序执行</li>
<li>共享：系统中的资源可以被内存中多个并发执行的进线程共同使用</li>
<li>虚拟：通过时分复用以及空分复用，一个物理实体虚拟为多个</li>
<li>异步：进程以一种不可预知的速度推进</li>
</ol>
<h5 id="大端、小端存储"><a href="#大端、小端存储" class="headerlink" title="大端、小端存储"></a>大端、小端存储</h5><p>大端：数据的高字节，保存在内存的低地址中<br>小端：数据的高字节，保存在内存的高地址中</p>
<h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><p>如果一个进程在用户态需要使用内核态的功能，进行系统调用从而陷入内核，由操作系统代为完成。<br>Linux主要的系统调用主要有：</p>
<ol>
<li>进程控制：fork(); exit(); wait();</li>
<li>进程通信：pipe(); shmget(); mmap();</li>
<li>文件操作：open(); read(); write();</li>
<li>设备操作：loctl(); read(); write();</li>
<li>信息维护：getpid(); alarm(); sleep();</li>
<li>安全：chmod(); umask(); chown();</li>
</ol>
<h5 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h5><p>系统调用：程序向系统内核请求服务的方式，可以包括硬件相关的服务，创建新进程，调度其他进程等<br>库函数：将常用的函数编写完放到一个文件里，编写应用程序时调用，由第三方提供，发生在用户地址空间<br>移植性方面，系统调用较差，因为操作系统差异很大，但库函数只要编译器版本相同就相同<br>调用开销方面，系统调用需要在用户态和内核态切换，开销大，而库函数属于过程调用，开销小</p>
<h5 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h5><p>运行在用户态的程序，只能受限地访问内存，不允许访问外围设备。占用CPU的能力被剥夺<br>内核态程序可以访问内存所有数据，包括外围设备<br>用户态切换到内核态的方式</p>
<ol>
<li>系统调用</li>
<li>触发异常</li>
<li>外围设备终端</li>
</ol>
<h5 id="操作系统的存储部分"><a href="#操作系统的存储部分" class="headerlink" title="操作系统的存储部分"></a>操作系统的存储部分</h5><p>硬盘、内存、CPU缓存和寄存器，且从左到右速度加快</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程是资源分配的基本单位，由进程控制块描述进程的基本信息和运行状态。</p>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是独立调度的基本单位。一个进程可以有多个线程，共享进程的资源</p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ol>
<li>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属于进程的资源</li>
<li>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</li>
<li>系统开销：进程切换时涉及当前执行进程CPU环境的保存和新调度进程CPU环境的设置，而切换线程只需保存和设置少量寄存器内容，开销小</li>
<li>通信：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC</li>
</ol>
<h5 id="为什么现在程序朝着多线程方向发展"><a href="#为什么现在程序朝着多线程方向发展" class="headerlink" title="为什么现在程序朝着多线程方向发展"></a>为什么现在程序朝着多线程方向发展</h5><ol>
<li>线程与进程相比，花销小，切换快。同一进程下的多线程，使用相同的地址空间，共享大部分数据。而一个新的进程必须分配独立的地址空间，建立数据表维护代码段、堆栈段和数据段</li>
<li>线程具有更方便的通信机制。不同进程具有独立的地址空间，数据传递只能通过通信的方式，费时且不方便。而线程之间共享数据空间，可以访问其他线程的数据。</li>
<li>提高应用程序响应速度。可以在进行某个耗时操作时不耽误其余响应</li>
<li>使多CPU系统更有效。</li>
<li>改善程序结果。将功能复杂的进程分为多个线程，将功能解耦，利于理解和维护</li>
</ol>
<h5 id="线程切换开销在哪些方面（从CPU的层面上"><a href="#线程切换开销在哪些方面（从CPU的层面上" class="headerlink" title="线程切换开销在哪些方面（从CPU的层面上)"></a>线程切换开销在哪些方面（从CPU的层面上)</h5><p>CPU从一个线程切换到另一个线程时，需保存当前线程的CPU寄存器和程序计数器状态，然后加载下一个等待执行的线程的数据和程序指针到CPU寄存器和程序计数器，并跳转到程序计数器所指的新位置，运行新任务。<br>进程切换还需要切换虚拟地址空间</p>
<h5 id="fork和exec的区别"><a href="#fork和exec的区别" class="headerlink" title="fork和exec的区别"></a>fork和exec的区别</h5><p>fork：调用fork函数后，子进程与父进程使用同一代码段，复制一份新的数据段和堆栈段给子进程。并且会生成新的进程号<br>exec：一个进程调用exec，系统把代码段替换为新的程序的代码段，废弃原有的数据段和堆栈段，为新程序分配新的。唯一留下的就是进程号，通过参数可以继承环境变量等信息</p>
<h5 id="父进程和子进程哪些是共享的"><a href="#父进程和子进程哪些是共享的" class="headerlink" title="父进程和子进程哪些是共享的"></a>父进程和子进程哪些是共享的</h5><p>fork后父子进程只共享代码段，数据段和堆栈段都是父进程的一个副本，并不共享地址空间。子进程开始运行后，和父进程不会共享数据。如果需要共享，则需要进程通信</p>
<h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><h5 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h5><p>调度算法目标是保证吞吐量和周转时间</p>
<ol>
<li>先来先服务（FCFS）：非抢占式，按照请求的顺序进行调度，有利于长作业，不利于短作业</li>
<li>短作业优先（SJF）：非抢占式，按估计运行时间最短的顺序进行调度，但长作业可能饿死</li>
<li>最短剩余时间优先（SRTN）：最短作业优先抢占</li>
</ol>
<h5 id="交互系统"><a href="#交互系统" class="headerlink" title="交互系统"></a>交互系统</h5><p>目标是快速进行响应</p>
<ol>
<li>时间片轮转：每个进程执行一个时间片，用完时停止进程并放入队列尾，继续分给队列首进程。如果时间片太小则切换太频繁，时间片长则无法保证实时性</li>
<li>优先级调度：每个进程一个优先级，高优先级先调度</li>
<li>多级反馈队列：结合时间片轮转和优先级调度，使用多级队列，如果当前进程执行完时间片后未完成，则放入下一个时间片翻倍的队列。最小时间片队列优先权最高，且只有上一个队列没有进程排队，才能调度当前队列的进程</li>
</ol>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><ol>
<li>就绪：等待被调度</li>
<li>运行：占用资源运行</li>
<li>阻塞：等待资源</li>
<li>终止</li>
</ol>
<h4 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h4><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>一个父进程退出，而他的子进程还在运行，则这些子进程变为孤儿进程，会被init进程（pid=1）所收养，并由init进程完成状态收集工作，不会对系统造成危害</p>
<h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>一个子进程的进程描述符在子进程退出时不会释放，只有父进程通过wait()或waitpid()获取子进程信息才会释放。如果子进程退出而父进程没有调用wait，子进程的进程描述符仍在系统中，这种进程是僵尸进程。<br>ps显示出来状态为Z。<br>系统能使用的进程号有限，如果有大量僵尸进程，将因为没有可用进程号导致系统不能产生新进程。<br>要消失系统中的僵尸进程，只需要杀死父进程，则僵尸进程变为孤儿进程，由init收养。</p>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><h5 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h5><p>同一时间只能被一个进程所占用的资源，比如打印机。<br>对临界资源进行访问的代码称为临界区。临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到该资源被释放。</p>
<h5 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h5><p>同步：多个进程因为合作产生的直接制约关系，使进程有一定的先后执行关系<br>互斥：多个进程同一时刻只有一个进程能进入临界区</p>
<h5 id="同步的方式"><a href="#同步的方式" class="headerlink" title="同步的方式"></a>同步的方式</h5><p>互斥量、条件变量、信号量</p>
<h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><h5 id="生产者于消费者问题"><a href="#生产者于消费者问题" class="headerlink" title="生产者于消费者问题"></a>生产者于消费者问题</h5><p>一组生产者和消费者共享一块缓冲区，只有缓冲区不满时，生产者进程可以将消息放入缓冲区，只有缓冲区不为空时，消费者才能从中取出消息。缓冲区是临界资源。</p>
<h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5><p>允许多个进程同时对数据进行读操作，但不允许读写以及写写同时发生</p>
<h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><p>哲学家围着一张圆桌，前面放着食物。每个哲学家生活只有思考和吃饭。当吃饭时需要先拿起左右两边的两根筷子，且一次只能拿起一根。</p>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p>目的是在进程间传输信息，从而达到进程同步。<br>方式有</p>
<ol>
<li>管道：pipe()创建，fd[0]读，fd[1]写。只支持半双工通信，只能在父子进程或兄弟进程间使用</li>
<li>FIFO命名管道：去除了管道只能在父子进程中使用的限制</li>
<li>消息队列：相比于FIFO，具有以下优点：1）消息队列可以独立于读写进程存在，避免了FIFO中同步管道的打开和关闭时可能产生的困难；2）避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法；3）读进程可以根据消息类型有选择地接收，而不像FIFO默认接收</li>
<li>信号量：一个计数器，为多个进程提供对共享数据对象地访问</li>
<li>共享存储：允许多个进程共享一个给定的存储区，因为数据不需要复制所以最快。需要使用信号量控制同步。多个进程可以将同一个文件映射到各自的地址空间实现共享内存。</li>
<li>套接字：可用于不同机器间进程通信</li>
</ol>
<h5 id="最快的进程通信方式"><a href="#最快的进程通信方式" class="headerlink" title="最快的进程通信方式"></a>最快的进程通信方式</h5><p>共享内存。映射一段能被其他进程访问的内存，这段共享内存由一个进程创建，但多个进程可以访问。通过其他通信机制如信号量配合使用，实现进程间同步和通信</p>
<h4 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h4><h5 id="多线程共享的数据类型"><a href="#多线程共享的数据类型" class="headerlink" title="多线程共享的数据类型"></a>多线程共享的数据类型</h5><ol>
<li>进程代码段</li>
<li>进程的共有数据</li>
<li>进程打开的文件描述符</li>
<li>信号的处理器</li>
<li>进程的当前目录</li>
<li>进程用户ID与进程组ID</li>
</ol>
<h5 id="多线程同步的方式"><a href="#多线程同步的方式" class="headerlink" title="多线程同步的方式"></a>多线程同步的方式</h5><ol>
<li>信号量</li>
<li>互斥量</li>
<li>信号，或者事件</li>
</ol>
<h5 id="线程同步的锁类型"><a href="#线程同步的锁类型" class="headerlink" title="线程同步的锁类型"></a>线程同步的锁类型</h5><ol>
<li>互斥锁</li>
<li>自旋锁</li>
<li>信号量</li>
<li>读写锁</li>
<li>递归锁</li>
</ol>
<h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><p>单核单线程CPU某一时刻只能执行一条CPU指令。上下文切换时一种将CPU资源从进程分配给另一个进程的机制。用户角度看，计算机能并行运行多个进程。切换过程中，操作系统先存储当前进程的状态（包括内存空间的指针，当前执行完的指令等），再读入下一个进程的状态，然后执行</p>
<h5 id="中断和轮询"><a href="#中断和轮询" class="headerlink" title="中断和轮询"></a>中断和轮询</h5><p>中断：计算机执行期间，系统内发生任何非寻常或非预期的继续处理的事件，使得CPU中断当前执行的程序，转去执行事件。处理完毕后，CPU返回原来被中断的地方，继续执行或调度新的进程。容易遗漏一些问题，CPU利用率高<br>轮询：系统定时对各种设备轮流询问一遍是否有处理要求。有要求则处理。占用CPU时间较多，效率较低，等待时间长</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h5 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h5><ol>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，只能被占用它地进程显式释放</li>
<li>环路等待：有两个及以上地进程组成一条环路，环路中每个进程在等待下一个进程占有的资源</li>
</ol>
<h5 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h5><ol>
<li>鸵鸟策略：忽略问题。在大多数操作系统上使用（当死锁影响小或发生概率小）</li>
<li>死锁检测与死锁恢复：不阻止死锁，而是检测到发生时，采取措施恢复</li>
<li>死锁预防：在程序运行之前预防发生死锁，方法有：1）破坏互斥条件；2）破坏占有和等待条件；3）破坏不可抢占条件；4）破坏环路等待。</li>
<li>死锁避免：在程序运行时避免发生死锁</li>
</ol>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h5><p>目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多可用内存。将内存抽象成地址空间，每个程序拥有自己的地址空间称为页，当程序引用不在物理内存中的页时，由硬件执行映射，将缺失部分放入物理内存并重新执行失败指令。</p>
<p>优点：</p>
<ol>
<li>在内存中可以保留多个进程，提高系统并发度</li>
<li>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</li>
</ol>
<p>访问虚拟内存时，先访问MMU，去匹配对应的物理地址。如果内存已满，调用页面置换算法进行换页</p>
<h5 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h5><p>虚拟地址分为页面号和偏移量。通过页面号索引到实际地址，并拼接偏移量作为最终地址</p>
<h5 id="页置换算法"><a href="#页置换算法" class="headerlink" title="页置换算法"></a>页置换算法</h5><ol>
<li>最佳算法（OPT）：被换出的页面最长时间内不再被访问，可以保证最低的缺页率。但由于页面多久不访问未知，只是理论算法</li>
<li>最近最久未使用（LRU）：将最近最久未使用的页换出。</li>
<li>最近未使用（NRU）：每个页面2个状态为R、M，被访问时设置R=1，被修改时M=1，R会定时清零。缺页中断时，随机从类编号最小的非空类中挑选一个并替换。</li>
<li>先进先出（FIFO）：替换的页面是最先进入的</li>
<li>第二次机会算法：当页面被访问时设置R=1，需要替换时，搜索最老的页面，如果R=0则替换，R=1则置为0，并放入链表尾当作最近访问的页面</li>
<li>时钟：使用环形链表将页面连接起来，使用一个指针指向最老的页面</li>
</ol>
<h5 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h5><p>虚拟内存采用分页技术，而分段把每个表分成段，一个段是一个独立的地址空间，并且可以动态增长</p>
<h5 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h5><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。既有分段系统的共享和保护，又有分页系统的虚拟内存功能</p>
<h5 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h5><ol>
<li>对程序员的透明性：分页透明，但分段需要程序员显式划分每个段</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ol>
<p>段式存储管理是一种符合用户视角的内存分配管理方案，在段式存储中，将地址空间划分为若干段，如代码段、数据段、堆栈段。每个进程有一个二维地址空间，相互独立，互不打扰。优点是没有内碎片，可以通过改变段大小消除碎片。但是会产生外碎片，例如4K的段换5K的段，会产生1K的外碎片<br>页式存储管理是一种用户视角内存与物理内存分离的内存分配管理方案。在页式管理中，程序的逻辑地址划分为固定大小的页，而物理内存划分为同样大小的帧。程序加载时，可将任意一页放入内存中任意一个帧，帧不必连续，实现了离散分离。优点是没有外碎片，因为页大小固定，但会产生内碎片，因为一个页可能填充不满</p>
<p>不同点：</p>
<ol>
<li>目的不同：分页是系统管理的需要，是信息的物理单位。分段是用户的需要，是信息的逻辑单位</li>
<li>大小不同：页大小固定。段大小不固定</li>
<li>地址空间不同：页向用户提供一维地址空间，段提供二维地址空间</li>
<li>信息共享：页的保护和共享受到限制，段利于存储保护和信息共享</li>
<li>内存碎片：分页没有外碎片，但有内碎片；分段没有内碎片，但有外碎片</li>
</ol>
<h5 id="分页是一维的而分段是二维的原因"><a href="#分页是一维的而分段是二维的原因" class="headerlink" title="分页是一维的而分段是二维的原因"></a>分页是一维的而分段是二维的原因</h5><p>页式存储是一维的，因为各个模块在链接时必须组织在同一地址空间；而分段式二维的，各个模块在链接时可以把每个段组织成一个地址空间。也就是说，在编程的时候，如果是分页存储，你只需要给定一个虚拟地址，然后操作系统会自己去把虚拟地址划分成虚页号和页内偏移，所以是一维的。而如果是段式存储的话，你需要给定的虚拟地址必须包括虚段号和段内偏移量，因为分段式从程序员的角度来分的，操作系统并不知道，所以段式存储是二维的。</p>
<h5 id="内存连续分配"><a href="#内存连续分配" class="headerlink" title="内存连续分配"></a>内存连续分配</h5><ol>
<li>首次适应算法：空闲分区以地址递增次序链接，分配内存时顺序查找，找到大小满足的第一个空闲分区</li>
<li>最佳适应算法：空闲分区按容量递增的次序链接，找到第一个能满足要求的空闲分区</li>
<li>最坏适应算法：空闲分区以容量递减的次序链接，找到第一个满足要求的空闲分区，即最大分区</li>
</ol>
<h5 id="缓存和缓冲"><a href="#缓存和缓冲" class="headerlink" title="缓存和缓冲"></a>缓存和缓冲</h5><p>缓存是数据流向从低速到高速，例如内存到CPU有高速缓存，磁盘到内存有缓存，防止速度快的一方等待，OS会从低速一方预读一部分数据。要求缓存的速度与告诉的接近<br>缓冲是数据流向从高速到低速，防止低速一方处理不过来造成数据丢失</p>
<h5 id="上下文切换-1"><a href="#上下文切换-1" class="headerlink" title="上下文切换"></a>上下文切换</h5><p>单核单线程CPU某一时刻只能执行一条CPU指令。上下文切换时一种将CPU资源从进程分配给另一个进程的机制。用户角度看，计算机能并行运行多个进程。切换过程中，操作系统先存储当前进程的状态（包括内存空间的指针，当前执行完的指令等），再读入下一个进程的状态，然后执行</p>
<h5 id="为什么页大小是4KB，如果是24KB内存利用率怎么变化"><a href="#为什么页大小是4KB，如果是24KB内存利用率怎么变化" class="headerlink" title="为什么页大小是4KB，如果是24KB内存利用率怎么变化"></a>为什么页大小是4KB，如果是24KB内存利用率怎么变化</h5><p>这是遗留问题，之前默认采用4KB大小是因为内存小，如果过大会浪费内存空间，而现在内存快速增长，可以考虑使用更大的页表。<br>主要是以下影响：</p>
<ol>
<li>过小的页面大小会带来较大的页表项增加寻址时TLB的查找速度和额外开销（将等量内存分成更小的，则页表更多，分级越多）</li>
<li>过大的页面会浪费内存空间，造成内存碎片，降低内存利用率（比如换成24KB的话，如果只申请1字节大小则也需要使用一个页表，则剩余的绝大多数空间都浪费，产生内存碎片，降低内存利用率）</li>
<li>除了内存的利用率之外，较大的内存页也会增加内存拷贝时的额外开销，因为 Linux 上的写时拷贝机制，在多个进程共享同一块内存时，当其中的一个进程修改了共享的虚拟内存会触发内存页的拷贝，这时操作系统的内存页越小，写时拷贝带来的额外开销也就越小。</li>
</ol>
<p>24KB内存利用率降低，产生内存碎片更多</p>
<h5 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h5><p>是指计算机向缓冲区填充数据时，超出了缓冲区本身的容量，溢出的数据覆盖在了合法的数据上。<br>危害有：</p>
<ol>
<li>程序崩溃，导致拒绝服务</li>
<li>跳转并执行一段恶意代码</li>
</ol>
<p>产生的主要原因是程序中没有仔细检查用户输入</p>
<h5 id="堆栈区别"><a href="#堆栈区别" class="headerlink" title="堆栈区别"></a>堆栈区别</h5><p>程序的内存分配：</p>
<ol>
<li>堆：程序员分配释放，若不释放，程序结束时可能由OS回收</li>
<li>栈：编译器自动分配释放，存放函数的参数值、局部变量等</li>
</ol>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>读写磁盘块的影响因素有：</p>
<ol>
<li>旋转时间</li>
<li>寻道时间</li>
<li>实际的数据传输时间</li>
</ol>
<p>寻道时间最长，目标是使平均寻道时间最短</p>
<ol>
<li>先来先服务：按照磁盘请求的顺序进行调度。优点是公平和简单，缺点是未做优化，平均寻道时间可能较长</li>
<li>最短寻道时间优先：优先调度与当前磁头所在磁道距离最近的磁道，但两端的磁道请求可能出现饥饿现象</li>
<li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求，然后改变运行方向</li>
</ol>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h5 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h5><p>gcc -o hello hello.c的编译过程为<br>hello.c—&gt;预处理器（cpp）-&gt;hello.i—&gt;编译器（ccl）-&gt;hello.s—&gt;汇编器（as）-&gt;hello.o—&gt;链接器-&gt;hello（可执行目标程序）<br>预处理阶段：处理以#开头的预处理命令<br>编译阶段：翻译成汇编文件<br>汇编阶段：将汇编文件翻译成可重定位目标文件<br>链接阶段：将可重定位目标文件和单独编译好的目标文件合并，得到最终的可执行目标文件</p>
<h5 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h5><p>静态链接以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件，主要完成：</p>
<ol>
<li>符号解析：符号对应函数、全局变量或静态变量，目的是将每个符号引用和一个符号定义关联起来</li>
<li>重定位：连接器通过将符号定义与内存位置关联起来，并修改对这些符号的引用，使他们指向对应的内存位置</li>
</ol>
<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>静态库的问题：</p>
<ol>
<li>静态库更新时整个程序都要重新进行链接</li>
<li>printf标准函数库，每个程序都要有代码会极大浪费资源</li>
</ol>
<p>共享库在linux常用.so后缀，windows常用.dll后缀</p>
<ol>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件是共享这个文件，而不是复制到引用的可执行文件中</li>
<li>在内存中，一个共享库的.text节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享</li>
</ol>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h5 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h5><ol>
<li>man：将指令的具体信息显示出来</li>
<li>who：关机前查看有没有其他用户在线</li>
<li>sync：为了加快对磁盘文件的读写速度，关机前执行sync同步文件数据到磁盘上</li>
<li>shutdown：关机</li>
<li>sudo：允许一般用户执行root可执行的命令，用户需要配置在/ect/sudoers中</li>
<li>ls：列出文件或目录的信息</li>
<li>cd：更换目录</li>
<li>mkdir：创建目录</li>
<li>rmdir：删除目录，目录必须为空</li>
<li>touch：更新文件时间或建立新文件</li>
<li>cp：复制文件，如果源文件2个以上，则目的文件必须是目录</li>
<li>mv：移动文件</li>
<li>chmod：修改文件权限，chmod 754 a.log</li>
<li>ln：默认实体链接，-s为符号链接（软链接）</li>
<li>cat：打印文件内容</li>
<li>tac：cat反向操作，从最后一行开始打印</li>
<li>more：一页一页查看文件内容，可以翻页</li>
<li>less：类似more，可以向前翻页</li>
<li>head：读取文件前几行，-n指定</li>
<li>tail：读取文件后几行</li>
<li>which：指令搜索</li>
<li>whereis：文件搜索，但只搜几个特定目录</li>
<li>locate：文件搜索，可以使用关键字或者正则表达式</li>
<li>find：文件搜索，可以使用文件的属性和权限搜索，-name指定文件名，-mtime根据修改时间</li>
<li>cut：提取数据 -d 分隔符 -f 取出第n个区间 -c 以字符为单位取出区间</li>
<li>sort：对数据内容进行排序</li>
<li>uniq：将重复数据只取一个</li>
<li>tr：删除一行中的字符，或者对字符进行替换</li>
<li>expand：将tab转换成一定数量的空格，默认8个</li>
<li>join：将有相同数据的那一行合并在一起</li>
<li>paste：直接将两行粘贴在一起</li>
<li>split：将一个文件划分成多个文件</li>
<li>grep：使用正则表达式进行全局查找并打印</li>
<li>awk：每次处理一行，处理的最小单位是字段，awk ‘条件类型1 {动作1}…’ filename，根据字段的条件匹配并执行对应操作</li>
<li>ps：查看当前时间的进程信息</li>
<li>pstree：查看进程树</li>
<li>top：实时显示进程信息，一秒刷新一次</li>
<li>netstat：查看占用端口的进程，查看特定端口的进程可以netstat -anp | grep port</li>
</ol>
<h5 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h5><p>环境变量，声明可执行文件的路径，路径之间用:分隔</p>
<h5 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h5><p>RPM和DPKG，YUM基于RPM<br>RPM     Red Hat     CentOS<br>DPKG    Ubuntu      Debian</p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><h5 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h5><ol>
<li>MBR：第一个扇区有主要开机记录（MBR）和分区表</li>
<li>GPT：第一个区块记录主要开机记录，紧接着33个区块记录分区信息</li>
</ol>
<h5 id="开机检测程序"><a href="#开机检测程序" class="headerlink" title="开机检测程序"></a>开机检测程序</h5><ol>
<li>BIOS：存放在只读内存中，是开机时执行的第一个程序，知道开机的磁盘并读取磁盘第一个扇区的主要开机记录，由主要开机记录执行其中的开机管理程序，加载OS的核心文件。开机管理程序提供：选单、载入核心文件以及转交其他开机管理程序。<br>安装多重引导最好先装windows，因为安装windows会覆盖主要开机记录，而Linux可以选择将开机管理程序安装在MBR或其他分区的启动扇区，并且可以设置开机管理程序的选单。</li>
<li>UEFI：可以读取GPT分区表</li>
</ol>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ol>
<li>inode：一个文件占用一个inode，记录文件的属性，同时记录文件的内容所在的block编号</li>
<li>block：记录文件的内容，文件太大时，会占用多个block</li>
<li>superblock：记录文件系统的整体信息，包括inode和block的总量、使用量、剩余量以及文件系统的格式与相关信息等</li>
<li>block bitmap：记录block是否被使用的位图</li>
</ol>
<h5 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h5><p>Ext2系统，先在inode找出内容所在的所有block，把所有block的内容读出来<br>FAT文件系统，每个block中存储着下一个block的编号</p>
<h5 id="磁盘碎片"><a href="#磁盘碎片" class="headerlink" title="磁盘碎片"></a>磁盘碎片</h5><p>一个文件内容所在的block过于分散，导致磁盘磁头移动距离过大，降低磁盘读写性能</p>
<h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><p>建立目录时，分配一个inode与至少一个block。block记录目录下所有文件的inode编号以及文件名，因此新增、删除文件以及更改文件名需要有目录的写权限</p>
<h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>通过日志修复断电异常导致的文件系统错误</p>
<h5 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h5><p>会有9位表示文件拥有者、群组以及其他人对该文件的权限</p>
<h5 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h5><ol>
<li>文件默认权限：默认没有可执行权限，为666</li>
<li>目录默认权限：目录必须能进入，即要有可执行权限，默认777</li>
</ol>
<h5 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h5><ol>
<li>实体链接：创建一个条目，记录文件名和inode编号，即指向源文件的inode。但不能跨越文件系统、不能对目录进行链接</li>
<li>符号链接：保存源文件所在的绝对路径，源文件被删除时，链接文件就打不开。</li>
</ol>
<h3 id="Shell相关"><a href="#Shell相关" class="headerlink" title="Shell相关"></a>Shell相关</h3><h5 id="压缩文件名"><a href="#压缩文件名" class="headerlink" title="压缩文件名"></a>压缩文件名</h5><p>扩展名              压缩程序<br>*.Z                 compress<br>*.zip               zip<br>*.gz                gzip<br>*.bz2               bzip2<br>*.xz                xz<br>*.tar               tar程序打包的数据，没有经过压缩<br>*.tar.gz            tar程序打包的文件，经过gzip的压缩<br>*.tar.bz2           tar程序打包的文件，经过bzip2的压缩<br>*.tar.xz            tar程序打包的文件，经过xz的压缩</p>
<h5 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h5><p>gzip, bzip2, xz<br>tar可以将多个文件打包成一个大文件，也可使用压缩方式将打包文件进行压缩</p>
<h5 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h5><p>通过shell请求内核提供服务<br>变量操作：</p>
<ol>
<li>变量赋值使用=</li>
<li>变量取用在变量前加$，也可以用${}的形式</li>
<li>输出变量用echo</li>
<li>变量内有空格，使用双引号或单引号，双引号保留原本特性（即变量对应的值），单引号就是字符本身（自带转义）</li>
<li>可以使用`指令`或者$(指令)将执行结果赋值给变量</li>
<li>使用export可以将自定义变量转成环境变量，环境变量可以在子程序中使用</li>
<li>bash可以声明变量为数组和整数数字</li>
</ol>
<h5 id="指令搜索顺序"><a href="#指令搜索顺序" class="headerlink" title="指令搜索顺序"></a>指令搜索顺序</h5><ol>
<li>绝对或相对路径</li>
<li>别名</li>
<li>bash内置指令</li>
<li>$PATH变量指定的搜索路径</li>
</ol>
<h5 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h5><p>标准输入stdin           0           &lt;或&lt;&lt;<br>标准输出stdout          1           &gt;或&gt;&gt;<br>标准错误输出stderr      2           2&gt;或2&gt;&gt;<br>单箭头表示以覆盖的方式重定向，双箭头以追加方式重定向<br>2&gt;&amp;1表示将标准错误输出转换为标准输出</p>
<h5 id="管道指令"><a href="#管道指令" class="headerlink" title="管道指令"></a>管道指令</h5><p>将一个命令的标准输出作为另一个命令的标准输入，命令间使用 | 分隔各个管道命令</p>
<h3 id="资源监控命令"><a href="#资源监控命令" class="headerlink" title="资源监控命令"></a>资源监控命令</h3><h5 id="top命令详解"><a href="#top命令详解" class="headerlink" title="top命令详解"></a>top命令详解</h5><p>第一行</p>
<ol>
<li>load average: 1.14, 1.42, 1.44，分别表示1、5、15分钟的负载情况，负载指的是正在运行和排队的任务数除以逻辑cpu的数量</li>
</ol>
<p>第二行<br>Tasks：183 total, 1 running, 182 sleeping, 0 stopped, 0 zombie<br>系统共有183个进程，1个运行，182个休眠，0个stopped，0个僵尸状态</p>
<p>第三行<br>Cpus(s): 6.7% us, 0.4% sy, 0.0% ni, 92.9% id, 0.0% wa, 0.0% hi, 0.0% si</p>
<ol>
<li>us：用户空间占用cpu的百分比</li>
<li>sy：内核空间占用cpu的百分比</li>
<li>ni：改变过优先级的进程占用cpu百分比，nice操作</li>
<li>id：空闲cpu百分比</li>
<li>wa：io等待占用cpu的百分比</li>
<li>hi：硬中断占用cpu百分比</li>
<li>si：软中断占用cpu百分比</li>
</ol>
<p>第四行<br>Mem：8306544k total, 7775876k used, 530668k free, 79236k buffers</p>
<ol>
<li>total：物理内存总量，8G</li>
<li>used：使用中的内存总量，7.7G</li>
<li>free：空闲内存总量，530M</li>
<li>buffers：缓存的内存量，79M</li>
</ol>
<p>第五行<br>Swap：2031608k total, 2556k used, 2029052k free, 4231276k cached</p>
<ol>
<li>total：交换区总量，2G</li>
<li>used：使用的交换区总量，2.5M</li>
<li>free：空闲的交换区总量，2G</li>
<li>cached：缓冲的交换区总量，4G</li>
</ol>
<p>第六行<br>PID USER    PR  NI  VIRT    RES     SHR S   %CPU    %MEM    TIME+   COMMAND</p>
<ol>
<li>pid：进程id</li>
<li>user：进程所有者</li>
<li>pr：进程优先级</li>
<li>ni：nice值，负值表示高优先级</li>
<li>virt：进程使用的虚拟内存总量，单位kb，virt=swap+res</li>
<li>res：进程使用的未被换出的物理内存大小，单位kb，res=code+data</li>
<li>shr：共享内存大小，kb</li>
<li>S：进程状态</li>
<li>%CPU：上次更新到现在的CPU时间占用百分比</li>
<li>%MEM：进程使用的物理内存百分比</li>
<li>TIME+：进程使用的CPU时间总计，单位1/100秒</li>
<li>command：进程名称</li>
</ol>
<h5 id="free命令详解"><a href="#free命令详解" class="headerlink" title="free命令详解"></a>free命令详解</h5><p>free -h<br>        total       used        free        shared      buff/cache      available<br>Mem:    1.8G        760M        103M        9.8M        967M            857M<br>Swap:   4.0G        12K         4.0G<br>Mem行是内存的使用情况，Swap行是交换空间的使用情况</p>
<ol>
<li>total显示系统总的可用物理内存和交换空间的大小</li>
<li>used显示已经被使用的物理内存和交换空间</li>
<li>free显示还有多少物理内存和交换空间可以使用</li>
<li>shared显示被共享使用的物理内存大小</li>
<li>buff/cache显示被buffer和cache使用的物理内存大小</li>
<li>available显示还可以被应用程序使用的物理内存大小</li>
</ol>
<h5 id="vmstat命令详解"><a href="#vmstat命令详解" class="headerlink" title="vmstat命令详解"></a>vmstat命令详解</h5><p>vmstat 5 5（在5秒时间内进行5次采样）<br>procs ——memory————-   —swap–     –io—–     –system–    —–cpu———-<br>r  b  swpd   free   buff  cache    si    so      bi    bo      in     cs     us  sy  id  wa  st<br>1  0     0  756072  4484  221448    0     0      1      4      4      5      0   0   100  0   0<br>说明：</p>
<ol>
<li>r：表示运行队列，分配到CPU的进程数</li>
<li>b：阻塞的进程</li>
<li>swpd：虚拟内存已使用的大小，大于0表示机器物理内存不足</li>
<li>free：空闲的物理内存大小</li>
<li>buff：缓存大小，缓存存放的是数据块</li>
<li>cache：页高速缓存大小</li>
<li>si：每秒从磁盘读入虚拟内存的大小，如果值大于0，表示物理内存不够用或内存泄漏</li>
<li>so：每秒虚拟内存写入磁盘的大小，值大于0同上</li>
<li>bi：块设备每秒接收的块数量，块设备指系统上所有磁盘和其他块设备</li>
<li>bo：块设备每秒发送的块数量</li>
<li>in：每秒cpu中断次数</li>
<li>cs：每秒上下文切换次数，系统调用、进程切换</li>
<li>us：用户cpu时间</li>
<li>sy：系统cpu时间，太高表示系统调用时间长，例如io频繁</li>
<li>id：空闲cpu时间，一般id + us + sy = 100</li>
<li>wt：等待io的cpu时间</li>
</ol>
<h5 id="iostat命令详解"><a href="#iostat命令详解" class="headerlink" title="iostat命令详解"></a>iostat命令详解</h5><p>iostat<br>avg-cpu:        %user   %nice   %system     %iowait     %steal      %idle<br>                0.08    0.00    0.06        0.00        0.00        99.86</p>
<p>Device:         tps     Blk_read/s      Blk_wrtn/s      Blk_read        Blk_wrtn<br>vda             0.45    0.29            8.10            6634946         183036680</p>
<p>显示结果为系统开机到当前执行时刻的统计信息<br>avg-cpu：总体cpu使用情况统计信息，对于多核cpu，为所有cpu的平均值</p>
<ol>
<li>%user：cpu在用户态执行进程的时间百分比</li>
<li>%nice：改变过优先级的进程的cpu使用率</li>
<li>%system：cpu处在内核态执行进程的时间百分比</li>
<li>%iowait：cpu用于等待io操作占用cpu总时间百分比，过高，硬盘存在io瓶颈</li>
<li>%steal：管理程序为另一个虚拟程序提供服务而等待虚拟cpu的百分比</li>
<li>%idle：cpu空闲时间百分比，高但系统响应慢，可能是cpu等待分配内存，应加大内存容量，持续低于1则cpu处理能力较低，需要提高cpu资源</li>
</ol>
<p>Device：个磁盘设备的io统计信息</p>
<ol>
<li>Device：设备名称</li>
<li>tps：每秒向磁盘设备请求数据的次数，包括读写请求，每次io下发后不是立即处理请求，而是将请求合并，这里指合并后的请求计数</li>
<li>Blk_read/s：每秒从设备读取的数据量</li>
<li>Blk_wrtn/s：每秒写入设备的数据量</li>
<li>Blk_read：读取的总数据量</li>
<li>Blk_wrtn：写入的总数据量</li>
</ol>
<p>-k可以使kb为单位显示读写信息，-m以mb为单位</p>
<p>-x显示更详细的io统计信息，一般分析io瓶颈时会开启-x选项<br>linux # iostat -x -k -d 1<br>Linux 2.6.16.60-0.21-smp (linux)     06/13/12</p>
<p>……<br>Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util<br>sda               0.00  9915.00    1.00   90.00     4.00 34360.00   755.25    11.79  120.57   6.33  57.60</p>
<ol>
<li>rrqm/s：每秒对该设备的读请求被合并次数，文件系统对读取同块的请求进行合并</li>
<li>wrqm/s：每秒对该设备的写请求被合并次数</li>
<li>r/s：每秒完成的读次数</li>
<li>w/s：每秒完成的写次数</li>
<li>rkB/s：每秒读数据量，kb</li>
<li>wkB/s：每秒写数据量，kb</li>
<li>avgrq-sz：平均每秒io操作的数据量，扇区数为单位</li>
<li>avgqu-sz：平均等待处理的io请求队列长度</li>
<li>await：平均每次io请求等待时间，包括等待时间和处理时间，毫秒</li>
<li>svctm：平均每次io请求的处理时间</li>
<li>%util：采用周期内用于io操作的时间比率，即io队列非空的时间比率</li>
</ol>
<h5 id="sar命令详解（很全的命令）"><a href="#sar命令详解（很全的命令）" class="headerlink" title="sar命令详解（很全的命令）"></a>sar命令详解（很全的命令）</h5><p>sar -u， 查看cpu使用情况，类似于iostat中的cpu</p>
<ol>
<li>%user：cpu在用户态执行进程的时间百分比</li>
<li>%nice：改变过优先级的进程的cpu使用率</li>
<li>%system：cpu处在内核态执行进程的时间百分比</li>
<li>%iowait：cpu用于等待io操作占用cpu总时间百分比，过高，硬盘存在io瓶颈</li>
<li>%steal：管理程序为另一个虚拟程序提供服务而等待虚拟cpu的百分比</li>
<li>%idle：cpu空闲时间百分比，高但系统响应慢，可能是cpu等待分配内存，应加大内存容量，持续低于1则cpu处理能力较低，需要提高cpu资源</li>
</ol>
<p>sar -q，查看平均负载</p>
<ol>
<li>runq-sz    运行队列的长度（等待运行的进程数，每核不能超过3个）</li>
<li>plist-sz   进程列表中的进程（processes）和线程数（threads）的数量</li>
<li>ldavg-1  最后1分钟的CPU平均负载，即将多核CPU过去一分钟的负载相加再除以核心数得出的平均值，5分钟和15分钟以此类推</li>
<li>ldavg-5   最后5分钟的CPU平均负载</li>
<li>ldavg-15  最后15分钟的CPU平均负载</li>
<li>blocked   阻塞的进程数</li>
</ol>
<p>sar -r，查看内存使用情况<br>kbmemfree   空闲的物理内存大小<br>kbmemused   使用中的物理内存大小<br>%memused  物理内存使用率<br>kbbuffers  内核中作为缓冲区使用的物理内存大小，kbbuffers和kbcached:这两个值就是free命令中的buffer和cache. <br>kbcached  缓存的文件大小<br>kbcommit   保证当前系统正常运行所需要的最小内存，即为了确保内存不溢出而需要的最少内存（物理内存+Swap分区）<br>commit   这个值是kbcommit与内存总量（物理内存+swap分区）的一个百分比的值</p>
<p>sar -W，查看系统swap分区统计请况<br>pswpin/s    每秒从交换分区到系统的交换页面（swap page）数量<br>pswpott/s   每秒从系统交换到swap的交换页面（swap page）的数量</p>
<p>sar -b，查看io和传递速率</p>
<ol>
<li>tps：磁盘每秒中的io总数，等于iostat的tps</li>
<li>rtps：每秒钟从磁盘读取的io总数</li>
<li>wtps：每秒写入到磁盘的io总数</li>
<li>bread/s：每秒从磁盘读取的总块数</li>
<li>bwrtn/s：每秒写入磁盘的总块数</li>
</ol>
<p>sar -d，查看磁盘使用情况</p>
<ol>
<li>tps：每秒io的传输总数</li>
<li>rd_sec/s：每秒读取的扇区总数</li>
<li>wr_sec/s：每秒写入的扇区总数</li>
<li>avgrq-sz：平均每次磁盘io操作的数据大小</li>
<li>avgqu-sz：磁盘请求队列的平均长度</li>
<li>await：从请求磁盘操作到系统完成处理，每次请求的平均消耗时间，包括请求队列等待时间，等于寻道时间+队列时间+服务时间</li>
<li>svctm：io服务处理时间，不包括请求队列中的时间</li>
<li>%util：io请求占用的cpu百分比，值越高io越慢</li>
</ol>
<h3 id="Buffer和Cache"><a href="#Buffer和Cache" class="headerlink" title="Buffer和Cache"></a>Buffer和Cache</h3><p>buffer和cache是两个不同的概念：cache是高速缓存，用于CPU和内存之间的缓冲；buffer是I/O缓存，用于内存和硬盘的缓冲；简单的说，cache是加速“读”，而buffer是缓冲“写”，前者解决读的问题，保存从磁盘上读出的数据，后者是解决写的问题，保存即将要写入到磁盘上的数据。</p>
<h3 id="io需要经历的阶段"><a href="#io需要经历的阶段" class="headerlink" title="io需要经历的阶段"></a>io需要经历的阶段</h3><p>比如写入一个字符从系统到硬盘需要经历哪些阶段（面试时问的，后续想起来可能是想问经历哪些系统调用）<br>简单版：应用程序调用系统调用write来由操作系统完成写入，linux将文件系统抽象为VFS（虚拟文件系统）兼容多种文件系统。write会调用vfs的接口。如果创建新文件，文件系统添加一个inode文件用于记录data文件，并将inode关联到所在的文件夹中，接着inode会记录一个block，记录写入的内容。文件系统调用block io实现写磁盘，block设备能随机读取一个固定块数据。文件系统将带写入的数据转化为block io调用，并由于block设备一次写入和寻址耗时多，block io并不会立即写入，而是缓存在队列中，进行一轮合并和重排后再操作。最后block io调用硬件设备的驱动程序，写入到硬件中</p>
<p>详细一点参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jason-t/articles/10534919.html#_label5">博客</a><br>读文件</p>
<ol>
<li>进程调用库函数向内核发起读文件请求；</li>
<li>内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；</li>
<li>调用该文件可用的系统调用函数read()</li>
<li>read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；</li>
<li>在inode中，通过文件内容偏移量计算出要读取的页；</li>
<li>通过inode找到文件对应的address_space；</li>
<li>在address_space中访问该文件的页缓存树，查找对应的页缓存结点：<ol>
<li>如果页缓存命中，那么直接返回文件内容；</li>
<li>如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；</li>
</ol>
</li>
<li>文件内容读取成功</li>
</ol>
<p>写文件<br>前6步和读文件一致，在address_space中查询对应页的页缓存是否存在：</p>
<ol start="7">
<li>如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。</li>
<li>如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。</li>
<li>一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：<ol>
<li>手动调用sync()或者fsync()系统调用把脏页写回</li>
<li>pdflush进程会定时把脏页写回到磁盘</li>
</ol>
</li>
</ol>
<p>同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</p>
<h3 id="机械硬盘和固态硬盘"><a href="#机械硬盘和固态硬盘" class="headerlink" title="机械硬盘和固态硬盘"></a>机械硬盘和固态硬盘</h3><p>硬盘是计算机的主要外部存储设备。</p>
<ol>
<li>机械硬盘HDD<br>采用磁性碟片存储数据，每个碟片分为磁道、扇区，磁道是逻辑结构中的同心圆，扇区是每个碟形成片划分出的扇形区域，是存储的最小单位，通常是512字节。柱面是多个盘面中编号相等的磁道形成的圆柱。磁盘大小=磁头数（碟片数*2） * 柱面数 * 扇区数 * 每个扇区的大小。常见接口有IDE(133MB/s), SATA(600MB/s, 速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力), SCSI(320MB/s, 广泛应用在服务器上，具有应用范围广、多任务、带宽大、CPU 占用率低及热插拔等优点)</li>
<li>固态硬盘SSD<br>由主控芯片、闪存颗粒和缓存单元构成<br>1）主控芯片：类似于CPU，作用一是合理调配数据在各个闪存芯片上的负荷，二则是承担了整个数据中转，连接闪存芯片和外部SATA接口<br>2）闪存颗粒单元：存储单元，闪存是长寿命、非易失的存储器，数据删除以区块为单位，分为SLC、MLC、TLC，分别存储1，2，3比特<br>3）缓存芯片，读写小文件和常用文件时，不断进行数据整块写入缓存，导出到闪存颗粒，需要缓存维持。相当于临时停车场<br>总线：数据传输公路<br>1）SATA：最大不超过600MB/s<br>2）PCI-E：最高1500MB/s<br>协议：NVMe协议相当于针对PCI-E专门设计的用于提升传输速率。内存中SQ（提交队列）和CQ（完成队列），SSD中DB（门铃注册）。<br>接口：<br>1）SATA：老式接口，最大不超过600MB/s<br>2）mSATA<br>3）M.2,：需要主板配备M.2接口，新式接口可达1500MB/s，老式上限为1000MB/s<br>4）PCI-E：x1…x16读写速率依次提升<br>固态硬盘顺序读写速度超快，但实际使用时通常用4KB随机读写速度<br>• 扇区：磁盘的最小存储单位；<br>• 磁盘块：文件系统读写数据的最小单位；<br>• 页：内存的最小存储单位；<br>• 一个磁盘块由连续几个（2^n）扇区组成；<br>• 页的大小为磁盘块大小的2^n倍<br>参阅<a target="_blank" rel="noopener" href="https://www.cnblogs.com/whl320124/p/10063608.html">博客</a>, <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/879.html">博客</a></li>
</ol>
<h3 id="常用硬件性能参数"><a href="#常用硬件性能参数" class="headerlink" title="常用硬件性能参数"></a>常用硬件性能参数</h3><p>操作类别                    时间<br>访问L1 cache               0.5ns<br>分支预测失败                5ns<br>访问L2 cache                7ns<br>Mutex加锁/解锁              100ns<br>内存访问                    100ns<br>千兆网络发送1M数据          10ms<br>从内存顺序读取1M数据        0.25ms<br>机房内网络来回              0.5ms<br>异地机房网络来回            30-100ms<br>SATA磁盘寻道               10ms<br>从SATA磁盘顺序读取1M数据    20ms<br>SSD访问延迟                0.1-0.2ms<br>可见存储系统的性能瓶颈主要在磁盘随机读写，设计存储引擎会针对磁盘特性做处理，比如将随机写操作转化为顺序写，通过缓存减少磁盘随机读操作</p>
<h3 id="单机存储引擎"><a href="#单机存储引擎" class="headerlink" title="单机存储引擎"></a>单机存储引擎</h3><p>存储系统的发动机，直接决定存储系统的性能和功能，理论来源于关系数据库</p>
<ol>
<li>哈希存储引擎：基于哈希表结构的键值存储结构，特点是写时追加，不会修改，文件大小超过限制会新建一个活跃数据文件，达到限制的叫老数据文件。会执行定期合并将所有老数据文件中的数据扫描一遍生成新的数据文件。同一个key的多个操作只保留最新的一个，其余删除来避免冗余。还通过索引文件来提高重建哈希表的速度，合并时除了产生新的数据文件，还产生一个索引文件，记录每条记录的哈希索引信息</li>
<li>B+树存储引擎：支持随机读取和范围扫描。叶子节点保存完整数据，非叶子节点保存索引信息。根节点是常驻内存。缓冲区管理器将可用内存划分为缓冲区，与页同等大小，使用LRU淘汰策略。并采用LIRS算法，构建二级cache，当数据访问频率到达阈值后放入二级cache</li>
<li>LSM树存储引擎：基本思想是将数据的修改增量保存到内存中，当内存达到大小限制后将这些增量数据批量写入磁盘，避免随机写入，读取时需要合并磁盘中的历史数据和内存中的增量数据，用作LevelDB的存储引擎。有效地规避了磁盘随机写人问题，读取时可能需要访问较多的磁盘文件</li>
</ol>
<h3 id="LevelDB存储系统"><a href="#LevelDB存储系统" class="headerlink" title="LevelDB存储系统"></a>LevelDB存储系统</h3><p>用于单机存储，其中写操作速度高效，远超过读操作<br>特点：</p>
<ol>
<li>LevelDB是一个持久化存储的KV系统，和Redis内存型的KV系统不同，不会很占内存，而是将大部分数据存储到磁盘上</li>
<li>LevelDB在存储数据时，根据记录的key值有序存储，且可以自定义key大小比较函数</li>
<li>像大多数KV系统一样，操作接口简单，基本操作包括写、读和删除，也支持多条操作的原子批量操作</li>
<li>LevelDB支持数据快照，使得读操作不受写影响</li>
<li>支持数据压缩，减小存储空间，增快IO效率</li>
</ol>
<p>整体结构：主要包括内存中的MemTable，只读MemTable，磁盘上的current文件，manifest文件，log文件以及SSTable文件。</p>
<ol>
<li>MemTable保存写入内存的kv对，并在达到界限后生成只读MemTable，并且启动子线程将只读MemTable持久化到磁盘中形成Level0的SSTable文件</li>
<li>在每次写入到内存时，会先向log文件中写入，成功后再写入MemTable，保证在系统崩溃时数据不会丢失。如果是删除则插入k-del数据，更新则插入新数据，对之前数据不进行任何操作。</li>
<li>SSTable文件记录的数据是有序的，除了Level0的多个文件之间可能存在重复元素外，Level1-n均是不重叠的。</li>
<li>manifest文件保存SSTable的管理信息，例如属于的level，文件名，最小key和最大key</li>
<li>current文件保存当前在使用的manifest文件名，每次合并进行会产生新的文件，对应的manifest文件也会变化</li>
</ol>
<p>操作：写入，删除，更新，合并</p>
<ol>
<li>写入/删除：写入时，先将kv记录以顺序写的方式追加到log文件尾，因为是顺序追加的方式效率很高。如果写入成功则插入内存的MemTable中，MemTable内部通过SkipList实现，一次插入操作需要一次磁盘文件追加写和内存SkipList插入。删除一条kv记录是插入k-del标记，并不删除记录，等后台合并时做删除。即懒惰做法，当前不更新只记录，等到后续操作执行。</li>
<li>读取：首先从MemTable-&gt;只读MemTable-&gt;Level0-&gt;…-&gt;levelN的顺序来看，数据是越来越老的，因为所有新更新的数据都会按照这个顺序执行。如果在某一位置查到了数据则这个数据是最新的，不需要再向后查找。即读数据按照这个顺序查找直到第一个，或到最高level都没有则不存在。</li>
<li>合并：memtable大小或者各Level的文件达到上界时，需要合并到下一级中。分为minor和major。minor是指将MemTable内容保存到磁盘文件中，按照记录从小到大的顺序，一次写入一个level0的新建SSTable文件中，并建立文件的index数据。对于被删除的数据，在minor阶段不真正删除，因为删除操作开销很大。major合并是指某个level下的SSTable文件数目超过一定值后，levelDB从中选择一个文件，将其和高一层级的SSTable文件合并，通常是轮流选择文件，并且与上级中具有重叠的文件进行合并，具体做法使用多路归并排序，并判断某一个key是否需要保存（是否删除或是旧值，小于level的层中是否存在这个key）并保存或抛弃，于是形成level+1层的新SSTable文件，并且将level层的被合并的文件删除。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/interview/" rel="tag"># 面经</a>
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/21/%E7%AC%94%E8%AF%95%E6%A8%A1%E6%9D%BF/" rel="prev" title="笔试模板">
      <i class="fa fa-chevron-left"></i> 笔试模板
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="操作系统面试题">
      操作系统面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">操作系统特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7%E7%AB%AF%E3%80%81%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="nav-number">2.0.1.</span> <span class="nav-text">大端、小端存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.0.2.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.0.3.</span> <span class="nav-text">系统调用和库函数的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">2.0.4.</span> <span class="nav-text">用户态和内核态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E9%83%A8%E5%88%86"><span class="nav-number">2.0.5.</span> <span class="nav-text">操作系统的存储部分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.0.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.0.2.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">3.0.3.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E7%A8%8B%E5%BA%8F%E6%9C%9D%E7%9D%80%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%90%91%E5%8F%91%E5%B1%95"><span class="nav-number">3.0.4.</span> <span class="nav-text">为什么现在程序朝着多线程方向发展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%88%E4%BB%8ECPU%E7%9A%84%E5%B1%82%E9%9D%A2%E4%B8%8A"><span class="nav-number">3.0.5.</span> <span class="nav-text">线程切换开销在哪些方面（从CPU的层面上)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fork%E5%92%8Cexec%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.0.6.</span> <span class="nav-text">fork和exec的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84"><span class="nav-number">3.0.7.</span> <span class="nav-text">父进程和子进程哪些是共享的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.1.</span> <span class="nav-text">批处理系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.2.</span> <span class="nav-text">交互系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.3.</span> <span class="nav-text">进程状态</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">孤儿进程和僵尸进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.2.1.</span> <span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text">僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.3.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="nav-number">3.3.1.</span> <span class="nav-text">临界资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">3.3.2.</span> <span class="nav-text">同步与互斥</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.3.</span> <span class="nav-text">同步的方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.</span> <span class="nav-text">经典同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BA%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.1.</span> <span class="nav-text">生产者于消费者问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.2.</span> <span class="nav-text">读者-写者问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.3.</span> <span class="nav-text">哲学家进餐问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">3.5.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%BF%AB%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">3.5.1.</span> <span class="nav-text">最快的进程通信方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B-1"><span class="nav-number">3.6.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.6.1.</span> <span class="nav-text">多线程共享的数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.6.2.</span> <span class="nav-text">多线程同步的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.6.3.</span> <span class="nav-text">线程同步的锁类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">3.6.4.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AE%E8%AF%A2"><span class="nav-number">3.6.5.</span> <span class="nav-text">中断和轮询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.0.1.</span> <span class="nav-text">必要条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">4.0.2.</span> <span class="nav-text">处理方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">5.0.1.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">5.0.2.</span> <span class="nav-text">分页系统地址映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">5.0.3.</span> <span class="nav-text">页置换算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%AE%B5"><span class="nav-number">5.0.4.</span> <span class="nav-text">分段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="nav-number">5.0.5.</span> <span class="nav-text">段页式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">5.0.6.</span> <span class="nav-text">分页与分段的比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%98%AF%E4%B8%80%E7%BB%B4%E7%9A%84%E8%80%8C%E5%88%86%E6%AE%B5%E6%98%AF%E4%BA%8C%E7%BB%B4%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.0.7.</span> <span class="nav-text">分页是一维的而分段是二维的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-number">5.0.8.</span> <span class="nav-text">内存连续分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E7%BC%93%E5%86%B2"><span class="nav-number">5.0.9.</span> <span class="nav-text">缓存和缓冲</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2-1"><span class="nav-number">5.0.10.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A1%B5%E5%A4%A7%E5%B0%8F%E6%98%AF4KB%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF24KB%E5%86%85%E5%AD%98%E5%88%A9%E7%94%A8%E7%8E%87%E6%80%8E%E4%B9%88%E5%8F%98%E5%8C%96"><span class="nav-number">5.0.11.</span> <span class="nav-text">为什么页大小是4KB，如果是24KB内存利用率怎么变化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-number">5.0.12.</span> <span class="nav-text">缓冲区溢出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.0.13.</span> <span class="nav-text">堆栈区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">磁盘调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">7.</span> <span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F"><span class="nav-number">7.0.1.</span> <span class="nav-text">编译系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">7.0.2.</span> <span class="nav-text">静态链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">7.0.3.</span> <span class="nav-text">动态链接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux"><span class="nav-number">8.</span> <span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">8.0.1.</span> <span class="nav-text">常用指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PATH"><span class="nav-number">8.0.2.</span> <span class="nav-text">PATH</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-number">8.0.3.</span> <span class="nav-text">包管理工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA"><span class="nav-number">9.</span> <span class="nav-text">分区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-number">9.0.1.</span> <span class="nav-text">分区表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%9C%BA%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F"><span class="nav-number">9.0.2.</span> <span class="nav-text">开机检测程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E6%88%90"><span class="nav-number">10.0.1.</span> <span class="nav-text">组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="nav-number">10.0.2.</span> <span class="nav-text">文件读取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87"><span class="nav-number">10.0.3.</span> <span class="nav-text">磁盘碎片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">10.0.4.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">10.0.5.</span> <span class="nav-text">日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-number">10.0.6.</span> <span class="nav-text">文件属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90"><span class="nav-number">10.0.7.</span> <span class="nav-text">默认权限</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5-1"><span class="nav-number">10.0.8.</span> <span class="nav-text">链接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shell%E7%9B%B8%E5%85%B3"><span class="nav-number">11.</span> <span class="nav-text">Shell相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-number">11.0.1.</span> <span class="nav-text">压缩文件名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4"><span class="nav-number">11.0.2.</span> <span class="nav-text">压缩指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bash"><span class="nav-number">11.0.3.</span> <span class="nav-text">Bash</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F"><span class="nav-number">11.0.4.</span> <span class="nav-text">指令搜索顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">11.0.5.</span> <span class="nav-text">数据流重定向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E6%8C%87%E4%BB%A4"><span class="nav-number">11.0.6.</span> <span class="nav-text">管道指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4"><span class="nav-number">12.</span> <span class="nav-text">资源监控命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="nav-number">12.0.1.</span> <span class="nav-text">top命令详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#free%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="nav-number">12.0.2.</span> <span class="nav-text">free命令详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vmstat%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="nav-number">12.0.3.</span> <span class="nav-text">vmstat命令详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iostat%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="nav-number">12.0.4.</span> <span class="nav-text">iostat命令详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sar%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%BE%88%E5%85%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%89"><span class="nav-number">12.0.5.</span> <span class="nav-text">sar命令详解（很全的命令）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer%E5%92%8CCache"><span class="nav-number">13.</span> <span class="nav-text">Buffer和Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E9%9C%80%E8%A6%81%E7%BB%8F%E5%8E%86%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="nav-number">14.</span> <span class="nav-text">io需要经历的阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="nav-number">15.</span> <span class="nav-text">机械硬盘和固态硬盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%A1%AC%E4%BB%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="nav-number">16.</span> <span class="nav-text">常用硬件性能参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%9C%BA%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">17.</span> <span class="nav-text">单机存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LevelDB%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">18.</span> <span class="nav-text">LevelDB存储系统</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiahang Gu</p>
  <div class="site-description" itemprop="description">认真学习，享受生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JiahangGu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiahangGu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/fengzhizi76506" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;fengzhizi76506" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiahang Gu</span>

</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
