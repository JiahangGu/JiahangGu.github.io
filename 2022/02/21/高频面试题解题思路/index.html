<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="codetop高频题思路 206.反转链表输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL  关键点：需要一个prev结点记录前驱结点，修改指向关系后更新prev和cur结点  215.数组中的第K个最大元素在未排序的数组中找到第 k 个最大的元素输入: [3,2,1,5,6,4] 和 k &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="高频面试题解题思路">
<meta property="og:url" content="http://example.com/2022/02/21/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/index.html">
<meta property="og:site_name" content="菜汤里的咸鱼要翻身">
<meta property="og:description" content="codetop高频题思路 206.反转链表输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL  关键点：需要一个prev结点记录前驱结点，修改指向关系后更新prev和cur结点  215.数组中的第K个最大元素在未排序的数组中找到第 k 个最大的元素输入: [3,2,1,5,6,4] 和 k &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-21T04:16:54.000Z">
<meta property="article:modified_time" content="2022-02-21T05:26:02.653Z">
<meta property="article:author" content="Jiahang Gu">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="算法题">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/02/21/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>高频面试题解题思路 | 菜汤里的咸鱼要翻身</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">菜汤里的咸鱼要翻身</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          高频面试题解题思路
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:16:54 / 修改时间：13:26:02" itemprop="dateCreated datePublished" datetime="2022-02-21T12:16:54+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>36k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>33 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="codetop高频题思路"><a href="#codetop高频题思路" class="headerlink" title="codetop高频题思路"></a>codetop高频题思路</h3><ol>
<li>206.反转链表<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</li>
</ol>
<p><strong>关键点：需要一个prev结点记录前驱结点，修改指向关系后更新prev和cur结点</strong></p>
<ol start="2">
<li>215.数组中的第K个最大元素<br>在未排序的数组中找到第 k 个最大的元素<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</li>
</ol>
<p><strong>关键点：快排思想更新数组为前k-1个元素均大于第k个最大元素，时间复杂度O(N)。或者使用最小堆维护，时间复杂度O(Nlgk)。</strong></p>
<ol start="3">
<li>3.无重复字符的最长子串<br>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度<br>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li>
</ol>
<p><strong>关键点：滑动窗口问题模板解决。</strong><br>模板：<br>window维护当前窗口内的变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while r &lt; n:</span><br><span class="line"></span><br><span class="line">  将s[r]放入window中</span><br><span class="line"></span><br><span class="line">  while window包含重复字符：</span><br><span class="line"></span><br><span class="line">​    移除s[l]，并且右移l</span><br><span class="line"></span><br><span class="line">  更新解</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>146.LRU 缓存机制<br>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：<br>1）LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>2）int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>3） void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ol>
<p><strong>关键点：有些难度，思路是使用双向链表维护插入顺序，然后再使用字典维护key-&gt;Node信息实现O(1)查找。插入时如果结点存在取出结点，并创建新值的结点，放入链表头，结点不存在则放入链表头表示最近访问，如果插入后超过最大容量则删除链表尾结点。查找时如果存在则将结点取出并移动到链表头。实现细节：定义head,tail为Node(0)，可以避免空结点的特判；移动到头或尾时需要先从链表中删除结点再插入</strong></p>
<ol start="5">
<li>25.K 个一组翻转链表<br>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。<br>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</li>
</ol>
<p><strong>关键点：分析问题一步步来。首先是划分k个结点一组，先找到这k个结点，如果不够则说明结束。使用prev记录这组的前驱结点，有前驱和结尾可以像反转链表一样做。反转完成后移动prev结点，并找到下一组的k个结点</strong></p>
<ol start="6">
<li>160.相交链表<br>编写一个程序，找到两个单链表相交的起始节点。</li>
</ol>
<p><strong>关键点：从起点出发，直到pa==pb前一直后移，如果移动到链表末尾则改为从另一链表头结点开始后移。假设链表长度分别为a,b，则最终循环结束时两个指针均走了a+b个结点，如果都为null则不相交，如果相交则必在末尾之前相遇</strong></p>
<ol start="7">
<li>15.三数之和<br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[ [-1,-1,2],[-1,0,1] ]</li>
</ol>
<p><strong>关键点：和两数之和一样的思路，先排序然后双指针查找和为0的元素。如果更大则右指针左移，如果更小则左指针右移，如果相等则记录解，并且因为要去重要左右指针均移动到第一个不相等的元素</strong></p>
<ol start="8">
<li>53.最大子序和<br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</li>
</ol>
<p><strong>关键点：加上负数只会更小。所以记录此前的和，如果小于0则从当前数字开始的和一定更大，如果大于0则可以累加。注意最后都要更新解</strong></p>
<ol start="9">
<li>121.买卖股票的最佳时机<br>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</li>
</ol>
<p><strong>关键点：维护此前的最小值，如果当前数字小于最小值则修改最小值，否则计算利润并更新解</strong></p>
<ol start="10">
<li>415.字符串相加<br>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</li>
</ol>
<p><strong>关键点：首先对齐数位，单个数位求和sum并加上之前的进位c,当前数字为(sum+c)%10, 更新进位为sum/10.直到字符串遍历结束并且c为0结束计算</strong></p>
<ol start="11">
<li>1.两数之和<br>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </li>
</ol>
<p><strong>关键点：排序，双指针。和更大则右指针左移，和更小则左指针右移。循环结束条件是l &gt;= r</strong></p>
<ol start="12">
<li>142.环形链表 II<br>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</li>
</ol>
<p><strong>关键点：双指针，快指针每次走两步，慢指针每次走一步，直到快指针为空或二者相遇。如果为空则表示无环，如果相遇则令慢指针指向head，和fast一起每次走一步，直到二者相遇得到环入口</strong></p>
<ol start="13">
<li>102.二叉树的层序遍历<br>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</li>
</ol>
<p><strong>关键点：使用队列存储，每次遍历，记录当前队列的结点个数，循环取出这些结点则为同一层</strong></p>
<ol start="14">
<li>21.合并两个有序链表<br>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</li>
</ol>
<p><strong>关键点：类似于归并排序，从头结点开始比较大小并合并，循环结束后将未遍历完的链表直接接到结果链表后即可。实现细节：使用dummy结点并使next指向结果链表的头结点，最后返回dummy.next</strong></p>
<ol start="15">
<li>912.排序数组<br>给你一个整数数组 nums，请你将该数组升序排列。</li>
</ol>
<p><strong>关键点：排序算法，好像要求手撕快排，可以记模板</strong></p>
<ol start="16">
<li>103.二叉树的锯齿形层序遍历<br>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</li>
</ol>
<p><strong>关键点：在普通层序遍历的基础上，判断当前层的顺序，根据顺序选择先放入左子节点还是右子节点，最好画一个至少三层的树推一次</strong></p>
<ol start="17">
<li>141.环形链表<br>给定一个链表，判断链表中是否有环。</li>
</ol>
<p><strong>关键点：双指针做法，快指针两步，慢指针一步，循环结束时判断是到链表尾还是相遇来确定是否有环</strong></p>
<ol start="18">
<li>236.二叉树的最近公共祖先<br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</li>
</ol>
<p><strong>关键点：遍历二叉树找到指定结点，并返回该结点，如果有一个公共祖先则该祖先左右子树会返回两个节点，否则会有当前结点等于指定结点其中一个节点值。</strong></p>
<ol start="19">
<li>20.有效的括号<br>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</li>
</ol>
<p><strong>关键点：使用栈放左括号，如果遇到右括号弹出栈顶判断是否匹配，不匹配则无效，字符串遍历完栈为空则有效</strong></p>
<ol start="20">
<li>94.二叉树的中序遍历<br>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</li>
</ol>
<p><strong>关键点：应该是要考迭代，可以记模板。关键点是两层while，第一层判断结点是否为空或栈是否为空，第二层从该结点一路向左并用栈记录路径，到达null时弹出栈顶并加入答案，然后进入右子节点。</strong></p>
<ol start="21">
<li>88.合并两个有序数组<br>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。<br>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]</li>
</ol>
<p><strong>关键点：从后向前遍历并比较。哪里有空闲位置就先往哪里写</strong></p>
<ol start="22">
<li>54.螺旋矩阵<br>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</li>
</ol>
<p><strong>关键点：一层一层打印，需要考虑的细节较多，建议样例使用33矩阵和44矩阵各进行一次推导，奇数边中心点无需打印，遍历层数为n/2</strong></p>
<ol start="23">
<li>199.二叉树的右视图<br>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</li>
</ol>
<p><strong>关键点：层次遍历，每层只记录最右测的结点值</strong></p>
<ol start="24">
<li>42.接雨水<br>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</li>
</ol>
<p><strong>关键点：做法1：更小的边决定了接水的容量，使用双指针维护左右两边界，每次移动更小的边并更新解；做法2：单调栈，栈底到栈顶递减，遇到高于栈顶的边时弹出栈顶并添加对应解</strong></p>
<ol start="25">
<li>200.岛屿数量<br>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</li>
</ol>
<p><strong>关键点：dfs模板，循环遍历，从没有被标记的陆地出发并将所有联通的陆地标记特殊值，记录标记的个数</strong></p>
<ol start="26">
<li>剑指 Offer 22.链表中倒数第k个节点<br>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.</li>
</ol>
<p><strong>关键点：双指针，快指针先走k步，然后快慢同时走，则快指针到末尾时慢指针到目标结点。需要考虑边界条件判断，避免出现空指针异常</strong></p>
<ol start="27">
<li>232.用栈实现队列<br>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</li>
</ol>
<p><strong>关键点：两个栈s1,s2，push放入s1，pop时如果s2为空则将s1的元素逐次取出并压入s2，弹出s2栈顶</strong></p>
<ol start="28">
<li>5.最长回文子串<br>给你一个字符串 s，找到 s 中最长的回文子串。</li>
</ol>
<p><strong>关键点：回文字串长度可能为奇数或偶数，遍历每个字符作为回文中心的情况向外层扩展直到不符合条件，在扩展的同时维护最长串对应的解。主要扩展不要超出字符串的范围，并且奇数中心和偶数中心都需要遍历</strong></p>
<ol start="29">
<li>46.全排列<br>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</li>
</ol>
<p><strong>关键点：模板。尝试将每一个字符放到当前字符串第一位，然后递归解决剩余字符串，递归参数需要记录当前字符串第一位在原字符串的位置</strong></p>
<ol start="30">
<li>92.反转链表 II<br>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表。<br>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]</li>
</ol>
<p><strong>关键点：同普通的反转链表，需要先找到链表反转区间的头结点和尾结点，此外因为要和剩余部分连接，同时也需要维护区间的前面一个结点和后面一个结点，在反转后连接起来</strong></p>
<ol start="31">
<li>300.最长递增子序列<br>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。<br>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</li>
</ol>
<p><strong>关键点：常规做法dp[i]表示以nums[i]结尾的最大递增子序列长度，求dp[i]时遍历k=0~i-1，如果nums[i]&gt;nums[k]，则dp[i] = max(dp[k]) + 1</strong></p>
<ol start="32">
<li>110.平衡二叉树<br>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</li>
</ol>
<p><strong>关键点：要记录子树的深度，可以维护一个全局变量记录是否平衡。根据子树深度判断是否平衡，当前结点的深度是max(左子树深度，右子树深度)+1</strong></p>
<ol start="33">
<li>113.路径总和 II<br>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</li>
</ol>
<p><strong>关键点：回溯算法，向下递归维护当前路径和和结点路径，到达叶子节点时判断是否等于target并记录解。</strong></p>
<ol start="34">
<li>2.两数相加<br>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</li>
</ol>
<p><strong>关键点：类似于字符串加法，记录进位，直到一个链表遍历完并且进位为0</strong></p>
<ol start="35">
<li>104.二叉树的最大深度<br>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</li>
</ol>
<p><strong>关键点：当前结点的深度是max(左子树深度，右子树深度)+1</strong></p>
<ol start="36">
<li>33.搜索旋转排序数组<br>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。<br>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4</li>
</ol>
<p><strong>关键点：二分只能在有序序列使用，所以根据nums[l]和nums[mid]的大小关系先找到有序的部分是哪个，然后在有序的部分中继续搜索。例如nums[l] &lt;= nums[mid]时，if nums[l] &lt;= target &lt; nums[mid]则左半部分有序，且target在左半部分中，r = mid - 1</strong></p>
<ol start="37">
<li>69.x 的平方根<br>实现 int sqrt(int x) 函数。<br>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>由于返回类型是整数，小数部分将被舍去。</li>
</ol>
<p><strong>关键点：二分查找，查找范围是o-x，当midmid &gt; x时mid肯定不是解，r = mid- 1向左继续搜索，当midmid&lt;=x时mid可能为解，l = mid</strong></p>
<ol start="38">
<li>23.合并K个升序链表<br>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。<br>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>1-&gt;4-&gt;5,<br>1-&gt;3-&gt;4,<br>2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</li>
</ol>
<p><strong>关键点：在两个链表合并的基础上，采用分治思想，两两合并，直到最后合并为一条链表。在每轮合并过程中需要使用数组记录每次合并后的头结点。实现细节同两个链表合并</strong></p>
<ol start="39">
<li>155.最小栈<br>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</li>
</ol>
<p><strong>关键点：一个栈记录原始数据，另一个栈记录最小值，当pop时如果弹出的元素是最小栈的栈顶元素时，说明即将弹出的是最小元素，则最小栈也弹出栈顶</strong></p>
<ol start="40">
<li>543.二叉树的直径<br>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</li>
</ol>
<p><strong>关键点：求树的深度，直径=root的左子树深度+1+root的右子树深度</strong></p>
<ol start="41">
<li>144.二叉树的前序遍历<br>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</li>
</ol>
<p><strong>关键点：同中序遍历，只是记录结点的操作放在了找左子节点的过程中。建议最好记一个模板</strong></p>
<ol start="42">
<li>704.二分查找<br>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</li>
</ol>
<p><strong>关键点：普通二分，没什么好说的</strong></p>
<ol start="43">
<li>234.回文链表<br>请判断一个链表是否为回文链表。</li>
</ol>
<p><strong>关键点：如果没要求O(1)空间，则可以找到中间结点，用栈记录前半部分结点，与后半部分比较。如果要求O(1)空间，则找到中间结点，对后半部分直接反转，并比较反转后的两部分链表是否相同。相同则回文。注意比较完成后对链表再次反转恢复初始状态。找中间结点要注意奇数个结点和偶数个结点，最好各举一个样例手推</strong></p>
<ol start="44">
<li>56.合并区间<br>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。<br>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li>
</ol>
<p><strong>关键点：以起点为准升序排序，起点相同则终点升序，记录当前区间，并向后遍历如果可以合并则更新当前区间，如果不能合并则记录当前区间为解，并以下一个区间作为当前区间继续搜索</strong></p>
<ol start="45">
<li>151.翻转字符串里的单词<br>给定一个字符串，逐个翻转字符串中的每个单词。<br>说明：<br>无空格字符构成一个 单词 。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ol>
<p><strong>关键点：先对整个字符串反转，然后以空格为隔离符，反转每一个单词</strong></p>
<ol start="46">
<li>169.多数元素<br>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</li>
</ol>
<p><strong>关键点：投票算法，记录当前元素以及出现次数，当前元素出现时次数+1，否则减1，如果减完&lt;0则更换当前元素。最终的当前元素需要一次遍历验证是否为多数元素</strong></p>
<ol start="47">
<li>105.从前序与中序遍历序列构造二叉树<br>根据一棵树的前序遍历与中序遍历构造二叉树。<br>注意:<br>你可以假设树中没有重复的元素。</li>
</ol>
<p><strong>关键点：前序遍历的头元素是当前树的根，在中序遍历中找到根，并划分为左子树和右子树分别构造，与根元素建立联系</strong></p>
<ol start="48">
<li>124.二叉树中的最大路径和<br>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br>路径和 是路径中各节点值的总和。<br>给你一个二叉树的根节点 root ，返回其 最大路径和 。</li>
</ol>
<p><strong>关键点：最大路径可能出现在任意位置，需要一个全局变量维护解。对于每个节点，以该节点为根的子树最大路径和为max(左子树最大路径和，右子树最大路径和，左子树最大路径和+右子树最大路径和+当前结点值)，以此来更新解。但向上返回路径时必须包含根结点的值，所以返回的最大路径和为max(包含左子节点的左子树最大路径和，包含右子节点的右子树最大路径和)+根节点的值，所以需要返回的值有2个，当前子树最大路径和，以及包含当前结点的最大路径和</strong></p>
<ol start="49">
<li>240.搜索二维矩阵 II<br>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：<br>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</li>
</ol>
<p><strong>关键点：从右上角开始搜索，根据与target的大小关系判断应该向左还是向下搜索</strong></p>
<ol start="50">
<li>8.字符串转换整数 (atoi)<br>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）</li>
</ol>
<p><strong>关键点：不难，但细节多。1）出现非法字符则应该停止，返回目前的结果；2）求其前导空格；3）对第一位字符为’+’或’-‘进行特判；4）最后返回时判断是否溢出int范围</strong></p>
<ol start="51">
<li>4.寻找两个正序数组的中位数<br>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</li>
</ol>
<p><strong>关键点：难题，酌情跳过。主要思路是，要找第k=n/2小的数，则有k-1个数小于中位数，则n1,n2均取k/2-1比较，可以排除较小一方的k/2-1个元素，并且修改k的值，表示剩余还需要找k个数小于中位数，继续后移较小方数组的指针。直到k为1.注意对k的处理，以及n1或n2有一方遍历完的情况</strong></p>
<ol start="52">
<li>148.排序链表<br>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。<br>进阶：<br>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</li>
</ol>
<p><strong>关键点：归并排序，需要先通过快慢双指针找到当前链表的中间结点，递归进入归并。在链表只有一个结点或没有结点时返回。</strong></p>
<ol start="53">
<li>70.爬楼梯<br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</li>
</ol>
<p><strong>关键点：斐波那契数列，f[n] = f[n - 1] + f[n - 2]，注意优化到O(1)空间</strong></p>
<ol start="54">
<li>98.验证二叉搜索树<br>给定一个二叉树，判断其是否是一个有效的二叉搜索树。<br>假设一个二叉搜索树具有如下特征：<br>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ol>
<p><strong>关键点：做法1：中序遍历，判断当前结点是否大于上一个结点，不满足则不是，需要维护上一个结点的值；做法2：维护左子树的最大值以及右子树的最小值，当前根节点应该大于左子树最大值，小于右子树最小值，任意一个结点不满足这条件就不是BST。dfs递归时需要返回两个值：当前子树的最大值和当前子树的最小值</strong></p>
<ol start="55">
<li>718.最长重复子数组<br>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</li>
</ol>
<p><strong>关键点：动态规划，dp[i][j]表示A[0:i]和B[0:j]的最长公共子数组，则A[i] == B[j]时，dp[i][j] = dp[i - 1][j - 1] + 1；A[i] != B[j]，dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</strong></p>
<ol start="56">
<li>83.删除排序链表中的重复元素<br>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br>示例 1:<br>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</li>
</ol>
<p><strong>关键点：维护当前结点的前一个结点（万一需要删除的时候用），然后记录当前结点并向后遍历，直到遇到第一个不相同的，删除中间的所有节点。需要在遍历时记录结点是否需要删除（没有移动的话就不需要删除）。</strong></p>
<ol start="57">
<li>1143.最长公共子序列<br>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>若这两个字符串没有公共子序列，则返回 0。</li>
</ol>
<p><strong>关键点：动态规划，dp(i)(j)表示A[0:i]和B[0:j]的最长公共子数组，则A[i-1] == B[j-1]时，dp(i)(j) = dp(i-1)(j-1)+1；A[i-1] != B[j-1]，dp(i)(j) = max(dp(i-1)(j), dp(i)(j-1))</strong></p>
<ol start="58">
<li>226.翻转二叉树<br>翻转一棵二叉树。</li>
</ol>
<p><strong>关键点：递归，对左右子树各自反转，然后反转根节点的左右子节点。</strong></p>
<ol start="59">
<li>143.重排链表<br>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</li>
</ol>
<p><strong>关键点：做法1：双指针找到中间结点，反转两部分链表，进行交叉合并；做法2：递归，找到尾结点后连接到头结点，并回溯到尾结点的前一个结点，头结点后移，且头结点需要是全局变量，较复杂，不建议使用</strong></p>
<ol start="60">
<li>剑指 Offer 36.二叉搜索树与双向链表<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</li>
</ol>
<p><strong>关键点：使用迭代法的中序遍历，记录前驱结点，对于当前结点构建和前驱结点的联系（next和pre指针）。实现细节：使用dummy结点作为虚拟头结点，方便后续找到头结点，还需要记录尾结点tail，和dummy.next（即头结点）构造连接关系</strong></p>
<ol start="61">
<li>93.复原 IP 地址<br>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。<br>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。<br>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#x40;&#49;&#x2e;&#49;">&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#x40;&#49;&#x2e;&#49;</a>“ 是 无效 IP 地址</li>
</ol>
<p><strong>关键点：回溯算法，记录当前遍历的位置，已加点的个数，如果遍历完成并且刚好加了三个点就记录到解，如果当前已加三个点但没有遍历完、或者剩余字符长度超过了后续加点所能分割的最大长度（比如1个点只能分割6个字符）提前剪枝结束递归。实现细节：可以使用StringBuilder存储每次加点得到的分割字符，比如123123123123可以记录为StringBuilder.append(“123”).append(“123”)</strong></p>
<ol start="62">
<li>剑指 Offer 54. 二叉搜索树的第k大节点<br>给定一棵二叉搜索树，请找出其中第k大的节点。</li>
</ol>
<p><strong>关键点：读题，是找第k大结点而不是第k小，所以遍历时应该遵循中序遍历的逆序。先右子树再左子树，并维护一个已遍历过结点的个数，如果个数等于k则是目标结点</strong></p>
<ol start="63">
<li>64.最小路径和<br>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。</li>
</ol>
<p><strong>关键点：动态规划。dp[i][j]表示到达grid[i][j]的最小总和，考虑到每次只能向右或向下移动一步，则状态转移方程：dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]，i和j要考虑边界溢出问题</strong></p>
<ol start="64">
<li>239.滑动窗口最大值<br>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。</li>
</ol>
<p><strong>关键点：使用一个双端单调队列（队列从左到右单调递增（可相等）），表示队列右侧元素是当前窗口的最大值，并且遍历到一个元素应该从左侧弹出所有小于该元素的值（因为这些元素在遇到更大的元素后不可能成为解），如果队列右侧刚好和窗口左侧应该弹出的元素相同则说明该元素是最大值，从队列中弹出</strong></p>
<ol start="65">
<li>78.子集<br>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集</li>
</ol>
<p><strong>关键点：做法1：子集共有2^n个，可以遍历0到2^n-1，并转化为二进制，如果对应位为1则表示选择该数字进入子集，否则不选择。做法2：从已有集合={空集}开始，遍历所有元素，每个元素都取出所有的已有集合，在已有集合中加入该元素得到新集合并放入到已有集合。例如已有集合=<code>&#123;&#123;&#125;, &#123;1&#125;&#125;</code>，当前遍历到2，则取出所有集合加入2得到<code>&#123;2&#125;, &#123;1,2&#125;</code>放入已有集合得到<code>&#123;&#123;&#125;, &#123;1&#125;, &#123;2&#125;, &#123;1,2&#125;&#125;</code></strong></p>
<ol start="66">
<li>62.不同路径<br>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</li>
</ol>
<p><strong>关键点：做法1（推荐）：动态规划，假设dp[i][j]表示从00到(i,j)的路径个数，则dp(i)(j) = dp(i-1)(j)+ dp(i)(j-1)，即当前位置可以从左边过来，也可以从上边过来。注意对i=0和j=0的边界条件处理</strong></p>
<ol start="67">
<li>101.对称二叉树<br>给定一个二叉树，检查它是否是镜像对称的。</li>
</ol>
<p><strong>关键点：对于一个结点对应子树是否对称，判断左右子节点是否对称（需要考虑是否为空的情况），然后判断左右子节点为根节点对应的子树是否对称</strong></p>
<ol start="68">
<li>34.在排序数组中查找元素的第一个和最后一个位置<br>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。<br>进阶<br>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</li>
</ol>
<p><strong>关键点：两次二分，第一次找开始，第二次找结束。推荐减治法</strong></p>
<ol start="69">
<li>958.二叉树的完全性检验<br>给定一个二叉树，确定它是否是一个完全二叉树。<br>百度百科中对完全二叉树的定义如下：<br>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）</li>
</ol>
<p><strong>关键点：可以使用层次遍历，判断每一层是否是预期的2^h个结点</strong></p>
<ol start="70">
<li>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面<br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。<br>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</li>
</ol>
<p><strong>关键点：类似于partition做法，将所有奇数移动到前半部分，偶数移动到后半部分，从partition中灵活转化</strong></p>
<ol start="71">
<li>165.比较版本号<br>给你两个版本号 version1 和 version2 ，请你比较它们。<br>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。<br>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。<br>返回规则如下：<br>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。<br>输入：version1 = “1.01”, version2 = “1.001”<br>输出：0<br>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”</li>
</ol>
<p><strong>关键点：两个指针对两个字符同时开始遍历，如果已经不同则可以返回。注意对于开始位置和每个.出现的位置后续要去掉前导0，得到对应数字。一个比较投机取巧的做法是对字符用split(“.”)拆分，对得到的String数组转化为int判断大小</strong></p>
<ol start="72">
<li>39.组合总和<br>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br>说明：<br>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </li>
</ol>
<p><strong>关键点：回溯算法，记录当前遍历的位置，当前的和，当前已加入的元素，当得到target==sum时记录结果并返回（后续不会有其他解），当sum&gt;target时剪枝，此外注意一个数字可以无限次使用，在进入下层递归时还是要从当前位置开始，因为当前元素可能使用多次</strong></p>
<ol start="73">
<li>41.缺失的第一个正数<br>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？<br>输入：nums = [1,2,0]<br>输出：3</li>
</ol>
<p><strong>关键点：将所有1~n范围内的数字交换到正确位置上，对于不在范围内的数字忽略，则最后得到所有范围内均在正确位置的数组，从0开始遍历，找第一个nums[i] != i的位置，则i+1为解</strong></p>
<ol start="74">
<li>剑指 Offer 09. 用两个栈实现队列<br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</li>
</ol>
<p><strong>关键点：两个栈s1,s2,第一个栈存插入的元素，在需要弹出时如果s2不为空则弹出s2栈顶，否则将s1元素依次弹出并压入s2，弹出s2栈顶</strong></p>
<ol start="75">
<li>48.旋转图像<br>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</li>
</ol>
<p><strong>关键点：逐层旋转，逐点旋转，例如第一层逐次旋转最上侧、最右侧、最下侧和最左侧的第一个点、第二个点…第n个点，只需要开始记录第一次覆盖掉的值，在转一圈回来后赋值即可。建议手推样例判断旋转过程中i,j的对应关系</strong></p>
<ol start="76">
<li>468.验证IP地址<br>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。</li>
</ol>
<p><strong>关键点：包含’.’则可能是v4，对于.划分的所有字符判断是否0-255，包含:则可能是v6，对于:划分的所有字符串判断是否属于0-FFFF，字符串不够4位可以补前导0，如果4位都是0则非法</strong></p>
<ol start="77">
<li>128.最长连续序列<br>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br>进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？<br>输入：nums = [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</li>
</ol>
<p><strong>关键点：懒惰法：先用set保存所有数字，对于每个数字x，如果x-1存在则跳过，交给x-1来做，如果不存在则从x开始，通过循环判断x+1,x+2…x+i直到x+i不存在，则长度为i，记录最长连续序列</strong></p>
<ol start="78">
<li>112.路径总和<br>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。<br>叶子节点 是指没有子节点的节点。</li>
</ol>
<p><strong>关键点：回溯，递归参数为当前和，当前结点，target，如果当前结点为空并且当前和==target则存在，否则回溯</strong></p>
<ol start="79">
<li>72.编辑距离<br>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</li>
</ol>
<p><strong>关键点：困难dp，建议跳过。假设dp(i)(j)表示word1[i]转化到word2[j]的最少操作数，则if word1[i] == word2[j]，dp(i)(j)= dp(i-1)(j-1)，否则dp(i)(j) = min(dp(i-1)(j) + 1, dp(i-1)(j-1) + 1, dp(i)(j-1) + 1)。需要处理i=0和j=0的边界条件</strong></p>
<ol start="80">
<li>19.删除链表的倒数第n个节点<br>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>进阶：你能尝试使用一趟扫描实现吗</li>
</ol>
<p><strong>关键点：双指针，快指针先走n-1步，注意判断结点个数是否大于n，如果小于则无法删除，如果刚好等于n则删除头结点，否则fast和slow指针同时移动找到要删除结点的前一个结点，删除目标结点</strong></p>
<ol start="81">
<li>153.寻找旋转排序数组中的最小值<br>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。<br>请找出其中最小的元素。<br>输入：nums = [3,4,5,1,2]<br>输出：1</li>
</ol>
<p><strong>关键点：可以采用减治法，可以看出序列以nums[0]为划分，前半部分递增，后半部分递增，所以nums[mid] &gt; nums[0]时当前位置一定不是解，且解在右侧，则l=mid+1；否则r=mid</strong></p>
<ol start="82">
<li>31.下一个排列<br>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>必须 原地 修改，只允许使用额外常数空间。<br>输入：nums = [1,2,3]<br>输出：[1,3,2]</li>
</ol>
<p><strong>关键点：先从右向左遍历找出最大索引k满足nums[k] &lt; nums[k + 1]，如果不存在就反转整个数组；然后从右向左找出最大索引l满足nums[l] &gt; nums[k]；交换nums[l]和nums[k]；最后反转nums[k+1:]</strong></p>
<ol start="83">
<li>24.两两交换链表中的节点<br>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换<br>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]</li>
</ol>
<p><strong>关键点：k个一组交换结点的特例，k=2，2个一组作为交换单位，记录当前交换区间的前一个结点，找到区间的末尾结点（如果遇到链表尾就结束）和区间的后一个结点，交换区间内的结点并与前一个结点和后一个结点构建联系</strong></p>
<ol start="84">
<li>470.用 Rand7() 实现 Rand10()<br>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。<br>不要使用系统的 Math.random() 方法。<br>输入: 1<br>输出: [7]</li>
</ol>
<p><strong>关键点：rand10应该生成1-10的概率均为0.1，而rand7生成1-7的概率是1/7，需要对概率进行一个均摊。调用两次rand7可以产生1-49，则可以丢弃大于40的数字（重新生成随机数），即产生1-40的概率相等。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> row, col, idx;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  row = rand7();</span><br><span class="line">  col = rand7();</span><br><span class="line">  idx = col + (row - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (idx &gt; <span class="number">40</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + (idx - <span class="number">1</span>) % <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ol start="85">
<li>82.删除排序链表中的重复元素 II<br>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字<br>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5</li>
</ol>
<p><strong>关键点：对于每个结点，记录该节点的前一个结点，向后遍历确认是否存在重复，如果有重复则遍历到重复的最后一个结点，删除这区间的所有节点，如果无重复则继续遍历。实现细节：使用一个dummy结点作为虚拟头，指向head</strong></p>
<ol start="86">
<li>162.寻找峰值<br>峰值元素是指其值大于左右相邻值的元素。<br>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。<br>你可以假设 nums[-1] = nums[n] = -∞<br>输入：nums = [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。</li>
</ol>
<p><strong>关键点：找到一个索引i满足nums[i - 1] &lt; nums[i] &gt; nums[i + 1]，注意对边界0和n-1的处理，因为默认外层是负无穷，所以只需要比一个大</strong></p>
<ol start="87">
<li>136.只出现一次的数字<br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素<br>输入: [2,2,1]<br>输出: 1</li>
</ol>
<p><strong>关键点：使用异或实现，两个相同数字的异或结果为0，所以需要对数组内的所有数字求异或，最终只有单独出现一次的数字保留下来，2次的会被消除为0</strong></p>
<ol start="88">
<li>129.求根节点到叶节点数字之和<br>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：<br>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。<br>叶节点 是指没有子节点的节点。</li>
</ol>
<p><strong>关键点：回溯算法，记录当前结点，从根节点遍历到当前结点的路径记录（可以使用StringBuilder实现），当前节点为空时表示遍历完，记录sb中保存的数字转化为int并加到结果上</strong></p>
<ol start="89">
<li>328.奇偶链表<br>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。<br>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</li>
</ol>
<p><strong>关键点：简单做法：可以使用两个虚拟链表头，分别连接奇数位结点和偶数位结点，在分离完成后，将两个链表拼到一起</strong></p>
<ol start="90">
<li>22.括号生成<br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</li>
</ol>
<p><strong>关键点：回溯算法，记录当前生成的左括号个数，右括号个数，生成序列（sb实现），当前递归层需要判断是否可以继续添加左括号和右括号，如果左括号个数 &lt; n则可以添加左括号并进入下层递归，如果右括号个数 &lt; 左括号个数则可以添加右括号进入下层递归。当左右括号均生成n个则添加到解中</strong></p>
<ol start="91">
<li>122.买卖股票的最佳时机 II<br>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</li>
</ol>
<p><strong>关键点：不限定交易次数，并且每天的状态有持有股票和不持有股票两种状态，所以动态规划可以设holder[i]表示第i天持有股票的最大利润，sailor[i]表示第i天不持有股票的最大利润，则转移方程：holder[i] = max(holder[i - 1], sailor[i - 1] - price[i])，sailor[i] = max(sailor[i - 1], holder[i - 1] + price[i])，初始化holder[0] = -price[0]表示买入第一天的股票</strong></p>
<ol start="92">
<li>7.整数反转<br>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</li>
</ol>
<p><strong>关键点：逐位拆分并记录到栈，然后依次弹出栈构造结果整数</strong></p>
<ol start="93">
<li>322.零钱兑换<br>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br>你可以认为每种硬币的数量是无限的。<br>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1</li>
</ol>
<p><strong>关键点：一开始很容易当前贪心做，但是贪心无法保证得到解。正确做法是01背包，设dp[i]表示凑到总额i时所需的最少硬币数，则dp[i] = min(dp[i], dp[i - coin] + 1)。主要01背包的模板，对物体的选择（这里是硬币）放在外层循环</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for (int coin : coins) &#123;</span><br><span class="line"></span><br><span class="line">  for (int i = 1;i &lt;= amount;i++) &#123;</span><br><span class="line"></span><br><span class="line">​    if (i &gt;= coin &amp;&amp; dp[i - coin] &lt; Integer.MAX_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">​      dp[i] = Math.min(dp[i], dp[i - coin] + 1);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="94">
<li>76.最小覆盖子串<br>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案<br>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”</li>
</ol>
<p><strong>关键点：滑动窗口模板题。使用一个map记录目标串的字符个数，一个map记录当前窗口内的字符个数，窗口如果不包含目标串则右指针右移，当满足条件时移动左指针移除左侧字符，并更新解，直到窗口不满足。模板</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">while (r &lt; n) &#123;</span><br><span class="line"></span><br><span class="line">  window记录s[r]</span><br><span class="line"></span><br><span class="line">  r++</span><br><span class="line"></span><br><span class="line">  while (window满足条件) &#123;</span><br><span class="line"></span><br><span class="line">​    更新解</span><br><span class="line"></span><br><span class="line">​    window删除s[l]</span><br><span class="line"></span><br><span class="line">​    l++</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="95">
<li>59.螺旋矩阵 II<br>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</li>
</ol>
<p><strong>关键点：从最外层向最内层逐层生成，一定要区分n是奇数和偶数的情况</strong></p>
<ol start="96">
<li>198.打家劫舍<br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额</li>
</ol>
<p><strong>关键点：偷当前房时要保证前一个房没偷，设dp[i]表示偷到第i间房的最大价值，则dp[i] = max(dp[i - 1], dp[i - 2] + price[i])，第一个表示偷了第i-1家，第二家表示偷当前家，所以前一家不能偷</strong></p>
<ol start="97">
<li>32.最长有效括号<br>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。<br>输入：s = “(()”<br>输出：2<br>解释：最长有效括号子串是 “()”</li>
</ol>
<p><strong>关键点：做法1：动态规划，设dp[i]表示第i位结束时形成的最长有效括号长度，只有）结尾时可能有效。</strong><br><strong>做法2：两次遍历，第一次从左到右，记录左括号和右括号的个数，当left==right时更新解，当right&gt;left时表示当前序列非法，重置left,right。第二次从右到左，方法类似，只是left、right互换，两次遍历的最大值即为解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 做法1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">​      dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; dp[i - <span class="number">1</span>] &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">​      dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + (i - dp[i - <span class="number">1</span>] &gt;= <span class="number">2</span>? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    ans = Math.max(ans, dp[i]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="98">
<li>695.岛屿的最大面积<br>给定一个包含了一些 0 和 1 的非空二维数组 grid 。<br>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</li>
</ol>
<p><strong>关键点：dfs，回溯。对于每个岛，从一个陆地开始遍历所有岛的陆地并打上不同的标记，并记录当前岛的陆地数量，在遍历一个岛完成后更新解。</strong></p>
<ol start="99">
<li>179.最大数<br>给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。<br>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>输入：nums = [10,2]<br>输出：”210”</li>
</ol>
<p><strong>关键点：自定义排序函数cmp(int a, int b) {return (String(a)+String(b)) - String(b+a)；}</strong></p>
<ol start="100">
<li>43.字符串相乘<br>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。<br>输入: num1 = “2”, num2 = “3”<br>输出: “6”</li>
</ol>
<p><strong>关键点：将任务拆分，划分成字符串与单个数字相乘，并保留所有相乘结果并根据数为补0，最后将所有结果累加。即划分为单字符与字符串相乘，以及字符串加法</strong></p>
<ol start="101">
<li>138.复制带随机指针的链表<br>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</li>
</ol>
<p><strong>关键点：将所有链表结点复制一份（包括random指针）并插入其后，然后遍历捡出所有的新复制的结点（偶数位）</strong></p>
<ol start="102">
<li>460.LFU 缓存<br>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</li>
</ol>
<p><strong>关键点：LRUcache基础上修改，结点多加一个值存储访问次数，在每次访问或添加新节点时，将该节点放入到相同访问次数的所有节点之后，次数-1的所有节点之前</strong></p>
<ol start="103">
<li>排序奇升偶降链表<br>给定一个奇数位升序，偶数位降序的链表，将其重新排序。<br>输入: 1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;NULL<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL</li>
</ol>
<p><strong>关键点：首先对奇数位结点和偶数位结点进行拆分得到一个升序和降序链表，对降序链表进行逆转，得到升序链表，将两个链表合并得到有序</strong></p>
<ol start="104">
<li>209.长度最小的子数组<br>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。<br>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li>
</ol>
<p><strong>关键点：滑动窗口模板题，</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">while (r &lt; n) &#123;</span><br><span class="line"></span><br><span class="line">  window记录s[r]</span><br><span class="line"></span><br><span class="line">  r++</span><br><span class="line"></span><br><span class="line">  while (window满足条件) &#123;</span><br><span class="line"></span><br><span class="line">​    更新解</span><br><span class="line"></span><br><span class="line">​    window删除s[l]</span><br><span class="line"></span><br><span class="line">​    l++</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="105">
<li>剑指 Offer 10- II. 青蛙跳台阶问题<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法</li>
</ol>
<p><strong>关键点：斐波那契数列，dp[i] = dp[i - 1] + dp[i - 2]，注意优化到O(1)空间</strong></p>
<ol start="106">
<li>394.字符串解码<br>给定一个经过编码的字符串，返回它解码后的字符串。<br>输入：s = “3[a]2[bc]”<br>输出：”aaabcbc”</li>
</ol>
<p><strong>关键点：递归实现，需要一个全局变量记录当前字符位置。遇到数字统计数字，遇到字符添加字符，遇到’[‘进入深层递归，并根据返回结果构造对应字符，遇到’ ]’返回当前构造得到的字符串</strong></p>
<ol start="107">
<li>224.基本计算器<br>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值<br>输入：s = “(1+(4+5+2)-3)+(6+8)”<br>输出：23</li>
</ol>
<p><em><em>关键点：使用一个栈记录此前的计算结果，遇到数字统计数字，遇到空格跳过，遇到+-将当前值放入栈，遇到</em>/取出栈顶元素与当前数字做操作并放入栈。遇到(进入递归，遇到)结束递归</em>*</p>
<ol start="108">
<li>189.旋转数组<br>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</li>
</ol>
<p><strong>关键点：先计算k%n得到需要移动的位置，再划分为两部分互换，使用python好实现</strong></p>
<ol start="109">
<li>剑指 Offer 51. 数组中的逆序对<br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>输入: [7,5,6,4]<br>输出: 5</li>
</ol>
<p><strong>关键点：利用归并排序的做法，在做归并排序时统计逆序对的个数。如果左侧数组当前元素大于右侧数组当前元素，则逆序对个数为右侧数组剩余元素个数</strong></p>
<ol start="110">
<li>145.二叉树的后序遍历<br>给定一个二叉树，返回它的 后序 遍历。</li>
</ol>
<p><strong>关键点：可以使用栈，弹出栈顶，将当前节点放入到结果序列中，然后先放入右子节点再放入左子节点（如果存在）。则得到的结果序列是后序遍历的逆序，进行翻转即可。</strong></p>
<h3 id="这里开始是力扣Hot100"><a href="#这里开始是力扣Hot100" class="headerlink" title="这里开始是力扣Hot100"></a>这里开始是力扣Hot100</h3><ol start="111">
<li>1.两数之和<br>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。<br>示例 1：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</li>
</ol>
<p><strong>关键点：注意到数组是无序的，无法使用双指针。除了暴力（双重循环之外），只有使用哈希表存储每个数字出现位置，一次遍历查找target-nums[i]是否出现在哈希表中，需要注意如果target=2*nums[i]时nums[i]要在哈希表中出现2次</strong></p>
<ol start="112">
<li>2.两数相加<br>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</li>
</ol>
<p><strong>关键点：链表的求和，好在已经是逆序，遍历两个链表直接相加，需要额外记录进位，直到一个链表遍历完成，如果进位为1则继续加进位，如果为0则讲剩余链表接到答案后即可</strong></p>
<ol start="113">
<li>10.正则表达式匹配<br>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘<em>‘ 的正则表达式匹配。<br>‘.’ 匹配任意单个字符<br>‘</em>‘ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。<br>示例 1：<br>输入：s = “aa” p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。</li>
</ol>
<p><strong>关键点：hard题。关键是对’.’,’*’和普通字符区分。假设dp[i][j]表示s和p从0开始长度为i，j是否匹配的结果，则</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p[j-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line"></span><br><span class="line">  dp[i][j] = dp[i][j-<span class="number">2</span>]; <span class="comment">//匹配零个前面的那一个元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p[j-<span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span> || s[i-<span class="number">1</span>]==p[j-<span class="number">2</span>]):</span><br><span class="line"></span><br><span class="line">​    dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];  <span class="comment">//&#x27;*&#x27;匹配一个前面的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> p[j-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> || s[i-<span class="number">1</span>] == p[j-<span class="number">1</span>]:</span><br><span class="line"></span><br><span class="line">​    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];  <span class="comment">//当前字符匹配，则看之前状态</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">​    dp[i][j] = <span class="literal">false</span>;  <span class="comment">//字符不匹配，一定无解</span></span><br></pre></td></tr></table></figure>

<ol start="114">
<li>11.盛最多水的容器<br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</li>
</ol>
<p><strong>关键点：类似于接雨水，接水量由最短边决定，即l,r形成的容器接水量为(r-l) * min(h[l],h[r])，所以双指针遍历，将更短的边对应移动，试图找到更长的边，并且在遍历阶段更新解。</strong></p>
<ol start="115">
<li>17.电话号码的字母组合<br>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母</li>
</ol>
<p><strong>关键点：构建一个数字到字符的映射表，根据输入的数字，回溯构造结果串，即遍历完最后一个数字时记录结果，dfs(String s, int idx, List<String> ans, StringBuilder path)</strong></p>
<ol start="116">
<li>49.字母异位词分组<br>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。<br>示例:<br>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出:<br>[<br>[“ate”,”eat”,”tea”],<br>[“nat”,”tan”],<br>[“bat”]<br>]</li>
</ol>
<p><strong>关键点：对每个单词排序得到最小字典序，以最小序为key放入Map中，所有在同一key中的单词为异位词</strong></p>
<ol start="117">
<li>55.跳跃游戏<br>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。<br>示例 1：<br>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标</li>
</ol>
<p><strong>关键点：维护一个可以到达的最大位置，如果大于等于n-1则可以到达，如果当前位置已经是最大位置且nums[i]==0则无法继续前进，返回false，更新最大位置step=max{step, nums[i]+i}</strong></p>
<ol start="118">
<li>75.颜色分类<br>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>示例 1：<br>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]</li>
</ol>
<p><strong>关键点：荷兰旗算法，双指针从左右开始，分别记录当前应该插入0和2的位置，从左到右遍历，如果当前是0则插入到l指针位置，如果是2则插入到r指针位置</strong></p>
<ol start="119">
<li>79.单词搜索<br>给定一个二维网格和一个单词，找出该单词是否存在于网格中。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</li>
</ol>
<p><strong>关键点：接近DFS模板，dfs(word, board, x, y, visited)先判断是否越界或者是否访问过或者当前字符是否word的下一个目标字符，如果是则标志已访问，继续下一层递归，注意递归完成后因为每个单词不重叠，之前标志已访问需要回溯到未访问，以便下一个单词继续查找。</strong></p>
<ol start="120">
<li>84.柱状图中最大的矩形，hard<br>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br>输入: [2,1,5,6,2,3]<br>输出: 10</li>
</ol>
<p>*<em>关键点：对于当前高度，向左右遍历找到第一个小于该高度的位置，则此区间内的矩形面积为(r-l-1)<em>height[i]，所以问题转化为优化每个位置从左和向右遍历找到第一个小的位置，可以使用单调栈（从栈底到栈顶递增），对于每个位置，找到第一个小于该高度的位置即为目标位置，并将当前位置放入栈用于后续遍历</em></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!stack.empty() &amp;&amp; heights[i] &lt;= heights[stack.peek()]) &#123;</span><br><span class="line"></span><br><span class="line">​    stack.pop();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  left[i] = stack.empty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line"></span><br><span class="line">  stack.push(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="121">
<li>85.最大矩形，hard<br>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</li>
</ol>
<p><strong>关键点：求得m[i][j]位置处左侧连续1的个数作为宽度，对于每个位置，向上向下遍历找最小宽度并同时得到高度，求最大面积。做法和上题类似，只是遍历方式从向左右变为向上下，找到第一个小于当前记录宽度的位置，可求得最大面积</strong></p>
<ol start="122">
<li>96.不同的二叉搜索树<br>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</li>
</ol>
<p><em><em>关键点：对于以i为根节点的子树，左子树为[1:i-1]形成的子树，右子树为[i+1:n]形成的子树，故设dp[i]表示以[1:i]为节点组成的BST种类，则dp[i] = 2sum{dp[j]</em>  dp[i - j - 1]},0 &lt;= j &lt; i/2;并且i为奇数时还要额外加上dp[i/2]dp[i/2]</em>*</p>
<ol start="123">
<li>114.二叉树展开为链表<br>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>
</ol>
<p><strong>关键点：对于当前子树的根节点，如果左子节点存在，则将根节点的右子树整个拼接到左子节点之后，并修改左子节点为根的右子节点，直到根节点遍历完成。如果不存在则从右子节点开始继续做上述操作</strong></p>
<ol start="124">
<li>124.二叉树的最大路径和<br>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br>路径和 是路径中各节点值的总和。<br>给你一个二叉树的根节点 root ，返回其 最大路径和 </li>
</ol>
<p><strong>关键点：使用一个全局变量记录最大值，对于每个子树的根节点，当前的最大值为max(ans, root.val + max(dfs(root.left), 0) + max(dfs(root.right), 0))，但向上返回时由于只能选择一个子树作为路径并且一定要包含根节点作为连接点，所以返回的值为root.val + max(leftMax, rightMax)。</strong></p>
<ol start="125">
<li>139.单词拆分<br>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</li>
</ol>
<p><strong>关键点：假设dp[i]表示以s[i]结尾的字符串是否可以拆分，则dp[i] = true如果存在一个j &lt; i且满足s[j:i]在字典中且dp[j-1]==true，并且只要存在一个满足的即可跳出循环求i+1</strong></p>
<ol start="126">
<li>152.乘积最大子数组<br>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<br>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</li>
</ol>
<p><strong>关键点：因为数组中含有负数，负负得正，所以需要记录最小值（负数），在遇到负数后可以得到最大乘积。dp1[i],dp2[i]分别表示以nums[i]结尾得到的最大、最小乘积，则dp1[i] = max(nums[i], max(dp1[i-1] * nums[i], dp2[i-1] * nums[i]))，dp2[i] = max(nums[i], max(dp1[i-1] * nums[i], dp2[i-1] * nums[i]))，在遍历时更新最大值为ans=max(ans, dp1[i])</strong></p>
<ol start="127">
<li>207.课程表<br>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。<br>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。<br>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。<br>输入：numCourses = 2, prerequisites = [[1,0]]<br>输出：true<br>解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</li>
</ol>
<p><strong>关键点：拓扑排序，即学一门课之前要先学别的课作为限制，BFS做法，记录每个结点的入度，将入度为0的点作为起始点放入队列，队列非空时每次从队列取出队首元素，记录到路径，并将相邻结点的入度减1，如果相邻结点的入度为0则加入到队列。当队列空时如果遍历完所有节点则路径为所求，否则存在环</strong></p>
<ol start="128">
<li>208.实现Trie<br>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。<br>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li>
</ol>
<p><strong>关键点：字典树，每个节点具有26个子节点，以及标志位表示从根到当前结点的单词是否为完整单词。插入时如果当前字符对应结点不存在则新建结点，插入到最后一个字符时在该节点处标志end，搜索时从根节点开始，如果某个字符对应的子节点不存在或者到达单词末尾字符的结点没有标志end则该单词不存在</strong></p>
<ol start="129">
<li>221.最大正方形<br>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</li>
</ol>
<p><strong>关键点：假设dp[i][j]表示是以m[i][j]为右下角所能得到的最大正方形，则如果m[i][j]==1，则dp[i][j] = min(dp[i-1][j], min(dp[i-1][j-1],dp[i][j-1])) + 1，更新期间使用变量维护出现过的最大dp[i][j]</strong></p>
<ol start="130">
<li>238.除自身之外数组的乘积<br>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。<br>输入: [1,2,3,4]<br>输出: [24,12,8,6]</li>
</ol>
<p><strong>关键点：普通做法，使用前缀积pre[i]表示nums[0:i]的乘积，后缀积post[i]表示nums[i:n-1]的乘积，对于每个位置，不包含他的乘积为pre[i - 1] * post[i + 1]。进阶：只记录前缀积，在计算后缀积时不存储到post数组中，而是直接更新到前缀积的结果上，需要额外使用一个变量记录末尾数字到当前位置的连续积</strong></p>
<ol start="131">
<li>279.完全平方数<br>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。<br>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。<br>输入：n = 12<br>输出：3<br>解释：12 = 4 + 4 + 4</li>
</ol>
<p><strong>关键点：找最小个数或次数都可以考虑BFS，本题从n开始，每次遍历当前队列，需要数字个数+1，如果某个元素的值刚好是平方数，则返回当前个数，否则将剩下需要构建的值加入到下一个队列，下次循环时对下一个队列进行遍历。因为要判断一个数是否为平方数，可以预处理，将小于等于n的所有平方数放入set中，O(1)查询</strong></p>
<ol start="132">
<li>283.移动零<br>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</li>
</ol>
<p><strong>关键点：双指针，l记录当前应该交换的位置，r记录当前遍历位置，因为要保持原序，每当遇到一个非0数字都应该交换到l位置（为后续的0腾出位置），而不是单纯与0位置交换</strong></p>
<ol start="133">
<li>287.寻找重复数<br>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。<br>输入：nums = [1,3,4,2,2]<br>输出：2</li>
</ol>
<p><strong>关键点：类似于链表判断环是否存在，可以将数组索引及对应位置值考虑为链表，nums[i]表示i下一个结点位置，定义fast=0,slow=0每次fast走两步，slow走一步，fast=nums[nums[fast]],slow=nums[slow]。找到相等位置后令fast=0开始找到第一个相等的位置即为重复元素</strong></p>
<ol start="134">
<li>297.二叉树的序列化与反序列化<br>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</li>
</ol>
<p><strong>关键点：对于空节点插入特殊字符，并保证采用同一种遍历方式如前序遍历。序列化做法是在遍历到空节点时添加特殊字符到结果，其余同前序遍历，反序列化是以”,”隔开，遇到有效值则继续构造节点，遇到特殊字符则返回null。</strong></p>
<ol start="135">
<li>301.删除无效的括号，hard<br>给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。<br>返回所有可能的结果。答案可以按 任意顺序 返回<br>输入: “()())()”<br>输出: [“()()()”, “(())()”]</li>
</ol>
<p><strong>关键点：题目要求删除最小数量的无效括号，可以通过一次遍历求出需要删除的左括号和右括号的个数，则所有结果都是删除这些数量的括号。然后回溯算法求所有合法的括号序列，对于每个左右括号递归搜索不包含和包含的结果。dfs(s, idx, leftCount, rightCount, leftRemain, rightRemain, sb)leftCount表示当前使用的左括号，leftRemain表示还需要删除的左括号，right同理，记录结果时需要记录到set中去重。</strong></p>
<ol start="136">
<li>309.买卖股票最佳时机含冷冻期<br>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:<br>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</li>
</ol>
<p><strong>关键点：设holder[i], sailor[i]分别表示到第i天时持有股票和不持有股票的最大利润，则holder[i] = max(holder[i-1], sailor[i - 2] - prices[i])，表示要么上一天持有股票，要么前天卖出，今天买入（需要一天冷冻期），sailor[i] = max(sailor[i - 1], holder[i] + prices[i])表示要么前一天不持有，要么昨天持有今天卖出</strong></p>
<ol start="137">
<li>312.戳气球，hard<br>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。<br>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。<br>求所能获得硬币的最大数量。<br>示例 1：<br>输入：nums = [3,1,5,8]<br>输出：167<br>解释：<br>nums = [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; []<br>coins = 315  +  358  + 138 + 181 = 167</li>
</ol>
<p><strong>关键点：区间DP，假设dp[i][j]表示区间[i:j]内能获得的最大分数，则对于i &lt; k &lt; j，打破气球[i:k-1]和[k+1:j]时还剩下气球i,j,k，可以得到的分数为n[i]n[k]n[j]，故dp[i][j] = max(dp[i][k-1] + dp[k+1][j] + n[i]n[k]n[j])，i &lt; k &lt; j</strong></p>
<ol start="138">
<li>337.打家劫舍III<br>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。<br>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</li>
</ol>
<p><strong>关键点：不能打劫连续的结点，即如果选择根节点，则根节点的左右子节点都无法选择，只能选左右子节点的子节点。故对于当前根节点，记录左右子树能得到的最大值（分为包含左右子节点和不包含），则当前结点的结果为，包含根节点的最大值=root.val + 不包含左子节点的最大值 + 不包含右子节点的最大值，不包含根节点的最大值 = max(不包含左子节点的最大值, 包含左子节点的最大值) + max(不包含右子节点的最大值, 包含右子节点的最大值)</strong></p>
<ol start="139">
<li>338.比特位计数<br>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。<br>输入: 2<br>输出: [0,1,1]</li>
</ol>
<p><strong>关键点：普通做法：暴力。通过n&amp;(n-1)可以消除n中最低位的1，所以循环消除，统计消除的次数即为n中1的个数。dp做法：记录最低有效位，设dp[i]表示数字i中1的个数，则i为奇数时，dp[i] = dp[i/2] + 1,i为偶数时，dp[i] = dp[i/2]。统一一下dp[i] = dp[i/2] + (i&amp;1)。</strong></p>
<ol start="140">
<li>347.前k个高频元素<br>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。<br>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</li>
</ol>
<p><strong>关键点：记录出现频率，然后找前k大的。可以使用最小堆维护，也可以使用partition实现，但需要注意的是partition时移动的是整个结点（包含数字和频率），对频率排序</strong></p>
<ol start="141">
<li>399.除法求值（略）<br>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。<br>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</li>
</ol>
<p><strong>关键点：并查集，在构建并查集连接关系时更新对应权重。</strong></p>
<ol start="142">
<li>406.根据身高重建队列<br>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。<br>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</li>
</ol>
<p><strong>关键点：对所有人按照身高降序排序，如果身高相等则按照k升序排列。然后遍历排序后的数组，按照k插入到正确的位置。这样在插入时可以保证同等k的人在一起并且身高是升序排列，不会打破k的约束关系。例如[[5,0], [7,0]]排序后得到[[7,0], [5,0]]，先插入[7,0]，再插入[5,0]得到[[5,0], [7,0]]满足k的约束关系</strong></p>
<ol start="143">
<li>416.分割等和子集<br>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].</li>
</ol>
<p><strong>关键点：先求和判断是否是偶数（奇数不可分），然后采用01背包的做法，假设dp[i][j]表示从nums[0:i]中选取若干整数是否存在使其整数和为j的方案。如果不选nums[i]dp[i][j] = dp[i-1][j]，如果要选nums[i]，则dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]，注意j-nums[i]&gt;=0的边界处理</strong></p>
<ol start="144">
<li>437.路径总和III<br>给定一个二叉树，它的每个结点都存放着一个整数值。<br>找出路径和等于给定数值的路径总数。<br>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</li>
</ol>
<p><strong>关键点：因为不需要从根节点开始叶子结点结束，所以不能采用常规回溯做法。可以使用前缀和，对于遍历到当前结点，如果target-root.val在前缀和中出现过n次，则表明此前有n条路径加上当前结点可以得到目标和，记录到结果中，并且将当前结对对应的前缀和记录到前缀和字典中</strong></p>
<ol start="145">
<li>438.找到字符串中所有字母异味词<br>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。<br>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。<br>说明：<br>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。<br>示例 1:<br>输入:<br>s: “cbaebabacd” p: “abc”<br>输出:<br>[0, 6]</li>
</ol>
<p><strong>关键点：滑动窗口，需要记录窗口内字符的个数，每次滑动时都比较一下是否与p构成异位词</strong></p>
<ol start="146">
<li>448.找到所有数组中消失的数字<br>给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。<br>找到所有在 [1, n] 范围之间没有出现在数组中的数字。<br>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</li>
</ol>
<p><strong>关键点：对于每个数字nums[i]将其交换到对应索引nums[i]-1的位置（每次交换应该是一次while循环，直到nums[i]-1 == nums[nums[i]-1]，第二次遍历记录每个nums[i] != i+1的位置即为结果</strong></p>
<ol start="147">
<li>461.汉明距离<br>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。<br>给出两个整数 x 和 y，计算它们之间的汉明距离。<br>注意：<br>0 ≤ x, y &lt; 231</li>
</ol>
<p><strong>关键点：先求x与y的异或，然后求异或结果中1的个数，使用n&amp;(n-1)可以消除最低位的1，统计消除了多少次n变为0</strong></p>
<ol start="148">
<li>494.目标和<br>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。<br>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</li>
</ol>
<p><strong>关键点：递归做的话每个符号可以加+或者-，复杂度O(2^n)。且其中有很多重复子问题，考虑使用动态规划。设dp[i][j]表示添加到第i个符号时得到j的方案数，因为可以全加负号，所以需要设dp[n][2001]，2000是因为最小是-1000，最大是1000。然后同01背包问题，dp[i][j + nums[i] + 1000] += dp[i-1][j+1000]，表达式中加1000是防止为负数。dp[i][j - nums[i] + 1000] += dp[i - 1][j + 1000]。</strong></p>
<ol start="149">
<li>538.把二叉搜索树转化为累加树<br>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。<br>提醒一下，二叉搜索树满足下列约束条件：<br>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</li>
</ol>
<p><strong>关键点：求大于等于该结点的值之和，需要先遍历右子树再遍历左子树，并记录此前出现过的和。遍历右子树完成后，更新当前根节点的值加上此前出现过的和，并更新此前和加上根节点值，继续遍历左子树</strong></p>
<ol start="150">
<li>560.和为k的子数组<br>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。<br>示例 1 :<br>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</li>
</ol>
<p><strong>关键点：记录前缀和，假设nums[i:j]和为k，则pre[i]-pre[j-1]=k,即pre[j-1]=pre[i]-k，对于当前前缀和sum，统计sum-k的出现次数n，则存在n个位置，从这个位置x开始sum[x:j]和为k</strong></p>
<ol start="151">
<li>581.最短无序连续子数组<br>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。<br>请你找出符合题意的 最短 子数组，并输出它的长度。<br>示例 1：<br>输入：nums = [2,6,4,8,10,9,15]<br>输出：5<br>解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</li>
</ol>
<p><strong>关键点：做法1：对数组排序，从左右开始分别比较，第一个不一样的数字即为边界位置；做法2：分别从左右开始遍历，每个方向2次遍历，以从左到右为例，第一次遍历记录当出现了不满足递增情况出现时，数组中的最小值，然后第二次遍历找到数组中第一个大于这个最小值的位置，则为需要排序的左边界，右边同理</strong></p>
<ol start="152">
<li>617.合并二叉树<br>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。<br>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</li>
</ol>
<p><strong>关键点：对树进行遍历，对于结点都存在的累计和，对于一个不存在的以存在的结点代替，对于都不存在的返回null。递归遍历时同时进入t1,t2的左子树和右子树</strong></p>
<ol start="153">
<li>621.任务调度器<br>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。<br>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。<br>你需要计算完成所有任务所需要的 最短时间 。<br>示例 1：<br>输入：tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2<br>输出：8<br>解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B<br>在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </li>
</ol>
<p><strong>关键点：窗口长度n的任务列表中不能有重复任务，采用贪心思想，首先对数量最多的任务安排，并且在这两者之间插入尽可能多的其他任务。统计每个任务的数量freq，并降序排序，在任务安排完之前，安排数量最多的任务，然后安排第二多第三多…直到排够n个任务或者不够n个则加待命时间。在每次排完当前窗口任务之后重新排序。</strong></p>
<ol start="154">
<li>647.回文子串<br>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。<br>输入：”abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</li>
</ol>
<p><strong>关键点：类似于求最长回文串，以每个字符为中心（奇数）和每两个字符为中心（偶数串）向外扩展，每扩展一步则表明存在一个不同的回文字串，记录到结果中</strong></p>
<ol start="155">
<li>739.每日温度<br>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</li>
</ol>
<p><strong>关键点：求当前位置i之后第一个大于nums[i]的位置差，可以使用单调栈，保持从栈底到栈顶递减，如果遇到温度小于栈顶则入栈，否则一直弹出，在弹出时记录弹出的位置对应天数为当前遇到的温度减栈顶弹出的位置，完成记录后将当前位置放入到栈中</strong></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol start="156">
<li>不使用+ -求和<br>以十进制为例，5+7<br>1）相加个位值，不算进位，得到2<br>2）计算进位值，得到10，如果这里进位为0，第一步的值是结果<br>3）重复上述2步，值变为2+10，得到12<br>转换成二进制运算，101 + 111<br>1）个位相加，等同于二进制的异或操作，101^111 = 010<br>2）求进位，等同于二进制求与操作再左移一位,(101&amp;111)&lt;&lt;1 = 1010<br>3）重复上述2步，变为010 + 1010，个位相加010^1010=1000，求进位(010&amp;1010)&lt;&lt;1 = 100<br>4）重复第1,2步，变为100 + 1000，个位数相加为100 ^ 1000 = 1100，进位(100&amp;1000)&lt;&lt;1 = 0，结束，结果为1100</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a ^ b;</span><br><span class="line">    b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    a = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="157">
<li>扁平化嵌套迭代器<br>给定一个类，构造输入嵌套列表，比如[[1,2],3,[4,5]]，需要做成迭代器，具有hasNext()和next()两个方法</li>
</ol>
<p><strong>做法1：构造时递归，将嵌套列表直接摊平，放到一个list中，复杂度O(n)，但迭代器不需要一开始就得到所有数据，应该做到随用随生<br>做法2:（面试应该做的方法）避免构造时直接摊平，而是用栈来模拟递归，因为栈是先进后出，需要一开始将列表逆序放入栈中，在hasNext方法中取出栈顶，判断是整数还是列表，如果是整数直接返回true，否则将列表打开，重新逆序放入到栈中。而next方法只需弹出当前栈顶元素。也可以使用迭代器模式放入栈中，则开始将迭代器<list>放入栈，在hasNext方法中取出栈顶，调用isNex判断是否为最后一个元素，如果是弹出栈顶并继续。否则取出栈顶元素的next元素，如果是整数则重新构造一个迭代器放入栈中，并返回true，否则取出栈顶元素的list元素并构造出迭代器放入栈。这么做是为了避免[[]]的形式，当出现嵌套空列表时需要打开看看是否存在元素才能返回hasNext为true</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Iterator&lt;NestedInteger&gt;&gt; stack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(nestedList.iterator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek().next().getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Iterator&lt;NestedInteger&gt; it = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (!it.hasNext()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">NestedInteger</span> <span class="variable">nest</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span> (nest.isInteger()) &#123;</span><br><span class="line">                List&lt;NestedInteger&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">                list.add(nest);</span><br><span class="line">                stack.push(list.iterator());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nest.getList().iterator());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/interview/" rel="tag"># 面经</a>
              <a href="/tags/algorithm-problem/" rel="tag"># 算法题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/21/%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/" rel="prev" title="概率问题">
      <i class="fa fa-chevron-left"></i> 概率问题
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/" rel="next" title="数据库总结">
      数据库总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#codetop%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">1.</span> <span class="nav-text">codetop高频题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E6%98%AF%E5%8A%9B%E6%89%A3Hot100"><span class="nav-number">2.</span> <span class="nav-text">这里开始是力扣Hot100</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">3.</span> <span class="nav-text">其他</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiahang Gu</p>
  <div class="site-description" itemprop="description">认真学习，享受生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JiahangGu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiahangGu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/fengzhizi76506" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;fengzhizi76506" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiahang Gu</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
