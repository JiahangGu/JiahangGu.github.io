<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="参考数据库面试题 高频面试题 怎么判断sql语句的性能，怎么分析，explain使用的时候需要关注的点是什么 介绍下InnoDB的索引实现，B+树叶子结点是单向链表还是双向链表 了解慢查询吗（不了解） 慢查询就是查询时可能查询数据涉及到的数据量或表较多导致查询速度慢的情况。常用的优化方式 可以使用explain对语句进行分析，并重点查看type, rows, keys字段查看查询类型、查询涉及到的">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库面试题">
<meta property="og:url" content="http://example.com/2022/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="菜汤里的咸鱼要翻身">
<meta property="og:description" content="参考数据库面试题 高频面试题 怎么判断sql语句的性能，怎么分析，explain使用的时候需要关注的点是什么 介绍下InnoDB的索引实现，B+树叶子结点是单向链表还是双向链表 了解慢查询吗（不了解） 慢查询就是查询时可能查询数据涉及到的数据量或表较多导致查询速度慢的情况。常用的优化方式 可以使用explain对语句进行分析，并重点查看type, rows, keys字段查看查询类型、查询涉及到的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-21T04:18:01.000Z">
<meta property="article:modified_time" content="2022-02-21T05:00:20.038Z">
<meta property="article:author" content="Jiahang Gu">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="DataBase">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据库面试题 | 菜汤里的咸鱼要翻身</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">菜汤里的咸鱼要翻身</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-21 12:18:01 / 修改时间：13:00:20" itemprop="dateCreated datePublished" datetime="2022-02-21T12:18:01+08:00">2022-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/babylovewei/article/details/106711013">数据库面试题</a></p>
<h3 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h3><ol>
<li>怎么判断sql语句的性能，怎么分析，explain使用的时候需要关注的点是什么</li>
<li>介绍下InnoDB的索引实现，B+树叶子结点是单向链表还是双向链表</li>
<li>了解慢查询吗（不了解）<br> 慢查询就是查询时可能查询数据涉及到的数据量或表较多导致查询速度慢的情况。常用的优化方式<ol>
<li>可以使用explain对语句进行分析，并重点查看type, rows, keys字段查看查询类型、查询涉及到的数据行数以及使用的索引，并以此确定优化的方向。例如涉及到的rows远大于目标数据行，则可以通过优化查询语句减少中间数据行的数量提高效率。也可以通过keys字段查看使用索引是否正确，可以新增或修改索引。</li>
<li>修改数据库表结构，将使用频率低的表拆分出来，也可以添加中间表代替联合查询提高效率</li>
<li>将一个大的查询分解为多个小查询</li>
</ol>
</li>
<li>数据库的隔离级别</li>
<li>MVCC了解吗</li>
<li>乐观锁和悲观锁</li>
<li>InnoDB的索引方式和特点</li>
<li>什么情况下索引不可用</li>
<li>MySQL的聚簇索引和非聚簇索引的区别</li>
<li>MySQL如何实现主从复制</li>
<li>binlog、redo、undo有什么作用</li>
<li>做过索引优化吗？</li>
<li>数据库为什么使用B+树而不是B树<br>1）B树只适合随机检索，而B+树同时支持随机检索和顺序检索<br>2）B+树空间利用率更高，可减少IO次数，磁盘读写代价更低，B+树非叶子结点只保存关键字，一次性读入到内存更多的关键字，减少了IO次数，而IO读写次数是影响检索效率的最大因素<br>3）B+树查询效率更稳定。B树可能在非叶子结点结束，等价于二分查找，而B+树都需要走一条从根节点到叶子结点的路，所有查询路径长度相同，导致每一个关键字的查询效率相当<br>4）B树提高磁盘性能的同时没有解决元素遍历效率低下的问题，B+树叶子结点通过指针连在一起，优化了基于范围的查询<br>5）增删文件时B+树效率更高，叶子结点包含所有关键字，并以有序链表结构存储，可以提高增删效率</li>
<li>大表数据查询怎么优化<br>1）优化schema、sql语句+索引<br>2）加缓存，缓解数据库压力，memcached，redis<br>3）主从复制，读写分离，主库负责写和高性能读，从库读<br>4）垂直拆分，划分为分布式系统<br>5）水平切分，选择合理的分配范围和分布算法</li>
<li>为什么尽量设定一个主键<br>主键确保数据行在整个表的唯一性，在删查改操作可能加速并确保操作数据范围安全。<br>推荐使用自增id，因为主键索引作为聚簇索引存在，B+树非叶子结点存储了关键字，叶子结点存储了主键索引和全部的数据，如果自增只需向后排列，否则可能存在较多的数据插入和移动，导致产生很多的内存碎片，造成插入性能的下降<br>如果没有主键，InnoDB会选择一个唯一键生成聚簇索引，如果没有唯一键会生成隐式主键</li>
<li>存储用户密码散列使用什么字段<br>密码散列、身份证号等定长字符串使用char，可以节省空间且提高检索效率</li>
<li>MySQL数据库cpu飙升如何处理<br>1）先使用top查看是否是mysqld导致<br>2）如果是，使用show processlist查看session情况，找出消耗高的sql，观察耗费高的原因：执行计划是否准确，索引是否确实，数据库是否太大<br>3）如果存在问题，kill掉并优化对应sql语句<br>4）也可能是突然之间大量session连入，考虑使用缓存，或限制连接个数</li>
</ol>
<h3 id="Cyc高频面试题"><a href="#Cyc高频面试题" class="headerlink" title="Cyc高频面试题"></a>Cyc高频面试题</h3><p>*表示重要程度，题目摘抄自<a target="_blank" rel="noopener" href="https://github.com/liguigui/CyC2018-CS-Notes">Cyc2018</a>，答案为自己的理解</p>
<h3 id="2-手写-SQL-语句，特别是连接查询与分组查询"><a href="#2-手写-SQL-语句，特别是连接查询与分组查询" class="headerlink" title="2* 手写 SQL 语句，特别是连接查询与分组查询"></a>2* 手写 SQL 语句，特别是连接查询与分组查询</h3><ol>
<li><p>创建数据库并使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE test;</span><br><span class="line">USE test;</span><br></pre></td></tr></table></figure></li>
<li><p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    col1 INT NOT NULL DEFAULT 1,</span><br><span class="line">    col2 VARCHAR(255) NULL,</span><br><span class="line">    col3 DATE NULL,</span><br><span class="line">    PRIMARY KEY(`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>修改表<br>添加列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE mytable ADD col CHAR(20);</span><br></pre></td></tr></table></figure>
<p>删除列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE mytable DROP COLUMN col;</span><br></pre></td></tr></table></figure>
<p>删除表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE mytable;</span><br></pre></td></tr></table></figure></li>
<li><p>插入<br>普通插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mytable(col1, col2) VALUES(val1, val2);</span><br></pre></td></tr></table></figure>
<p>插入检索出的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mytable(col1, col2) SELECT col1, col2 FROM mytable2;</span><br></pre></td></tr></table></figure>
<p>将一个表的内容插入到一个新表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE newtable AS SELECT * FROM mytable;</span><br></pre></td></tr></table></figure></li>
<li><p>更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mytable SET col = val WHERE id = 1;</span><br></pre></td></tr></table></figure></li>
<li><p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM mytable WHERE id = 1;</span><br><span class="line">TRUNCATE TABLE mytable;</span><br></pre></td></tr></table></figure></li>
<li><p>查询<br>DISTINCT，相同值只会出现一次，所有列都相同才算相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT col1, col2 FROM mytable;</span><br></pre></td></tr></table></figure>
<p>LIMIT, 限制返回的行数，第一个参数为起始行，默认为0，第二个参数是返回的总行数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM mytable LIMIT 5;</span><br></pre></td></tr></table></figure></li>
<li><p>排序<br>ORDER BY ASC升序（默认），DESC降序，可以按照多个列排序，并且每个列指定不同的排序方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM mytable ORDER BY col1 DESC, col2 ASC;</span><br></pre></td></tr></table></figure></li>
<li><p>过滤<br>WHERE子句可以筛选数据，降低数据传输的开销，NULL和0、空字符串都不同。AND和OR连接多个过滤条件，优先处理AND。</p>
</li>
<li><p>通配符<br>%匹配&gt;=0个字符，_匹配一个字符，[]匹配集合内的字符， [^]不匹配集合内的字符，LIKE进行通配符匹配</p>
</li>
<li><p>计算字段<br>AS取别名，CONCAT()连接两个字段，TRIM()去除首尾空格。</p>
</li>
<li><p>函数<br>汇总: AVG(), COUNT(), MAX(), MIN(), SUM()<br>文本处理: LEFT(), RIGHT(), LOWER(), UPPER(), LTRIM(), RTRIM(), LENGTH(), SOUNDEX()转为语音值<br>日期和时间处理: ADDDATE(), ADDTIME(), CURDATE(), CURTIME(), DATE(), DATEDIFF(), DATE_ADD(), DATE_FORMAT(), DAY(), DAYOFWEEK(), HOUR(), MINUTE(), MONTH(), NOW(), SECOND(), TIME(), YEAR()<br>数值处理: SIN(), COS(), TAN(), ABS(), SQRT(), MOD(), EXP(), PI(), RAND()</p>
</li>
<li><p>分组<br>将具有相同的数据值的行放在同一组中，可以对同一分组数据使用汇总函数处理，并且自动按照该字段排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col, COUNT(*) AS num FROM mytable GROUP BY col;</span><br></pre></td></tr></table></figure>
<p>GROUP BY自动按照该字段排序，也可以按汇总字段排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col, COUNT(*) AS num FROM mytable GROUP BY col ORDER BY num;</span><br></pre></td></tr></table></figure>
<p>WHERE过滤行，HAVING过滤分组，行过滤优先</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col, COUNT(*) AS num FROM mytable WHERE col &gt; 2 GROUP BY col HAVING num &gt;= 2;</span><br></pre></td></tr></table></figure>
<p>规定：</p>
</li>
<li><p>GROUP BY出现在WHERE子句之后，ORDER BY子句之前</p>
</li>
<li><p>除了汇总字段外，SELECT语句中的每一字段都必须在GROUP BY子句中给出</p>
</li>
<li><p>NULL的行单独分为一组</p>
</li>
<li><p>大多数SQL实现不支持GROUP BY列具有可变长度的数据类型</p>
</li>
<li><p>子查询<br>子查询中只能返回一个字段的数据，可以将子查询的结果作为WHERE语句的过滤条件</p>
</li>
<li><p>连接<br>连接用于连接多个表，使用JOIN关键字，条件语句用ON。连接可以替换子查询并且效率一般更快<br>内连接，关键字INNER JOIN，可以不明确使用JOIN<br>自连接：连接的表是自身<br>自然连接：NATURAL JOIN自动连接所有同名列，而内连接需要提供连接的列<br>外连接：LEFT OUTER JOIN左外连接寻找符合条件的连接，如果JOIN的左侧表存在没有关联的行，保留左侧表并复制右侧表相关字段为NULL</p>
</li>
<li><p>组合查询<br>UNION组合两个查询，每个查询包含相同列、表达式和聚集函数。默认去除相同行，要保留相同行使用UNION ALL，ORDER BY子句必须位于语句最后</p>
</li>
</ol>
<h3 id="2-连接查询与子查询的比较"><a href="#2-连接查询与子查询的比较" class="headerlink" title="2* 连接查询与子查询的比较"></a>2* 连接查询与子查询的比较</h3><p>连接查询是将多个表按某个条件连接起来，从中选取需要的数据，同时查询多个表使用。不同JOIN：</p>
<ol>
<li>(INNER) JOIN：如果表中列有匹配，返回行</li>
<li>NATURAL JOIN：自动连接所有同名列</li>
<li>OUTER JOIN：如果表中没有匹配，则返回同侧表所有行，其余表不匹配时字段填NULL</li>
</ol>
<p>子查询是一个嵌套在其他语句或子查询中的查询，对于得到的结果可以作为其余查询的条件。</p>
<h3 id="2-drop、delete、truncate-比较"><a href="#2-drop、delete、truncate-比较" class="headerlink" title="2* drop、delete、truncate 比较"></a>2* drop、delete、truncate 比较</h3><p>相同点：truncate、delete和drop都会删除表内的数据<br>不同点：</p>
<ol>
<li>truncate和delete只删除数据不删除表的结构。drop语句将删除表的结构、约束、触发器和索引，truncate删除所有行，但表结构、约束、索引保持不变，新行标识所用的计数值重置，如果想保留标识计数值用delete。</li>
<li>delete语句是数据库操作语言，会放在rollback中，事务提交之后才生效。truncate和drop是数据库定义语言，操作立即生效</li>
<li>速度：drop&gt;truncate&gt;delete，因为delete逐行删除，并在事务日志中记录。</li>
<li>安全性：drop和truncate直接生效，数据直接丢失</li>
<li>使用上：删除部分数据用delete，删除表及结构用drop，保留表而删除所有数据，和事务无关用truncate，和事务有关用delete。</li>
<li>对于外键约束，不能用truncate，应该用不带where的delete。</li>
<li>应用范围：truncate只对table，delete可以是table和view</li>
</ol>
<h3 id="2-视图的作用，以及何时能更新视图"><a href="#2-视图的作用，以及何时能更新视图" class="headerlink" title="2* 视图的作用，以及何时能更新视图"></a>2* 视图的作用，以及何时能更新视图</h3><p>作用：</p>
<ol>
<li>简化复杂的SQL操作，比如复杂的连接</li>
<li>只使用实际表的一部分数据</li>
<li>通过只给用户访问视图的权限，保证数据的安全性</li>
<li>更改数据格式和表示</li>
</ol>
<p>视图是一个虚拟表，没有数据，通过视图更新时要转换到基本表来更新。更新时只能更新权限范围内的数据。<br>可更新的视图，在视图中的行和基表中的行之间有一对一的关系，并且如果包含下述结构的任何一种则不可更新：</p>
<ol>
<li>聚合函数</li>
<li>DISTINCT</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION</li>
<li>位于选择列表中的子查询</li>
<li>join</li>
</ol>
<p>视图虽然可以更新数据，但一般情况下最好将视图视为查询数据的虚拟表，而不是通过视图更新数据，很可能造成数据更新失败</p>
<h3 id="理解存储过程、触发器等作用"><a href="#理解存储过程、触发器等作用" class="headerlink" title="* 理解存储过程、触发器等作用"></a>* 理解存储过程、触发器等作用</h3><p>存储过程是对一系列SQL操作的批处理，好处是：</p>
<ol>
<li>代码封装，保证了一定的安全性</li>
<li>代码复用</li>
<li>由于是预先编译，具有很高的性能</li>
</ol>
<p>命令行创建存储过程需要自定义分隔符。包含in、out和inout三种参数，给变量赋值需要用select into语句，每次只能给一个变量赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line">create procedure myprocedure(out ret int) </span><br><span class="line">    begin</span><br><span class="line"></span><br><span class="line">    end //</span><br><span class="line">delimiter;</span><br><span class="line"></span><br><span class="line">call myprocedure(@ret);</span><br><span class="line">select @ret</span><br></pre></td></tr></table></figure>
<p>触发器会在某个表执行以下语句时自动执行：DELETE、INSERT、UPDATE。触发器必须指定在语句执行之前（BEFORE）还是之后（AFTER）自动执行，BEFORE用于数据验证和净化，AFTER用于审计追踪，将修改记录到另一张表中。<br>INSERT触发器包含一个名为NEW的虚拟表，DELETE包含一个OLD虚拟表，只读。UPDATE有OLD（只读）虚拟表和NEW虚拟表。触发器中不能调用存储过程</p>
<h2 id="系统原理"><a href="#系统原理" class="headerlink" title="系统原理"></a>系统原理</h2><h3 id="3-ACID-的作用以及实现原理"><a href="#3-ACID-的作用以及实现原理" class="headerlink" title="3* ACID 的作用以及实现原理"></a>3* ACID 的作用以及实现原理</h3><ol>
<li>原子性，Atomicity：事务被视为不可分割的最小单位，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用回滚日志实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作</li>
<li>一致性：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>隔离性：一个事务所做的修改在最终提交之前，对其他事务是不可见的。</li>
<li>持久性：一旦事务提交，则其所作的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以使用重做日志保证持久性</li>
</ol>
<p>特性之间的关联：</p>
<ol>
<li>只有满足一致性，事务的执行结果才是正确的</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性</li>
<li>事务满足持久性是应对数据库崩溃的情况</li>
</ol>
<h3 id="3-四大隔离级别，以及不可重复读和幻影读的出现原因"><a href="#3-四大隔离级别，以及不可重复读和幻影读的出现原因" class="headerlink" title="3* 四大隔离级别，以及不可重复读和幻影读的出现原因"></a>3* 四大隔离级别，以及不可重复读和幻影读的出现原因</h3><p>四大隔离级别：</p>
<ol>
<li>未提交读：事务中的修改，即使没有提交，对其他事务也是可见的</li>
<li>提交读：一个事务只能读取已经提交的事务所作的修改，即事务做的修改在提交之前对其他事务不可见</li>
<li>可重复读：保证在同一个事务中多次读取数据的结果是一样的</li>
<li>可串行化：强制事务串行执行，需要加锁实现</li>
</ol>
<p>丢失修改：T1和T2两个数据都对一个数据修改，T1修改后T2随后修改，覆盖了T1的修改<br>脏读：T1修改一个数据，T2随后读取这个数据，如果T1撤销修改，则T2读出的数据是脏数据<br>不可重复读：T2读取一个数据，T1对该数据进行修改，此时T2再读这个数据会得到和第一次不同的结果<br>幻影读：T1读取某个范围的数据，T2在这个范围内插入新数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻影读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读</td>
<td align="center">存在</td>
<td align="center">存在</td>
<td align="center">存在</td>
</tr>
<tr>
<td align="center">提交读</td>
<td align="center">不存在</td>
<td align="center">存在</td>
<td align="center">存在</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">不存在</td>
<td align="center">不存在</td>
<td align="center">存在</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">不存在</td>
<td align="center">不存在</td>
<td align="center">不存在</td>
</tr>
</tbody></table>
<h3 id="2-封锁的类型以及粒度，两段锁协议，隐式和显式锁定"><a href="#2-封锁的类型以及粒度，两段锁协议，隐式和显式锁定" class="headerlink" title="2* 封锁的类型以及粒度，两段锁协议，隐式和显式锁定"></a>2* 封锁的类型以及粒度，两段锁协议，隐式和显式锁定</h3><p>封锁的粒度：行级锁和表级锁。应该尽量只锁定需要的数据，锁定的数据量越少，发生锁争用的可能性越小，系统的并发程度越高。但加锁消耗资源，锁操作会增加系统开销。因此封锁粒度越小，系统开销越大。在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡</p>
<p>封锁的类型：</p>
<ol>
<li>读写锁：分为排他锁（X锁，写锁）和共享锁（S锁，读锁）。一个事务对数据对象A加X锁，则可以读取和更新A，期间其他事务不能对A加任何锁。一个事务对A加S锁，可以对A进行读取操作，但不能更新。期间其他事务能对A加S锁。</li>
<li>意向锁：支持多粒度封锁。在存在行级锁和表级锁的情况下，事务想要对表A加锁，就要检测是否有其他事务对表A或表A的任意一行加锁，需要对A的每一行检测一次，非常耗时。在X/S基础上引入IX/IS作为表级锁，用来表示一个事务想在表中的某个数据行上加S锁或者X锁。规定：1）一个事务在获得对象的S锁之前，必须先获得表的IS锁或者更强的锁；2）一个事务在获得对象的X锁之前，必须先获得表的IX锁。引入意向锁后，如果T想对表A加X锁，先检测是否有其他事务对A加X/IX/IS锁，如果加了就表示其他事务正在使用这个表或表中某一行，加X锁失败。</li>
</ol>
<p>兼容关系<br>|-|X|IX|S|IS|<br>|:–:|:–:|:–:|:–:|:–:|<br>|X|x|x|x|x|<br>|IX|x|√|x|√|<br>|S|x|x|√|√|<br>|IS|x|√|√|√|</p>
<p>两段锁协议：加锁和解锁分为两个阶段进行，先加锁再解锁。可串行化调度是指通过并发控制使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。</p>
<p>隐式与显式锁定：InnoDB存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，被称为隐式锁定。也可以使用特定语句进行显式锁定：select … lock in share mode; select … for update;</p>
<h3 id="3-乐观锁与悲观锁"><a href="#3-乐观锁与悲观锁" class="headerlink" title="3* 乐观锁与悲观锁"></a>3* 乐观锁与悲观锁</h3><p>乐观锁会假设在极大多数情况下不会形成冲突，只有在数据提交的时候，才会对数据是否产生冲突进行检验。如果产生冲突，返回错误信息。MySQL常用的实现方法是版本控制，在数据表中增加一列version，将数据读出时将版本号一起读出，当数据更新时版本号加1，提交数据时判断当前version值和当时读出的version是否相同，相同则说明没有其余事务更新该行，否则取消此次操作</p>
<p>悲观锁假设大多数情况下会冲突，当启动事务时，如果事务的sql语句涉及到索引并用索引进行了条件判断，会使用行级锁锁定要修改的行，否则使用表级锁锁住整张表。</p>
<p>乐观锁并发高性能好，而悲观锁并发不高但不允许脏读。</p>
<h3 id="3-MVCC-原理，当前读以及快照读，Next-Key-Locks-解决幻影读"><a href="#3-MVCC-原理，当前读以及快照读，Next-Key-Locks-解决幻影读" class="headerlink" title="3* MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读"></a>3* MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读</h3><p>MVCC原理：MVCC是多版本并发控制，通过保存数据在某个时间点的快照实现，一个事务无论运行多久，在同一个事务里看到的数据视图是一致的。在MySQL的InnoDB存储引擎中实现提交读和可重复读隔离级别。未提交读总是读到最新的数据行不需要控制，可串行化需要对所有读取行加锁，MVCC无法实现。<br>MVCC使用两个版本号：系统版本号是一个递增的数字，每开始一个新的事务，系统版本号会递增；事务版本号是事务开始时的系统版本号。MVCC在每行后面保存着两个隐藏列：1）创建版本号：创建该数据行快照时的系统版本号；2）删除版本号：如果快照删除版本号为空或大于当前事务版本号表示该快照有效，否则表示已删除。MVCC将使用到的快照保存在Undo日志中，通过回滚指针将一个数据行的所有快照连接起来。<br>基本原理：开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号。</p>
<ol>
<li>select：多个事务必须读取到同一个数据行距离现在最近的一个有效快照。假设当前事务为T，则读的数据行快照的创建版本号必须小于T的版本号，删除版本号必须大于T的版本号或者为空。</li>
<li>insert：当前系统版本号作为数据行快照的创建版本号</li>
<li>delete：当前系统版本号作为数据行快照的删除版本号</li>
<li>update：可以理解为先删后插入，将当前版本号作为更新前的数据行快照的删除版本号，作为更新后的数据行快照的创建版本号</li>
</ol>
<p>快照读：MVCC读取的是快照中的数据，减少加锁开销<br>当前读：读取的是最新的数据，需要加X/S锁</p>
<p>MVCC无法解决幻影读，需要MVCC+Next-Key Locks解决。分为两个Lock</p>
<ol>
<li>Record Locks：锁定一个记录的索引，而不是记录本身。如果表没有索引，InnoDB会自动在主键上创建隐藏的聚簇索引</li>
<li>Gap Locks：锁定索引之间的间隙，但不包含索引本身，即锁定索引的范围。</li>
</ol>
<p>Next-Key Locks结合Record Locks和Gap Locks锁定记录上的索引以及索引之间的间隙</p>
<h3 id="2-范式理论"><a href="#2-范式理论" class="headerlink" title="2* 范式理论"></a>2* 范式理论</h3><p>不符合范式可能产生：冗余数据、修改异常、删除异常和插入异常。<br>函数依赖：A-&gt;B表示B函数依赖于A<br>第一范式：属性不可分<br>第二范式：每个非主键属性完全依赖于键码，可以对表进行拆分实现<br>第三范式：非主键属性不传递函数依赖于键码</p>
<h3 id="3-SQL-与-NoSQL-的比较"><a href="#3-SQL-与-NoSQL-的比较" class="headerlink" title="3* SQL 与 NoSQL 的比较"></a>3* SQL 与 NoSQL 的比较</h3><p>NoSQL是非关系型数据库，可用于超大规模数据的存储。<br>区别：</p>
<ol>
<li>SQL数据库提供关系型表存储数据，NoSQL数据库采用类JSON的键值对存储文档</li>
<li>SQL数据库中，只有事先定义了表和字段的模式才可以添加数据，NoSQL数据库中任何时候都可以添加。</li>
<li>SQL具有数据库的规范化，NoSQL也可以使用规范化，但倾向于非规范化</li>
<li>SQL有join操作，NoSQL没有</li>
<li>SQL具有数据完整性，NoSQL不具备</li>
<li>SQL需要自定义事务，NoSQL操作单文档时具备事务性，操作多文档时不具备</li>
<li>SQL使用SQL语言，NoSQL使用类JSON</li>
<li>NoSQL更快</li>
</ol>
<p>适合使用SQL开发的项目：</p>
<ol>
<li>可以预先定义逻辑相关的离散数据的需求</li>
<li>数据一致性是必要的</li>
<li>具有良好的开发者经验和技术支持的标准的成熟技术</li>
</ol>
<p>适合使用NoSQL开发的项目：</p>
<ol>
<li>不相关，不确定和逐步发展的数据需求</li>
<li>更简单或更宽松的能够快速开始编程的项目</li>
<li>速度和可扩展性至关重要</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="3-B-Tree-原理，与其它查找树的比较"><a href="#3-B-Tree-原理，与其它查找树的比较" class="headerlink" title="3* B+ Tree 原理，与其它查找树的比较"></a>3* B+ Tree 原理，与其它查找树的比较</h3><p>B+Tree基于B树实现，在叶子节点增加顺序访问指针。<br>B树的结构特点：</p>
<ol>
<li>所有键值分布在整个树中，与BST不同的是每个节点可能有多个子节点</li>
<li>任何关键字出现且只出现在一个节点中</li>
<li>搜索有可能在非叶子节点结束</li>
<li>关键字全集内做一次查找性能类似二分查找</li>
</ol>
<p>B+Tree与B树的对比：</p>
<ol>
<li>所有关键字和对应数据存储在叶子节点，非叶子节点用于索引，不存储真正的data，使得一个节点可以存储更多的索引关键字，能索引的范围更大</li>
<li>所有叶子节点具有指向兄弟节点的指针，可以通过顺序访问指针提高区间查询性能，从左到右叶子节点非递减排列</li>
</ol>
<p>与红黑树的比较：</p>
<ol>
<li>更少的查询次数：红黑树的高度h=log2N，而B+树的高度h=logdN，d表示每个节点的出度，高度更小</li>
<li>利用磁盘预读特性：磁盘通过预读来减少磁盘IO操作，并且进行顺序读取不需要进行磁盘寻道，速度很快。内存与磁盘以页为单位交换数据，数据库系统将索引的一个节点的大小设置为页的大小，使得一次IO能完全载入一个节点，利用预读特性，相邻节点也可以预先载入。</li>
</ol>
<h3 id="3-MySQL-索引以及优化"><a href="#3-MySQL-索引以及优化" class="headerlink" title="3* MySQL 索引以及优化"></a>3* MySQL 索引以及优化</h3><p>索引是在存储引擎层实现的，用于中到大型的表比较有效，小型表直接全盘扫描，超大型表维护索引代价高。<br>InnoDB使用B+树作为索引，特点：</p>
<ol>
<li>不需要全盘扫描，只对树进行搜索，查找速度快</li>
<li>B+树有序，除了查找还可用于排序和分组</li>
<li>可以指定多个列为索引列，共同组成键</li>
<li>适用于全键值、键值范围和键最左前缀查找，如果不按照索引列的顺序查找则无法使用索引</li>
<li>B+树索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，被称为聚簇索引。因为无法将数据行存放在两个地方，一个表只能有一个聚簇索引。而辅助索引的叶子节点的data域记录着主键的值，在使用辅助索引查找时，先找到主键，再根据主键在主索引中查找</li>
</ol>
<p>MyISAM的主索引和辅助索引一样，并且和InnoDB不同的是，叶子节点存储的是关键字及其地址，在读取之后需要一次磁盘IO。</p>
<p>哈希索引：能以O(1)时间查找，但失去有序性：无法用于排序和分组以及只支持精确查找，无法用于部分查找。InnoDB存储引擎使用自适应哈希索引：当某个索引值被使用很频繁，会在B+树索引之上创建哈希索引，引入哈希索引快速查找的优点</p>
<p>全文索引：MyISAM存储引擎支持，用于查找文本中的关键词，而不是直接比较是否相等。使用倒排索引实现，记录关键词到所在文档的映射。</p>
<p>空间数据索引：MyISAM支持，会从所有维度来索引数据，可以有效使用任意维度进行组合查询</p>
<p>索引优化：</p>
<ol>
<li>MySQL估计使用索引比全表扫描还慢，不会使用索引。通常返回数据比例越低越容易命中索引。</li>
<li>独立的列：索引列不能是表达式的一部分参与运算，也不能是函数的参数，否则无法使用索引</li>
<li>多列索引：需要多个列作为条件查询时，使用多列索引比使用多个单列索引性能更好。并且查询条件不包含索引列最左边部分时不会命中索引，是指条件列需要包含索引的最左列字段</li>
<li>索引列的顺序：让选择性强的索引放在前面。选择性是指不重复的索引值和记录总数的比值，最大为1.选择性越高，每个记录的区分度越高，查询效率更高</li>
<li>前缀索引：blob、text和varchar类型的列，必须使用前缀索引，前缀的长度需要根据索引选择性确定。前导模糊查询不能命中索引</li>
<li>数据类型隐式转换时不会命中索引，特别是列类型是字符串，要将字符常量值用引号引起来</li>
<li>union、in和or都可以命中索引，建议使用in</li>
<li>or分割的条件，or前列有索引，后面列没有索引，涉及到的索引都不会用</li>
<li>负向条件查询不能用索引，可优化为in查询，例如!=, not in</li>
<li>覆盖索引查询可以避免回表查询，需要索引包含所有需要查询的字段的值。优点：1）索引远小于数据行大小，减少数据访问量；2）MyISAM在内存中只缓存索引，数据依赖于操作系统，只访问索引可以不使用系统调用；3）InnoDB引擎若辅助索引能覆盖查询，无需访问主索引</li>
</ol>
<p>索引优点：</p>
<ol>
<li>大大减少了服务器需要扫描的数据行数</li>
<li>帮助服务器避免排序和分组，以及避免创建临时表</li>
<li>将随机IO变为顺序IO</li>
</ol>
<h3 id="3-查询优化"><a href="#3-查询优化" class="headerlink" title="3* 查询优化"></a>3* 查询优化</h3><ol>
<li>使用Explain分析select来优化查询语句。比较重要的字段有：1）select_type：查询类型，有简单查询、联合查询、子查询等；2）key：使用的索引；3）rows：扫描的行数</li>
<li>优化数据访问：2.1：减少请求的数据量：1）只返回必要的列，不使用select *；2）只返回必要行，使用limit限制；3）缓存重复查询的数据。2.2：减少服务器扫描的行数：使用索引覆盖查询</li>
<li>重构查询方式：1）切分大查询：大查询如果一次性执行，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询；2）分解大连接查询：将大连接查询分解成对每一个表一次单表查询，然后在应用程序中进行关联，好处有：缓存更高效；减少锁竞争；分解成单表查询，缓存结果可能被其他查询使用，减少冗余记录的查询；在应用层进行连接，更容易对数据库进行拆分，更容易做到高性能和可伸缩；查询效率本身可能会提升。</li>
</ol>
<h3 id="3-InnoDB-与-MyISAM-比较"><a href="#3-InnoDB-与-MyISAM-比较" class="headerlink" title="3* InnoDB 与 MyISAM 比较"></a>3* InnoDB 与 MyISAM 比较</h3><p>InnoDB是MySQL默认的事务存储引擎。实现了四个标准的隔离级别，默认是可重复读，并通过MVCC+Next-key Locks防止幻影读。主索引是聚簇索引，在索引中保存了数据，避免直接读取磁盘，提升了查询性能。内部加入很多优化，例如磁盘读取数据时的预读、能加快读操作且自动创建的自适应哈希索引、能加速插入操作的插入缓冲区等。支持真正的在线热备份，获取一致性视图不需要停止对所有表的写入</p>
<p>MyISAM设计简单，数据以紧密格式存储。提供了压缩表、空间数据索引等特性。不支持事务，不支持行级锁。可以手工或者自动执行检查和修复操作，但可能导致一些数据丢失，且修复操作慢</p>
<p>比较：</p>
<ol>
<li>事务：InnoDB是事务型的，可以使用commit和rollback语句，而MyISAM不支持事务</li>
<li>并发：MyISAM只支持表级锁，而InnoDB还支持行级锁</li>
<li>外键：InnoDB支持外键</li>
<li>备份：InnoDB支持热备份</li>
<li>崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，且恢复速度也更慢</li>
<li>MyISAM支持压缩表和空间数据索引</li>
</ol>
<h3 id="2-水平切分与垂直切分"><a href="#2-水平切分与垂直切分" class="headerlink" title="2* 水平切分与垂直切分"></a>2* 水平切分与垂直切分</h3><p>水平切分：将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，使用水平切分可以将数据分布到集群的不同节点上，缓解单个数据库的压力<br>垂直切分：将一张表按列切分成多个表，通常按照列的关系密集程度切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同表中。在数据库层面使用垂直切分将按数据库中表的密集程度部署到不同的库中。</p>
<p>水平切分的策略：</p>
<ol>
<li>哈希取模</li>
<li>范围：时间范围或者ID范围</li>
<li>映射表：使用单独的数据表存储映射关系</li>
</ol>
<p>水平切分问题：</p>
<ol>
<li>事务问题：使用分布式事务</li>
<li>连接：原来连接分解成多个单表查询，然后在用户程序中进行连接</li>
<li>ID唯一性：1）使用全局唯一ID（GUID）；2）为每个分片指定一个ID范围；3）分布式ID生成器，例如twitter的snowflake算法</li>
</ol>
<h3 id="2-主从复制原理、作用、实现"><a href="#2-主从复制原理、作用、实现" class="headerlink" title="2* 主从复制原理、作用、实现"></a>2* 主从复制原理、作用、实现</h3><p>原理：使用三个线程binlog线程、IO线程和SQL线程。</p>
<ol>
<li>binlog线程：负责将主服务器上的数据更改写入二进制日志binary log中</li>
<li>IO线程：负责从主服务器上读取binlog，并写入从服务器的中继日志relay log</li>
<li>SQL线程：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器重放</li>
</ol>
<p>主服务器处理写操作以及实时性要求比较高的读操作，从服务器处理读操作<br>读写分离能提高性能的原因：</p>
<ol>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用</li>
<li>从服务器可以使用MyISAM，提升查询性能以及节约系统开销</li>
<li>增加冗余，提高可用性</li>
</ol>
<p>实现：通过代理方式，代理服务器接收应用层发来的读写请求，然后决定转发到哪个服务器</p>
<h3 id="redo、undo、binlog-日志的作用"><a href="#redo、undo、binlog-日志的作用" class="headerlink" title="* redo、undo、binlog 日志的作用"></a>* redo、undo、binlog 日志的作用</h3><p>redo log作用：确保事务的持久性。防止在发生故障时尚有脏页未写入磁盘，在重启mysql服务时，根据redo log进行重做保证持久性。记录的是物理数据页面修改的信息，事务开始之后就写入redo log，在对应事务的数据写入磁盘后，redo log空间可被覆盖，通常存在Master Thread每秒一次刷新innodb_log_buffer到redo log<br>undo log作用：保存事务发生之前的数据的一个版本，可以用于回滚，同时可以提供MVCC下的读，即非锁定读。执行undo时，将数据从逻辑上恢复到事务之前状态，事务开始之前生成undo log，事务提交之后放入待清理的链表<br>binlog作用：用于复制，在主从复制中，从库利用主库上的binlog重放数据，实现主从同步，也可用于数据库基于时间点的还原。内容包含执行的sql语句及其反向语句，事务提交时产生，超过存活时间后释放。</p>
<p>redo log和binlog的区别：</p>
<ol>
<li>作用不同：redo log保证事务持久性，是事务层面的，而binlog实现还原的功能，是数据库层面的，保护数据的层次不同</li>
<li>内容：redo log是物理日志，是数据页面修改之后的物理记录，而binlog是逻辑日志，记录sql语句及其反向</li>
<li>redo log在事务开始时产生，在数据写入物理磁盘后释放，可被覆盖释放。binlog在事务提交时产生，超过存活时间后释放，被自动删除。</li>
<li>恢复数据的效率：基于物理日志的redo log恢复数据的效率高于binlog。</li>
</ol>
<p>理论上先写redo log，再写binlog，两个日志都写入磁盘，事务才算真正完成</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/interview/" rel="tag"># 面经</a>
              <a href="/tags/DataBase/" rel="tag"># DataBase</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/" rel="prev" title="数据库总结">
      <i class="fa fa-chevron-left"></i> 数据库总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93/" rel="next" title="消息队列总结">
      消息队列总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">高频面试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cyc%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">Cyc高频面试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%89%8B%E5%86%99-SQL-%E8%AF%AD%E5%8F%A5%EF%BC%8C%E7%89%B9%E5%88%AB%E6%98%AF%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.</span> <span class="nav-text">2* 手写 SQL 语句，特别是连接查询与分组查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">4.</span> <span class="nav-text">2* 连接查询与子查询的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-drop%E3%80%81delete%E3%80%81truncate-%E6%AF%94%E8%BE%83"><span class="nav-number">5.</span> <span class="nav-text">2* drop、delete、truncate 比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%95%E6%97%B6%E8%83%BD%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="nav-number">6.</span> <span class="nav-text">2* 视图的作用，以及何时能更新视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E7%AD%89%E4%BD%9C%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">* 理解存储过程、触发器等作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86"><span class="nav-number"></span> <span class="nav-text">系统原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ACID-%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">3* ACID 的作用以及实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E5%BD%B1%E8%AF%BB%E7%9A%84%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.</span> <span class="nav-text">3* 四大隔离级别，以及不可重复读和幻影读的出现原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B0%81%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E7%B2%92%E5%BA%A6%EF%BC%8C%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE%EF%BC%8C%E9%9A%90%E5%BC%8F%E5%92%8C%E6%98%BE%E5%BC%8F%E9%94%81%E5%AE%9A"><span class="nav-number">3.</span> <span class="nav-text">2* 封锁的类型以及粒度，两段锁协议，隐式和显式锁定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">3* 乐观锁与悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-MVCC-%E5%8E%9F%E7%90%86%EF%BC%8C%E5%BD%93%E5%89%8D%E8%AF%BB%E4%BB%A5%E5%8F%8A%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%8CNext-Key-Locks-%E8%A7%A3%E5%86%B3%E5%B9%BB%E5%BD%B1%E8%AF%BB"><span class="nav-number">5.</span> <span class="nav-text">3* MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%8C%83%E5%BC%8F%E7%90%86%E8%AE%BA"><span class="nav-number">6.</span> <span class="nav-text">2* 范式理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-SQL-%E4%B8%8E-NoSQL-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">7.</span> <span class="nav-text">3* SQL 与 NoSQL 的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number"></span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-B-Tree-%E5%8E%9F%E7%90%86%EF%BC%8C%E4%B8%8E%E5%85%B6%E5%AE%83%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.</span> <span class="nav-text">3* B+ Tree 原理，与其它查找树的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-MySQL-%E7%B4%A2%E5%BC%95%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">3* MySQL 索引以及优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">3* 查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-InnoDB-%E4%B8%8E-MyISAM-%E6%AF%94%E8%BE%83"><span class="nav-number">4.</span> <span class="nav-text">3* InnoDB 与 MyISAM 比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86%E4%B8%8E%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86"><span class="nav-number">5.</span> <span class="nav-text">2* 水平切分与垂直切分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%9C%E7%94%A8%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">2* 主从复制原理、作用、实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo%E3%80%81undo%E3%80%81binlog-%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">* redo、undo、binlog 日志的作用</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiahang Gu</p>
  <div class="site-description" itemprop="description">认真学习，享受生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JiahangGu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiahangGu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/fengzhizi76506" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;fengzhizi76506" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiahang Gu</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
