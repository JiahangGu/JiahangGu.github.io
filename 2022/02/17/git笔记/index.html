<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="版本控制系统，Version Control System，VCS。复习一下，看看有没有查漏补缺的地方 实现原理其余VCS存储文件原始版本和随时间的差异。git则是在每个版本保存文件的快照，然后保存快照索引。如果文件没改则保留链接指向之前的文件。（文件很大时快照是不是也很大）查看版本间差异时，git会找到两个版本的文件做本地的差异计算。避免连接远程服务器。git在存储数据前计算校验和，通过校验和确">
<meta property="og:type" content="article">
<meta property="og:title" content="git笔记">
<meta property="og:url" content="http://example.com/2022/02/17/git%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="菜汤里的咸鱼要翻身">
<meta property="og:description" content="版本控制系统，Version Control System，VCS。复习一下，看看有没有查漏补缺的地方 实现原理其余VCS存储文件原始版本和随时间的差异。git则是在每个版本保存文件的快照，然后保存快照索引。如果文件没改则保留链接指向之前的文件。（文件很大时快照是不是也很大）查看版本间差异时，git会找到两个版本的文件做本地的差异计算。避免连接远程服务器。git在存储数据前计算校验和，通过校验和确">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/git/commit-and-tree.png">
<meta property="og:image" content="http://example.com/images/git/commits-and-parents.png">
<meta property="og:image" content="http://example.com/images/git/basic-merging-2.png">
<meta property="og:image" content="http://example.com/images/git/basic-rebase-1.png">
<meta property="og:image" content="http://example.com/images/git/basic-rebase-2.png">
<meta property="og:image" content="http://example.com/images/git/basic-rebase-4.png">
<meta property="og:image" content="http://example.com/images/git/reset-checkout.png">
<meta property="og:image" content="http://example.com/images/git/summary_reset.png">
<meta property="og:image" content="http://example.com/images/git/data-model-1.png">
<meta property="og:image" content="http://example.com/images/git/data-model-3.png">
<meta property="article:published_time" content="2022-02-17T11:43:15.000Z">
<meta property="article:modified_time" content="2022-02-17T12:15:31.553Z">
<meta property="article:author" content="Jiahang Gu">
<meta property="article:tag" content="工具">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/git/commit-and-tree.png">

<link rel="canonical" href="http://example.com/2022/02/17/git%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>git笔记 | 菜汤里的咸鱼要翻身</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">菜汤里的咸鱼要翻身</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/17/git%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiahang Gu">
      <meta itemprop="description" content="认真学习，享受生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜汤里的咸鱼要翻身">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          git笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-17 19:43:15 / 修改时间：20:15:31" itemprop="dateCreated datePublished" datetime="2022-02-17T19:43:15+08:00">2022-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course-notes/" itemprop="url" rel="index"><span itemprop="name">课程笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>版本控制系统，Version Control System，VCS。复习一下，看看有没有查漏补缺的地方</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>其余VCS存储文件原始版本和随时间的差异。git则是在每个版本保存文件的快照，然后保存快照索引。如果文件没改则保留链接指向之前的文件。（文件很大时快照是不是也很大）<br>查看版本间差异时，git会找到两个版本的文件做本地的差异计算。避免连接远程服务器。<br>git在存储数据前计算校验和，通过校验和确保数据没有丢失或损坏。SHA1散列计算。</p>
<h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><ol>
<li>未暂存：修改了文件，没保存到数据库</li>
<li>已暂存：对一个已修改文件的版本标记，包含在下次提交的快照中</li>
<li>已提交：数据保存在本地数据库</li>
</ol>
<p>工作区是项目某个版本内容<br>暂存区是一个文件，保存下次要提交的文件列表信息，在git仓库目录中。git术语叫索引<br>git仓库目录是保存项目元数据和对象数据库的地方。克隆仓库就复制这些数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list --show-origin</span><br><span class="line">$ git config --global user.name <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br><span class="line">$ git config --list</span><br><span class="line"><span class="comment"># 找到git命令的手册</span></span><br><span class="line">$ git <span class="built_in">help</span> &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --<span class="built_in">help</span></span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure>

<p>已跟踪：纳入版本控制的文件<br>未跟踪：其他文件，git status显示的Untracked files下的所有文件<br>Changes to be committed:列出已暂存文件列表<br>Changes not staged for commit: 已跟踪但发生变化，且没放入暂存区<br>git add FILE 是将内容添加到下一次提交中</p>
<p>忽略文件：.gitignore中列出需要忽略的文件模式，可以使用shell的正则表达式，可以以/结尾指定目录</p>
<p>git diff 比较工作目录中当前文件和暂存区快照之间的差异，只显示尚未暂存的改动<br>git diff –staged 对比已暂存文件和最后一次提交的文件的差异</p>
<p>git commit -a -m”” 可以跳过暂存区，自动将所有跟踪过的文件暂存并提交<br>git rm 从暂存区域移除，如果只是在工作目录rm删除则会在未暂存列表中显示</p>
<p>git mv 重命名，等于mv f1 f2, git rm f1, git add f2三条命令</p>
<h3 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h3><p>git log -p -N  显示每次提交引入的差异，diff形式。-N限制最近的N次提交，通常用于代码审查或快速浏览变化<br>git log –stat 查看每次提交的简略统计信息<br>git log –pretty=FORMAT 可以通过不同的格式展示提交历史。比如oneline，short，full等<br>git log –graph 通过DAG的形式展示分支、合并历史<br>git log –since=2.weeks 显示最近两周的提交，还有until显示之前的提交<br>此外还有许多其他的选项，使用时直接查询较为方便，不算常用，粘贴自<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">git中文</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用选项</span></span><br><span class="line">-p</span><br><span class="line"></span><br><span class="line">按补丁格式显示每个提交引入的差异。</span><br><span class="line"></span><br><span class="line">--<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line">显示每次提交的文件修改统计信息。</span><br><span class="line"></span><br><span class="line">--shortstat</span><br><span class="line"></span><br><span class="line">只显示 --<span class="built_in">stat</span> 中最后的行数修改添加移除统计。</span><br><span class="line"></span><br><span class="line">--name-only</span><br><span class="line"></span><br><span class="line">仅在提交信息后显示已修改的文件清单。</span><br><span class="line"></span><br><span class="line">--name-status</span><br><span class="line"></span><br><span class="line">显示新增、修改、删除的文件清单。</span><br><span class="line"></span><br><span class="line">--abbrev-commit</span><br><span class="line"></span><br><span class="line">仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</span><br><span class="line"></span><br><span class="line">--relative-date</span><br><span class="line"></span><br><span class="line">使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。</span><br><span class="line"></span><br><span class="line">--graph</span><br><span class="line"></span><br><span class="line">在日志旁以 ASCII 图形显示分支与合并历史。</span><br><span class="line"></span><br><span class="line">--pretty</span><br><span class="line"></span><br><span class="line">使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。</span><br><span class="line"></span><br><span class="line">--oneline</span><br><span class="line"></span><br><span class="line">--pretty=oneline --abbrev-commit 合用的简写。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制输出的选项</span></span><br><span class="line">-&lt;n&gt;</span><br><span class="line"></span><br><span class="line">仅显示最近的 n 条提交。</span><br><span class="line"></span><br><span class="line">--since, --after</span><br><span class="line"></span><br><span class="line">仅显示指定时间之后的提交。</span><br><span class="line"></span><br><span class="line">--until, --before</span><br><span class="line"></span><br><span class="line">仅显示指定时间之前的提交。</span><br><span class="line"></span><br><span class="line">--author</span><br><span class="line"></span><br><span class="line">仅显示作者匹配指定字符串的提交。</span><br><span class="line"></span><br><span class="line">--committer</span><br><span class="line"></span><br><span class="line">仅显示提交者匹配指定字符串的提交。</span><br><span class="line"></span><br><span class="line">--grep</span><br><span class="line"></span><br><span class="line">仅显示提交说明中包含指定字符串的提交。</span><br><span class="line"></span><br><span class="line">-S</span><br><span class="line"></span><br><span class="line">仅显示添加或删除内容匹配指定字符串的提交。</span><br></pre></td></tr></table></figure>

<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p>git commit –amend  不是修补最后的提交，可以理解是完全用一个新的提交来替换旧的提交。仿佛从来没有出现过，并且是稍微改进，内容较少</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>根据提示操作总没问题，git reset HEAD <file> 来取消暂存的文件</p>
<p>撤销文件的修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>同样根据提示，git add 添加到暂存区，git checkout – <file> 撤销工作目录的修改，在撤销后无法找回。</p>
<p>总之就是记住状态：not staged, staged (to be commited)，commited</p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>给仓库历史的某个提交打标签，表示重要。例如用来标记发布节点v1.0等，但实际没用过，没觉得重要。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="comment"># 显示标签</span></span><br><span class="line">git tag -l <span class="string">&quot;re&quot;</span> <span class="comment"># 按照特定模式查找，必须用-l</span></span><br></pre></td></tr></table></figure>
<p>附注标签：存储在git数据库的完整对象，以及标签信息。通常建议使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.4 -m<span class="string">&quot;必须指定的信息&quot;</span> <span class="comment"># 创建</span></span><br><span class="line">git show v1.4 <span class="comment"># 查看标签及提交信息</span></span><br><span class="line">git tag -a v1.5 9fceb02 <span class="comment"># 为提交历史打标签，后面是散列值</span></span><br></pre></td></tr></table></figure>
<p>轻量标签：将提交校验和保存到文件，没有其他任何信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.4</span><br></pre></td></tr></table></figure>
<p>标签必须通过显式推送到远程，git push origin v1.4<br>git push origin –tags  将所有不在远程仓库的标签全部上传</p>
<p>git tag -d v1.4 删除标签<br>git push origin :refs/tags/v1.4 从远程仓库删除标签<br>git push origin –delete <tagname> 删除远程标签</p>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure>
<p>这个看起来很好用，之前没有试过</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>非常轻量，分支特性是git强大、独特的地方。<br>提交时git需要保存：</p>
<ol>
<li>blob对象，保存文件快照，每个文件对应blob</li>
<li>树对象，记录目录结构和blob对象索引</li>
<li>提交对象，包含指向树对象的指针和所有提交信息</li>
</ol>
<p><img src="/images/git/commit-and-tree.png" alt="如图"><br>首次提交对象以及树结构</p>
<p>继续修改并提交后，每次的提交对象还会包含一个指向上次提交对象即父对象的指针<br><img src="/images/git/commits-and-parents.png" alt="如图"></p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>git branch test 创建一个test分支，本质是创建一个可移动的指针。HEAD特殊指针指向当前的本地分支，在切换分支后HEAD指向对应分支的指针<br>git log –oneline –decorate 可以查看每个分支当前指向的对象<br>使用分支的好处：checkout移动到对应分支后，在其上进行修改和提交，再回到旧分支则依然位于历史提交中，不包含最新提交。<br>分支实质上是包含所指对象校验和的文件（40个字符的SHA1字符串）。</p>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>例如<img src="/images/git/basic-merging-2.png" alt="例图"><br>经过如下的操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master分支指向c2</span></span><br><span class="line">git checkout -b iss53 <span class="comment"># 创建一个分支并将HEAD指针移到新分支</span></span><br><span class="line">git commit -m<span class="string">&quot;&quot;</span> <span class="comment">#iss53上提交</span></span><br><span class="line"><span class="comment"># 此时来了紧急bug，需要保存iss53上的修改，签回到master</span></span><br><span class="line">git commit / git stash <span class="comment"># </span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="comment"># 创建修复bug的分支</span></span><br><span class="line">git checkout -b hotfix</span><br><span class="line">git commit</span><br><span class="line"><span class="comment"># 回到master合并</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge hotfix</span><br><span class="line"><span class="comment"># 此时master分支可以发布，并且指向最新修改</span></span><br><span class="line">git branch -d hotfix</span><br><span class="line"><span class="comment"># 然后回到iss53工作</span></span><br><span class="line">git checkout iss53</span><br><span class="line">git commit </span><br><span class="line"><span class="comment"># 测试通过后，回到master合并</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge iss53</span><br><span class="line">git branch -d iss53</span><br></pre></td></tr></table></figure>
<p>合并发生冲突，主要解释冲突标记的意思</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure>
<p>=======上的是HEAD，即当前所在分支的版本的修改，下面的是要被合并版本的修改</p>
<p>git branch 列出所有分支，带*的是当前分支<br>git branch -v 列出所有分支及最后一次提交<br>git branch -vv 列出所有本地分支，以及更多信息，例如对应远程分支以及本地是否落后<br>git branch –merged 查看哪些分支已经合并到当前分支<br>git branch –no-merged 查看哪些分支没合并到当前分支<br>git branch -d 删除， -D 强制删除（即使有修改未保存）</p>
<h4 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h4><p>参阅<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81">git中文</a>，之前使用的方式感觉像两种混合，导致偶尔会发生混乱。应该确定的使用规范：每个分支名对应iss#，修复bug则可以使用iss#或fixbug。</p>
<p>长期分支：同时拥有多个开放的分支，定期把某些主题分支合并入其他分支。例如master保留完全稳定的代码，develop则是做后续开发，topic和当前工作内容相关。当分支一旦稳定，就合并入master分支。</p>
<p>主题分支：上文示例的iss#和fixbug的用法，是短期分支，用来实现单一特性。可以快速实现上下文切换。方便快速实验想法，以及代码审核。</p>
<p>git push origin serverfix 会自动将serverfix分支名字展开为refs/heads/serverfix:refs/heads/serverfix，即将本地的分支推送到远程的分支，可以通过修改:后的分支改变远程分支</p>
<p>git fetch origin Branch 抓取本地没有的数据<br>git merge 合并数据<br>git pull等同于上述两个，但指南说最好单独使用以上两个命令，不过个人经常使用git pull，不确定这其中有什么问题。</p>
<h4 id="变基与分支合并"><a href="#变基与分支合并" class="headerlink" title="变基与分支合并"></a>变基与分支合并</h4><p>这个样例很经典啊，看完就感觉老衲悟了！参阅<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">git中文</a></p>
<p>假设最初分支长这样<br><img src="/images/git/basic-rebase-1.png" alt="原始"><br>则合并操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge experiment</span><br></pre></td></tr></table></figure>
<p>之后长这样<br><img src="/images/git/basic-rebase-2.png" alt="合并"><br>即会找到两个分支的最近公共祖先进行三方合并，将两个分支的修改内容改到一起。但是看log不是单个分支<br>但是变基操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout experiment</span><br><span class="line">git rebase master</span><br><span class="line"><span class="comment"># 这意思就是找到最近公共祖先C2，然后对比当前分支相对于该祖先的历次提交，提取相应修改为临时文件，将当前分支指向C3，最后将临时文件的修改按顺序应用到新分支</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge experiment</span><br></pre></td></tr></table></figure>
<p>此时得到<br><img src="/images/git/basic-rebase-4.png" alt="变基"><br>基本变基就是这样，提到的一个特性是，假设有master，server，client分支，client分支从server中签出来，但是在提交时只希望提交client的修改，则可以只将client的修改在master分支重放并提交。</p>
<p>变基的风险：如果提交存在于你的仓库之外，而别人可能基于这些提交开发，那就不要变基。<br>翻译了就是：在你本地提交到远程仓库之前，以及在你提交远程但别人没有pull之前，都可以变基，否则变基会修改此前的提交对象的内容，如父对象指针，这时别人在分支上提交时发现引入多余的提交但却是相同的修改内容。<br>使用git pull –rebase，可以在本地分支完成变基。</p>
<p>合并和变基的对比：<br>合并会保留原本的提交历史，能够让后人查阅所有痕迹。<br>变基则认为提交历史是过程中发生的事，类似于草稿，应该以简介的形式给人看</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><h4 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="集成管理者工作流"></a>集成管理者工作流</h4><p>github常用的</p>
<ol>
<li>项目维护者推送到主仓库。</li>
<li>贡献者克隆此仓库，做出修改。</li>
<li>贡献者将数据推送到自己的公开仓库。</li>
<li>贡献者给维护者发送邮件，请求拉取自己的更新。</li>
<li>维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。</li>
<li>维护者将合并后的修改推送到主仓库。</li>
</ol>
<h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h4><p>个人使用，AB同时克隆，A提交后，B提交被拒绝，提示本地落后，则需要本地先git pull合并后再提交</p>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>派生一个项目</li>
<li>从 master 分支创建一个新分支</li>
<li>提交一些修改来改进项目</li>
<li>将这个分支推送到 GitHub 上</li>
<li>创建一个拉取请求</li>
<li>讨论，根据实际情况继续修改</li>
<li>项目的拥有者合并或关闭你的拉取请求</li>
<li>将更新后的 master 分支同步到你的派生中</li>
</ol>
<p>贡献者的操作流程</p>
<ol>
<li>将派生出的副本克隆到本地</li>
<li>创建出名称有意义的分支</li>
<li>修改代码</li>
<li>检查改动</li>
<li>将改动提交到分支中</li>
<li>将新分支推送到 GitHub 的副本中</li>
</ol>
<p>此时查看自己的副本仓库，会显示让我们检查改动，并给源项目创建拉取请求。点击create pull request后，源项目拥有者会受到提醒。</p>
<h3 id="Git工具"><a href="#Git工具" class="headerlink" title="Git工具"></a>Git工具</h3><p>SHA1散列函数默认使用7位十六进制足以无冲突的表示所有提交。<br>git show lc002d 显示提交信息<br>git rev-parse BRANCH 可以看到对应分支指向哪个提交</p>
<p>git reflog 查看引用日志（仅存在于本地仓库），记录最近几月HEAD和分支指向的历史，@{n}可以引用reflog输出的提交记录，^会解析位该引用的上一个提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEAD~表示HEAD的父提交</span><br><span class="line">HEAD~N表示HEAD的第N父提交</span><br></pre></td></tr></table></figure>

<h4 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两点 ..</span></span><br><span class="line">git <span class="built_in">log</span> master..b1 <span class="comment"># git选出在b1分支但是不在master分支的提交</span></span><br><span class="line">git <span class="built_in">log</span> origin/master..HEAD <span class="comment"># 选出在当前分支但不在远程的提交</span></span><br><span class="line">git <span class="built_in">log</span> refA refB ^refC <span class="comment"># 在A、B中包含但不被C包含的提交，^和--not表示不被包含</span></span><br><span class="line"><span class="comment"># 三点 ...</span></span><br><span class="line">git <span class="built_in">log</span> b1...b2 <span class="comment"># 选择出被两个之一包含但又不被同时包含</span></span><br></pre></td></tr></table></figure>

<h4 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add -i</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]<span class="built_in">dd</span> untracked</span><br><span class="line">  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp</span><br><span class="line">What now&gt;</span><br></pre></td></tr></table></figure>
<p>staged显示已暂存的修改，unstaged显示未暂存的修改，path显示对应文件。Commands显示命令，包括2u更新到暂存，3r取消暂存，4a添加跟踪文件，5p针对补丁操作（git会询问想暂存哪些文件的哪些部分，对每个部分git会逐个显示区间并询问），6d查询修改</p>
<h4 id="贮藏与清理"><a href="#贮藏与清理" class="headerlink" title="贮藏与清理"></a>贮藏与清理</h4><p>stash和clean<br>git stash 会贮藏文件的修改和暂存的改动，并将未完成的修改保存到栈中。通常用于不想因为一点修改并要切换到其他分支而创建一个提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash list <span class="comment"># 列出所有修改，栈形式保存</span></span><br><span class="line">git stash apply stash@&#123;n&#125; <span class="comment"># 指定应用栈中第n个贮藏到当前分支，默认是栈顶。这里只是应用，对应的内容还在堆栈中保存</span></span><br><span class="line">git stash drop stash@&#123;n&#125; <span class="comment"># 删除指定贮藏</span></span><br><span class="line">git stash pop <span class="comment"># 删除栈顶</span></span><br><span class="line">git stash -u <span class="comment"># stash指挥贮藏已修改和暂存的已跟踪文件，指明-u才会贮藏未跟踪文件，-a还会包含被.gitignore忽略的文件</span></span><br><span class="line">git stash --patch <span class="comment"># 不贮藏所有修改，交互式询问想贮藏哪些</span></span><br><span class="line">git stash branch BRANCH <span class="comment"># 创建一个新分支，找出贮藏时的提交，并重新应用贮藏的修改，并从栈中删除 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clean <span class="comment"># 移除未被追踪的文件，被移除的无法追回，git stash --all更安全</span></span><br><span class="line">git clean -n <span class="comment"># 做一次将要移除什么的演习，只给你看看受影响的文件，不删除</span></span><br><span class="line">-i <span class="comment"># 交互模式</span></span><br></pre></td></tr></table></figure>

<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>git grep，从提交历史、工作目录、文件内容或索引中找出正则表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git grep -n RE <span class="comment"># -n打印匹配到的行号，-c输出概述，每个文件包含多少个匹配，-p显示匹配的字符串所在的方法，--and确保多个匹配出现在同一个文本行。还可以在旧版本里查找</span></span><br><span class="line">git <span class="built_in">log</span> -S XX <span class="comment"># 找出XX相关的新增和删除该字符串的提交，-G可以使用正则表达式</span></span><br><span class="line">git <span class="built_in">log</span> -L :git_deflate_bound:zlib.c <span class="comment"># 查看 zlib.c 文件中 git_deflate_bound` 函数的每一次变更</span></span><br></pre></td></tr></table></figure>

<h4 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h4><p>只能在提交到远程服务器之前修改。<br>git commit –amend 修改最近一次提交<br>运行git rebase -i可以修改提交信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3 <span class="comment"># 会显示如下命令，此时尝试修改最近三次提交</span></span><br><span class="line"></span><br><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 710f0f8..a5f4a0d onto 710f0f8</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment"># .       create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment"># .       message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure>
<p>上述的顺序是与log反序，即最上面的是最旧的提交，可以与下文对比</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> HEAD~3..HEAD</span><br><span class="line">a5f4a0d added cat-file</span><br><span class="line">310154e updated README formatting and added blame</span><br><span class="line">f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure>

<p>如果想修改第三次提交，修改pick为edit。保存并退出，则得到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3</span><br><span class="line">Stopped at f7f3f6d... changed my name a bit</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">       git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">       git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>然后按照提示即可。这里edit在多次commit之后，会把edit对应的提交拆分成多个提交，并重新计算SHA1和</p>
<p>移除提交以及重新排序，可以删除pick对应的提交整行，然后调整pick的顺序修改提交的顺序。</p>
<p>可以压缩提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">squash 310154e updated README formatting and added blame</span><br><span class="line">squash a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>
<p>pick改为squash会将三次提交变为一个，即squash的提交会合并到上一个</p>
<h4 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h4><p>参阅<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86">git中文</a>介绍的非常详细，这里做下简单记录，有需要还是要看原文<br>主要指的是reset和checkout命令<br>主要是三个概念（想象成树）要理解</p>
<ol>
<li>HEAD：上次提交的快照，通常指向所在分支的最后一个提交。仅是一个指针</li>
<li>Index：索引，也是暂存区，是预期的下一次提交，也就是修改文件并add之后，文件保存的地方</li>
<li>工作目录：自己电脑上的文件。</li>
</ol>
<p>工作流程：以修改文件为例，文件修改后会在工作目录保存，在git add之后会添加到暂存区，最后commit之后才会生成提交，并移动HEAD指针指向该提交。<br>而如果修改文件没暂存或提交，通过git status查看，即<br>Changes not staged for commit：表示对应条目在工作目录与暂存区之间存在不同，需要add<br>Changes to be committed：表示HEAD所指版本与暂存区内容不同。通过commit<br>如果没有输出，显示clean，则表示三个树相同。</p>
<p>在检出分支时，会将HEAD移动到新分支的引用，然后将暂存区填充为该提交对应的快照，最后将暂存区的内容复制到工作目录。</p>
<p>而reset会执行三个操作</p>
<ol>
<li>移动HEAD，仅将HEAD指针移到目标提交，暂存区和工作目录内容不变，等同于–soft。此时用git status会看到绿色标出的HEAD和索引的区别，即是commit执行之前的状态</li>
<li>然后更新索引,–mixed，会用HEAD当前指向的快照内容更新暂存区，即add执行之前的状态。</li>
<li>最后更新工作目录,–hard，会将暂存区的内容更新到工作目录。这是无法撤销的，比较危险。</li>
</ol>
<p>总结：reset以特定顺序重写三棵树</p>
<ol>
<li>移动 HEAD 分支的指向 （若指定了 –soft，则到此停止）</li>
<li>使索引看起来像 HEAD （若未指定 –hard，则到此停止）</li>
<li>使工作目录看起来像索引</li>
</ol>
<p>重置文件<br>如果指定文件路径，会跳过移动HEAD，继续2、3步。<br>git reset file.txt，等于git reset –mixed HEAD file.txt，即将HEAD的快照中该文件的内容复制到暂存区，等于git add file.txt的逆过程。<br>git reset eb43bf file.txt 可以从指定提交恢复文件</p>
<p>git checkout <branch> 则是移动HEAD指针到对应的分支最后一个提交。<br>与reset的区别如图<img src="/images/git/reset-checkout.png" alt="区别"><br>而git checkout [branch] file 会用该分支的最后一个提交恢复文件，并且会覆盖工作目录，等同于git reset –hard [branch] file</p>
<p>最后用个图总结<br><img src="/images/git/summary_reset.png" alt="总结"></p>
<h3 id="Git自定义配置"><a href="#Git自定义配置" class="headerlink" title="Git自定义配置"></a>Git自定义配置</h3><p>git的三个配置文件<br>/etc/gitconfig<br>~/.gitconfig<br>.git/config<br>从上到下会被一次覆盖</p>
<h4 id="Git钩子"><a href="#Git钩子" class="headerlink" title="Git钩子"></a>Git钩子</h4><p>参阅<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">git中文</a><br>钩子绝大部分存在.git/hooks，初始化时会放示例脚本。也可以用ruby和py脚本。</p>
<p>提交工作流钩子</p>
<ol>
<li>pre-commit钩子在键入提交信息前运行。检查即将提交的快照，比如可以用来检查代码风格是否一致等，如果非零值退出，会放弃此次提交。</li>
<li>prepare-commit-msg 钩子在启动提交信息编辑器之前，默认信息被创建之后运行，接收参数，并结合提交模板动态插入提交信息。</li>
<li>commit-msg 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。</li>
<li>post-commit 钩子在整个提交过程完成后运行。通常用于通知</li>
</ol>
<p>客户端钩子和服务器端钩子，看过之后发现平时甚至没见过，感觉用途不是很广，留坑。</p>
<h3 id="Git底层原理"><a href="#Git底层原理" class="headerlink" title="Git底层原理"></a>Git底层原理</h3><p>.git目录包含所有git存储和操作的东西，像备份或复制版本库，只拷贝这个目录即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -F1</span><br><span class="line">config</span><br><span class="line">description</span><br><span class="line">HEAD</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">refs/</span><br></pre></td></tr></table></figure>
<p>目录结构解释：</p>
<ol>
<li>config，项目配置</li>
<li>info，全局性排除，放置不希望被记录在.gitignore文件的忽略模式。（没理解，是记录被git忽略的文件？）</li>
<li>hooks，包含客户端或服务器的钩子脚本</li>
<li>HEAD，指向目前被检出的分支，也就是现在用的分支</li>
<li>objects，存储所有数据内容，应该是所有保存的文件快照</li>
<li>refs，存储指向数据（分支、远程仓库和标签等）的提交对象的指针</li>
<li>index，保存暂存区信息</li>
</ol>
<p>Git是一个内容寻址文件系统，核心是KV数据库。任意数据保存在.git/objects时通过一个唯一键指向。git hash-object 命令可以查看数据的键，即数据校验和。git cat-file -p SHA1值 可以根据键取出数据。-p由git解析文件类型，-t返回存储的对象类型。比如blob。<br>单个文件对应的是blob对象，此外还有树对象，类似于目录项，而数据对象则对应inodes或文件内容。<br>一个树包含多条树对象记录，每个记录包含指向数据对象或子树对象的SHA1指针，以及相应模式、类型、文件名信息。<br>举例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br></pre></td></tr></table></figure>
<p>可以看出，lib对象是tree类型，表示指针，指向另一个树对象。类似这样<br><img src="/images/git/data-model-1.png" alt="数据模型"><br>git在创建一个树对象前要暂存一些文件来创建暂存区。<br>git update-index可以为单独文件创建一个暂存区，并且需要加上–add追踪文件以及–cacheinfo选项（文件在git hash-object后仅在数据库，而不是当前工作目录），最后指定文件模式（100644普通文件，100755可执行文件，120000符号链接）。</p>
<p>现在，git write-tree将暂存区写入树对象。即为暂存区中的文件创建树。</p>
<p>这时暂存区包含两个blob。此时使用<br>git read-tree –prefix=bak d8329f<br>可以把已有的树对象作为子数读入暂存区，即d8329f指向的树对象</p>
<p>最后提交对象，通过<br>git commit-tree d8329f<br>可以发起一次提交<br>然后对于之前通过git write-tree创建的树对象，通过<br>git commit-tree 0155eb -p fdf4fc<br>其中-p可以引用一个提交作为父提交对象，即在log中之后的提交。<br>此时运行git log就可以看到所有的log，符合上文的提交顺序。</p>
<p>git add 和 git commit 命令，git所作的工作就是将改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建指明顶层树对象和父提交的提交对象。<br>git对象：数据对象、树对象和提交对象，最初以单独文件形式保存在.git/objects下。内部指针指向对象如图所示<br><img src="/images/git/data-model-3.png" alt="指针对象"></p>
<h4 id="Git引用"><a href="#Git引用" class="headerlink" title="Git引用"></a>Git引用</h4><p>git log 1a410e 可以查看以1a410e开始往前的历史。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/refs</span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/heads</span><br><span class="line">.git/refs/tags</span><br></pre></td></tr></table></figure>
<p>.git/refs中包含所有引用文件，文件中包含对象的SHA1值。<br>git update-ref refs/heads/master 1a410e 可以为该对象创建一个引用，即master。<br>而创建一个分支，则可以使用<br>git update-ref refs/heads/<branch> 目标提交对象SHA1值，作用等同于在当前分支reset到目标提交对象，然后创建分支</p>
<p>HEAD是一个符号引用，指向目前所在分支。<br>查看HEAD文件内容可能是，ref: refs/heads/master。等切换分支，则更新HEAD文件。</p>
<p>git symbolic-ref HEAD 查看HEAD引用的值<br>git symbolic-ref HEAD refs/heads/test 等同于git checkout test</p>
<p>标签引用类似于提交对象，但通常指向提交对象，是一个永不移动的分支引用，为其加个更好的名字。<br>git update-ref refs/tags/v1.0 SHA1值 创建标签</p>
<h4 id="git包文件，数据压缩和gc"><a href="#git包文件，数据压缩和gc" class="headerlink" title="git包文件，数据压缩和gc"></a>git包文件，数据压缩和gc</h4><p>例如提交一个22k的文件<br>使用git cat-file -s SHA1 可以查看对象大小<br>此时追加一个字符，发现新生成的blob对象依然是22k<br>这两个几乎完全相同，浪费空间。如果保存其中一个，在保存其中的差异可以节约空间。</p>
<p>git最初在磁盘存储的是松散对象，即每个文件一个，但会经常打包成packfile的二进制文件，节省空间提高效率。<br>git会打包的三种情况：</p>
<ol>
<li>版本库太多松散对象</li>
<li>手动执行git gc</li>
<li>向远程服务器推送</li>
</ol>
<p>例如执行git gc后，会出现新的文件.git/objects/info/packs，以及未被任何提交引用的数据对象，还有新创建的包文件和索引，包文件包含从文件系统移除的所有对象的内容，索引包含文件的偏移信息，可以快速定位指定对象。<br>git verify-pack 可以查看已打包的内容</p>
<p>引用规范，在.git/config中定义，例如执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure>
<p>之后会添加</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/schacon/simplegit-progit</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">  push = refs/heads/master:refs/heads/qa/master</span><br></pre></td></tr></table></figure>
<p>格式为+<src>:<dst>，src是模式，代表远程版本库的引用，dst是本地跟踪的远程引用的位置，+表示git即使不能fast-forward时也要强制更新。<br>有命名空间的通配符，可以获取所有分支，如果指定分支如refs/heads/master，则只能获取master的数据。</p>
<p>git gc 会收集所有松散对象并将它们放置到包文件中， 将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。此外还有打包引用到一个单独的文件。原本在.git/refs中保存的引用会移动到.git/packed-refs。</p>
<p>数据恢复：执行reset –hard之后，恢复点之后的数据丢失。需要找出最后一次提交的SHA1值然后增加一个指向它的分支。<br>通过 git reflog 可以查看每次改变HEAD时的值，每次提交或改变分支时会被更新。<br>通过git log -g 会以标准日志格式输出引用日志。<br>找到需要恢复的提交对象的SHA1后，通过<br>git branch <branch> SHA1值<br>可以创建一个新分支恢复被删除的提交。</p>
<p>如果reflog中不含信息，则可以使用<br>git fsck –full<br>显示所有没被其他对象指向的对象，然后通过dangling commit后的SHA1创建分支恢复。</p>
<p>有用的环境变量参阅<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">git中文</a></p>
<h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><h4 id="zsh中使用"><a href="#zsh中使用" class="headerlink" title="zsh中使用"></a>zsh中使用</h4><p>在~/.zshrc中添加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">autoload</span> -Uz vcs_info</span><br><span class="line"><span class="function"><span class="title">precmd_vcs_info</span></span>() &#123; vcs_info &#125;</span><br><span class="line">precmd_functions+=( precmd_vcs_info )</span><br><span class="line"><span class="built_in">setopt</span> prompt_subst</span><br><span class="line">RPROMPT=\<span class="variable">$vcs_info_msg_0_</span></span><br><span class="line"><span class="comment"># PROMPT=\$vcs_info_msg_0_&#x27;%# &#x27;</span></span><br><span class="line"><span class="built_in">zstyle</span> <span class="string">&#x27;:vcs_info:git:*&#x27;</span> formats <span class="string">&#x27;%b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Git常见命令参阅<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%85%8D%E7%BD%AE">git中文</a>，这里不再摘录。</p>
<p>一个很好的错误使用以及如何恢复的示例，<a target="_blank" rel="noopener" href="https://ohshitgit.com/zh">oh Shit Git</a>。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/tools/" rel="tag"># 工具</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%99%E8%82%B2%E7%AC%94%E8%AE%B0/" rel="prev" title="计算机缺失的教育笔记">
      <i class="fa fa-chevron-left"></i> 计算机缺失的教育笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/17/MapReduce%E7%AC%94%E8%AE%B0/" rel="next" title="MapReduce笔记">
      MapReduce笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="nav-number">2.</span> <span class="nav-text">文件状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95"><span class="nav-number">3.</span> <span class="nav-text">历史记录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%A4%E9%94%80"><span class="nav-number">3.1.</span> <span class="nav-text">撤销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE"><span class="nav-number">3.2.</span> <span class="nav-text">标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%AB%E5%90%8D"><span class="nav-number">3.3.</span> <span class="nav-text">别名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF"><span class="nav-number">4.</span> <span class="nav-text">分支</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF"><span class="nav-number">4.1.</span> <span class="nav-text">创建分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"><span class="nav-number">4.2.</span> <span class="nav-text">合并分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">4.3.</span> <span class="nav-text">分支开发工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA%E4%B8%8E%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"><span class="nav-number">4.4.</span> <span class="nav-text">变基与分支合并</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E7%AE%A1%E7%90%86%E8%80%85%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">5.1.</span> <span class="nav-text">集成管理者工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">5.2.</span> <span class="nav-text">集中式工作流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Github"><span class="nav-number">6.</span> <span class="nav-text">Github</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">6.1.</span> <span class="nav-text">流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git%E5%B7%A5%E5%85%B7"><span class="nav-number">7.</span> <span class="nav-text">Git工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E5%8C%BA%E9%97%B4"><span class="nav-number">7.1.</span> <span class="nav-text">提交区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98"><span class="nav-number">7.2.</span> <span class="nav-text">交互式暂存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86"><span class="nav-number">7.3.</span> <span class="nav-text">贮藏与清理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2"><span class="nav-number">7.4.</span> <span class="nav-text">搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2"><span class="nav-number">7.5.</span> <span class="nav-text">重写历史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE"><span class="nav-number">7.6.</span> <span class="nav-text">重置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE"><span class="nav-number">8.</span> <span class="nav-text">Git自定义配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Git%E9%92%A9%E5%AD%90"><span class="nav-number">8.1.</span> <span class="nav-text">Git钩子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">Git底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Git%E5%BC%95%E7%94%A8"><span class="nav-number">9.1.</span> <span class="nav-text">Git引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#git%E5%8C%85%E6%96%87%E4%BB%B6%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%92%8Cgc"><span class="nav-number">9.2.</span> <span class="nav-text">git包文件，数据压缩和gc</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git%E4%BD%BF%E7%94%A8"><span class="nav-number">10.</span> <span class="nav-text">Git使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#zsh%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-number">10.1.</span> <span class="nav-text">zsh中使用</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiahang Gu</p>
  <div class="site-description" itemprop="description">认真学习，享受生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JiahangGu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiahangGu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/fengzhizi76506" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;fengzhizi76506" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiahang Gu</span>

</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
